#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VOLUME_Reinforcements

#include "Basic.hpp"

#include "VOLUME_Reinforcements_classes.hpp"
#include "VOLUME_Reinforcements_parameters.hpp"


namespace SDK
{

// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.ExecuteUbergraph_VOLUME_Reinforcements
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::ExecuteUbergraph_VOLUME_Reinforcements(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "ExecuteUbergraph_VOLUME_Reinforcements");

	Params::VOLUME_Reinforcements_C_ExecuteUbergraph_VOLUME_Reinforcements Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "ReceiveEndPlay");

	Params::VOLUME_Reinforcements_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AVOLUME_Reinforcements_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.IsReinforcementCooldownFinished
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::IsReinforcementCooldownFinished(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "IsReinforcementCooldownFinished");

	Params::VOLUME_Reinforcements_C_IsReinforcementCooldownFinished Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.IsVolumePerceptibleForAmbush
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APAWN_Hacker_Simple_C*            HackerPawn                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::IsVolumePerceptibleForAmbush(class APAWN_Hacker_Simple_C* HackerPawn, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "IsVolumePerceptibleForAmbush");

	Params::VOLUME_Reinforcements_C_IsVolumePerceptibleForAmbush Parms{};

	Parms.HackerPawn = HackerPawn;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.GetReinforcementBox
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FBox                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::GetReinforcementBox(struct FBox* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "GetReinforcementBox");

	Params::VOLUME_Reinforcements_C_GetReinforcementBox Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.HasAnyFunctionalLogisticsLifts
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::HasAnyFunctionalLogisticsLifts(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "HasAnyFunctionalLogisticsLifts");

	Params::VOLUME_Reinforcements_C_HasAnyFunctionalLogisticsLifts Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.CanTriggerAmbush
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::CanTriggerAmbush(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "CanTriggerAmbush");

	Params::VOLUME_Reinforcements_C_CanTriggerAmbush Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.CanSpawnAsEcology
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             EnemyClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::CanSpawnAsEcology(TSoftClassPtr<class UClass> EnemyClass, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "CanSpawnAsEcology");

	Params::VOLUME_Reinforcements_C_CanSpawnAsEcology Parms{};

	Parms.EnemyClass = EnemyClass;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.InitializeReinforcementVolume
// (Protected, BlueprintCallable, BlueprintEvent)

void AVOLUME_Reinforcements_C::InitializeReinforcementVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "InitializeReinforcementVolume");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.OnEnemySpawned
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::OnEnemySpawned(class APAWN_Enemy_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "OnEnemySpawned");

	Params::VOLUME_Reinforcements_C_OnEnemySpawned Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.SpawnReinforcementsAsEcology
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftClassPtr<class UClass>             PreferredEnemyClass                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// int32                                   DesiredCount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CountSpawned                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::SpawnReinforcementsAsEcology(TSoftClassPtr<class UClass> PreferredEnemyClass, int32 DesiredCount, int32* CountSpawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "SpawnReinforcementsAsEcology");

	Params::VOLUME_Reinforcements_C_SpawnReinforcementsAsEcology Parms{};

	Parms.PreferredEnemyClass = PreferredEnemyClass;
	Parms.DesiredCount = DesiredCount;

	UObject::ProcessEvent(Func, &Parms);

	if (CountSpawned != nullptr)
		*CountSpawned = Parms.CountSpawned;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.EVENT_OnSpawnedEnemyDied
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::EVENT_OnSpawnedEnemyDied(class APAWN_SystemShockCharacter_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "EVENT_OnSpawnedEnemyDied");

	Params::VOLUME_Reinforcements_C_EVENT_OnSpawnedEnemyDied Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.EVENT_OnSpawnEcologyReinforcements
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bResult                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<struct FVector4>                 WeightedWorldLocations                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AVOLUME_Reinforcements_C::EVENT_OnSpawnEcologyReinforcements(bool bResult, const TArray<struct FVector4>& WeightedWorldLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "EVENT_OnSpawnEcologyReinforcements");

	Params::VOLUME_Reinforcements_C_EVENT_OnSpawnEcologyReinforcements Parms{};

	Parms.bResult = bResult;
	Parms.WeightedWorldLocations = std::move(WeightedWorldLocations);

	UObject::ProcessEvent(Func, &Parms);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.IsReinforcementVolumeOccupied
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IgnorePlayer                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::IsReinforcementVolumeOccupied(bool IgnorePlayer, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "IsReinforcementVolumeOccupied");

	Params::VOLUME_Reinforcements_C_IsReinforcementVolumeOccupied Parms{};

	Parms.IgnorePlayer = IgnorePlayer;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.IsHackerNearAnyLogisticsLift
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APAWN_Hacker_Simple_C*            HackerPawn                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::IsHackerNearAnyLogisticsLift(class APAWN_Hacker_Simple_C* HackerPawn, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "IsHackerNearAnyLogisticsLift");

	Params::VOLUME_Reinforcements_C_IsHackerNearAnyLogisticsLift Parms{};

	Parms.HackerPawn = HackerPawn;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.HasNearbyEnemyOfClass
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             EnemyClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::HasNearbyEnemyOfClass(TSoftClassPtr<class UClass> EnemyClass, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "HasNearbyEnemyOfClass");

	Params::VOLUME_Reinforcements_C_HasNearbyEnemyOfClass Parms{};

	Parms.EnemyClass = EnemyClass;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.HasAnyNearbySpawnedEnemies
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AVOLUME_Reinforcements_C::HasAnyNearbySpawnedEnemies(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "HasAnyNearbySpawnedEnemies");

	Params::VOLUME_Reinforcements_C_HasAnyNearbySpawnedEnemies Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.GetEnemyClassToSpawn
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             EnemyClass                                             (Parm, OutParm, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::GetEnemyClassToSpawn(TSoftClassPtr<class UClass>* EnemyClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "GetEnemyClassToSpawn");

	Params::VOLUME_Reinforcements_C_GetEnemyClassToSpawn Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EnemyClass != nullptr)
		*EnemyClass = Parms.EnemyClass;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.GetReinforcedEnemyName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           EnemyClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             EnemyName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::GetReinforcedEnemyName(class UClass* EnemyClass, class FName* EnemyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "GetReinforcedEnemyName");

	Params::VOLUME_Reinforcements_C_GetReinforcedEnemyName Parms{};

	Parms.EnemyClass = EnemyClass;

	UObject::ProcessEvent(Func, &Parms);

	if (EnemyName != nullptr)
		*EnemyName = Parms.EnemyName;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.SpawnReinforcementsAsAmbush
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftClassPtr<class UClass>             PreferredEnemyClass                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// int32                                   DesiredCount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CountSpawned                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::SpawnReinforcementsAsAmbush(TSoftClassPtr<class UClass> PreferredEnemyClass, int32 DesiredCount, int32* CountSpawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "SpawnReinforcementsAsAmbush");

	Params::VOLUME_Reinforcements_C_SpawnReinforcementsAsAmbush Parms{};

	Parms.PreferredEnemyClass = PreferredEnemyClass;
	Parms.DesiredCount = DesiredCount;

	UObject::ProcessEvent(Func, &Parms);

	if (CountSpawned != nullptr)
		*CountSpawned = Parms.CountSpawned;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.EVENT_OnSpawnAmbushEnemy
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AINTERACT_LogisticsLift_C*        LogisticsLift                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           CargoActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AVOLUME_Reinforcements_C::EVENT_OnSpawnAmbushEnemy(class AINTERACT_LogisticsLift_C* LogisticsLift, class AActor* CargoActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "EVENT_OnSpawnAmbushEnemy");

	Params::VOLUME_Reinforcements_C_EVENT_OnSpawnAmbushEnemy Parms{};

	Parms.LogisticsLift = LogisticsLift;
	Parms.CargoActor = CargoActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.ShouldSaveActor
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStreamingSaveGameActorParams    Params_0                                               (Parm, OutParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AVOLUME_Reinforcements_C::ShouldSaveActor(struct FStreamingSaveGameActorParams* Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "ShouldSaveActor");

	Params::VOLUME_Reinforcements_C_ShouldSaveActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Params_0 != nullptr)
		*Params_0 = std::move(Parms.Params_0);

	return Parms.ReturnValue;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.ReceivePendingBodyTransforms
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FTransform>               BodyTransforms                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AVOLUME_Reinforcements_C::ReceivePendingBodyTransforms(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<struct FTransform>& BodyTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "ReceivePendingBodyTransforms");

	Params::VOLUME_Reinforcements_C_ReceivePendingBodyTransforms Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.BodyTransforms = std::move(BodyTransforms);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function VOLUME_Reinforcements.VOLUME_Reinforcements_C.ReceivePendingCharacterVelocity
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Velocity                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AVOLUME_Reinforcements_C::ReceivePendingCharacterVelocity(const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VOLUME_Reinforcements_C", "ReceivePendingCharacterVelocity");

	Params::VOLUME_Reinforcements_C_ReceivePendingCharacterVelocity Parms{};

	Parms.Velocity = std::move(Velocity);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

