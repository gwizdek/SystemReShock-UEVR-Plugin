#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InventoryBag

#include "Basic.hpp"

#include "CoreGame_classes.hpp"
#include "STRUCT_InventoryBagParams_structs.hpp"
#include "ENUM_CardinalDirection_structs.hpp"
#include "ENUM_UpgradeResult_structs.hpp"
#include "ENUM_InventorySlotType_structs.hpp"
#include "ENUM_ItemType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass InventoryBag.InventoryBag_C
// 0x00A0 (0x00C8 - 0x0028)
class UInventoryBag_C final : public UWorldObject
{
public:
	struct FSTRUCT_InventoryBagParams             BagParams;                                         // 0x0028(0x0030)(Edit, BlueprintVisible, SaveGame, ExposeOnSpawn, HasGetValueTypeHash)
	TSet<class UITEM_Base_C*>                     ItemSet;                                           // 0x0058(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TArray<class UITEM_Base_C*>                   ItemSlots;                                         // 0x00A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	FMulticastInlineDelegateProperty_             OnBagChanged;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)

public:
	void OnBagChanged__DelegateSignature(int32 SlotIndex);
	void InitializeBag();
	void TryFixupBag(const struct FSTRUCT_InventoryBagParams& DefaultParams, bool* Result);
	void GetInventory(class UCOMP_Inventory_C** Inventory);
	void IsOverflowBag(bool* Result);
	void AddItemInternal(class UITEM_Base_C* Item, class UClass* ItemClass, const struct FSTRUCT_ItemInsertionRules& InsertionRules, bool Modify, int32& InOutCount, bool* Result);
	void AddItemToSlotInternal(int32 SlotIndex, class UITEM_Base_C* Item, class UClass* ItemClass, bool IsRotated, bool Modify, int32& InOutCount, bool* Result);
	void GetSlotCountRequiredForItem(int32 SlotIndex, class UITEM_Base_C* Item, class UClass* ItemClass, int32* Result);
	void GetSlotIndicesForItemWithSize(int32 SlotIndex, const struct FIntPoint& ItemSize, TArray<int32>* SlotIndices);
	void GetSlotIndicesForItemInstance(class UITEM_Base_C* Item, TArray<int32>* Slot_Indices);
	void IsValidSlotIndex(int32 SlotIndex, bool* Result);
	void IsValidGridCoordinates(const struct FIntPoint& GridCoords, bool* Result);
	void IsSlotTypeGrid(bool* Result);
	void IsSlotTypeSingle(bool* Result);
	void HasSlotSpaceForItemWithSize(int32 SlotIndex, const struct FIntPoint& ItemSize, class UITEM_Base_C* IgnoreItem, bool* Result);
	void GetMaxSlots(int32* Count);
	void SetMaxSlotCount(int32 NewSlotCount, bool* Result);
	void CreateItemInSlot(int32 SlotIndex, class UITEM_Base_C* Item, class UClass* ItemClass, bool IsRotated, int32 Count, class UITEM_Base_C** ItemCreated);
	void ResizeBag(int32 Size, bool* Result);
	void ForceEquipItemInSlot(int32 SlotIndex, bool* Result);
	void SetEquipSlotActive(int32 SlotIndex, bool Active, bool* Result);
	void AddItem(class UITEM_Base_C* Item, bool* Result);
	void AddItemToSlot(class UITEM_Base_C* Item, int32 SlotIndex, bool* Result);
	void SortBag(bool* Result);
	bool CompareItems(class UObject* ObjectA, class UObject* ObjectB);
	void CanSlotItemType(ENUM_ItemType ItemType, bool* Result);
	void RequiresItemType(ENUM_ItemType ItemType, bool* Result);
	void GetItemCount(TSoftClassPtr<class UClass> ItemClass, int32 MaxCount, class UITEM_Base_C* IgnoreItem, int32* Result);
	void GetTotalItemCount(int32* Count);
	void RemoveItemCount(class UITEM_Base_C* Item, int32 Count, class UITEM_Base_C** RemovedItem);
	void CleanupSlot(class UITEM_Base_C* Item, bool* Result);
	void GetItemArray(TArray<class UITEM_Base_C*>* Items);
	void BeginPlay();
	void GetBagName(class FName* BagName);
	void IsBagEmpty(bool* Result);
	void RemoveItem(class UITEM_Base_C* Item, class UITEM_Base_C** RemovedItem);
	void GetSlotType(ENUM_InventorySlotType* SlotType);
	void GetGridSlotIndices(int32 SlotIndex, int32 StartWidthOffset, int32 StartHeightOffset, int32 EndWidthOffset, int32 EndHeightOffset, TArray<int32>* SlotIndices);
	void GetGridSlotIndicesForItemWithSize(int32 SlotIndex, const struct FIntPoint& ItemSize, TArray<int32>* ResultIndices);
	void HasGridSpaceForItemWithSize(int32 SlotIndex, const struct FIntPoint& ItemSize, class UITEM_Base_C* IgnoreItem, bool* Result);
	void GetGridWidth(int32* Result);
	void GetGridHeight(int32* Result);
	void GetSlotItem(int32 SlotIndex, class UITEM_Base_C** Item);
	void GetGridHeightAtHorizontalSlotIndex(int32 SlotLocation, int32* Result);
	void GetItemGridSize(class UITEM_Base_C* Item, class UClass* ItemClass, struct FIntPoint* Result);
	void GetGridCoordinatesFromSlotIndex(int32 SlotIndex, struct FIntPoint* GridCoords);
	void GetSlotIndexFromGridCoordinates(const struct FIntPoint& GridCoords, int32* SlotIndex);
	void IsSlottedItemContainedByItem(class UITEM_Base_C* SlottedItem, int32 ContainmentSlotIndex, class UITEM_Base_C* ContainmentItem, bool* Result);
	void GetItemsInSlots(TArray<int32>& SlotIndices, TArray<class UITEM_Base_C*>* Items);
	void CanAddItem(class UITEM_Base_C* Item, bool IgnoreCurrentInventory, bool* Result);
	void CanAddItemToSlot(class UITEM_Base_C* Item, int32 SlotIndex, bool IgnoreCurrentInventory, bool* Result);
	void FindItem(class UClass* ItemClass, bool RequireUnslottable, bool AnyDerivedClass, class UITEM_Base_C** FoundItem);
	void FindItemBySoftClass(TSoftClassPtr<class UClass> ItemClass, bool RequireUnslottable, class UITEM_Base_C** FoundItem);
	void FindAndApplyUpgrade(class UITEM_UpgradeBase_C* UpgradeItem, class UClass* UpgradeClass, ENUM_UpgradeResult* Result);
	void FindItemToUpgrade(class UClass* UpgradeClass, class UITEM_UpgradeBase_C** Item, ENUM_UpgradeResult* Result);
	void GetItemsByClass(class UClass* ItemClass, TArray<class UITEM_Base_C*>* Result);
	void CanSlotItemClass(class UClass* ItemClass, bool* Result);
	void GrantItem(const struct FSTRUCT_HardItemParams& ItemParams, bool* Result);
	void GrantItemsFromPackage(class UClass* PackageClass, bool* Result);
	void MoveItemCount(class UITEM_Base_C* Item, int32 Count, int32 SlotIndex, class UInventoryBag_C* MultiSwapBag, int32 MultiSwapSlotIndex, bool MultiSwapRotated, bool* Result);
	void CanMoveItemCount(class UITEM_Base_C* Item, int32 Count, int32 SlotIndex, class UInventoryBag_C* MultiSwapBag, int32 MultiSwapSlotIndex, bool MultiSwapRotated, bool* Result);
	void MoveItem(class UITEM_Base_C* Item, int32 SlotIndex, class UInventoryBag_C* MultiSwapBag, int32 MultiSwapSlotIndex, bool MultiSwapRotated, bool* Result);
	void CanMoveItem(class UITEM_Base_C* Item, int32 SlotIndex, class UInventoryBag_C* MultiSwapBag, int32 MultiSwapSlotIndex, bool MultiSwapRotated, bool* Result);
	void CombineItemsInternal(class UITEM_Base_C* ItemSrc, class UITEM_Base_C* ItemDst, int32 Count);
	void SwapSlotsInternal(class UITEM_Base_C* SourceItem, class UITEM_Base_C* TargetItem, int32 SlotIndex, class UInventoryBag_C* SwapBag, int32 SwapSlotIndex);
	void CleanupSlotInternal(class UITEM_Base_C* Item);
	void PlaceItemInSlotInternal(class UITEM_Base_C* Item, int32 SlotIndex);
	void RemoveItemCountByClass(TSoftClassPtr<class UClass> ItemClass, int32 DesiredCount, bool PrioritizeSmallStacks, int32* RemovedCount);
	void GetItemRotatedGridSize(class UITEM_Base_C* Item, class UClass* ItemClass, bool IsRotated, struct FIntPoint* Result);
	void GetBestSlotInCardinalDirection(int32 SlotIndex, ENUM_CardinalDirection Direction, int32* Result);
	void GetFirstOccupiedSlotIndex(int32* Result);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"InventoryBag_C">();
	}
	static class UInventoryBag_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryBag_C>();
	}
};
static_assert(alignof(UInventoryBag_C) == 0x000008, "Wrong alignment on UInventoryBag_C");
static_assert(sizeof(UInventoryBag_C) == 0x0000C8, "Wrong size on UInventoryBag_C");
static_assert(offsetof(UInventoryBag_C, BagParams) == 0x000028, "Member 'UInventoryBag_C::BagParams' has a wrong offset!");
static_assert(offsetof(UInventoryBag_C, ItemSet) == 0x000058, "Member 'UInventoryBag_C::ItemSet' has a wrong offset!");
static_assert(offsetof(UInventoryBag_C, ItemSlots) == 0x0000A8, "Member 'UInventoryBag_C::ItemSlots' has a wrong offset!");
static_assert(offsetof(UInventoryBag_C, OnBagChanged) == 0x0000B8, "Member 'UInventoryBag_C::OnBagChanged' has a wrong offset!");

}

