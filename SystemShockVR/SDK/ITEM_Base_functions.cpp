#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ITEM_Base

#include "Basic.hpp"

#include "ITEM_Base_classes.hpp"
#include "ITEM_Base_parameters.hpp"


namespace SDK
{

// Function ITEM_Base.ITEM_Base_C.DropEvent__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APICKUP_Base_C*                   Pickup                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::DropEvent__DelegateSignature(class APICKUP_Base_C* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "DropEvent__DelegateSignature");

	Params::ITEM_Base_C_DropEvent__DelegateSignature Parms{};

	Parms.Pickup = Pickup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ITEM_Base.ITEM_Base_C.CountChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UITEM_Base_C*                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::CountChanged__DelegateSignature(class UITEM_Base_C* Item, int32 Count_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "CountChanged__DelegateSignature");

	Params::ITEM_Base_C_CountChanged__DelegateSignature Parms{};

	Parms.Item = Item;
	Parms.Count_0 = Count_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ITEM_Base.ITEM_Base_C.GetInventory
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UCOMP_Inventory_C*                Inventory                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetInventory(class UCOMP_Inventory_C** Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetInventory");

	Params::ITEM_Base_C_GetInventory Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Inventory != nullptr)
		*Inventory = Parms.Inventory;
}


// Function ITEM_Base.ITEM_Base_C.IsStackable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::IsStackable(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "IsStackable");

	Params::ITEM_Base_C_IsStackable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.ShouldAutoEquip
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::ShouldAutoEquip(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "ShouldAutoEquip");

	Params::ITEM_Base_C_ShouldAutoEquip Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.HasLinkedPickup
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::HasLinkedPickup(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "HasLinkedPickup");

	Params::ITEM_Base_C_HasLinkedPickup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetLinkedPickup
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APICKUP_Base_C*                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetLinkedPickup(class APICKUP_Base_C** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetLinkedPickup");

	Params::ITEM_Base_C_GetLinkedPickup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.DestroyLinkedPickup
// (Public, BlueprintCallable, BlueprintEvent)

void UITEM_Base_C::DestroyLinkedPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "DestroyLinkedPickup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ITEM_Base.ITEM_Base_C.AddCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CountToAdd                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UITEM_Base_C*                     SourceItem                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ResultCount                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::AddCount(int32 CountToAdd, class UITEM_Base_C* SourceItem, int32* ResultCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "AddCount");

	Params::ITEM_Base_C_AddCount Parms{};

	Parms.CountToAdd = CountToAdd;
	Parms.SourceItem = SourceItem;

	UObject::ProcessEvent(Func, &Parms);

	if (ResultCount != nullptr)
		*ResultCount = Parms.ResultCount;
}


// Function ITEM_Base.ITEM_Base_C.SetInventory
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCOMP_Inventory_C*                NewInventory                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::SetInventory(class UCOMP_Inventory_C* NewInventory, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "SetInventory");

	Params::ITEM_Base_C_SetInventory Parms{};

	Parms.NewInventory = NewInventory;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.OnInventoryChanged
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCOMP_Inventory_C*                PrevInventory                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::OnInventoryChanged(class UCOMP_Inventory_C* PrevInventory, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "OnInventoryChanged");

	Params::ITEM_Base_C_OnInventoryChanged Parms{};

	Parms.PrevInventory = PrevInventory;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.InitializeItem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInventoryBag_C*                  Bag_0                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::InitializeItem(class UInventoryBag_C* Bag_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "InitializeItem");

	Params::ITEM_Base_C_InitializeItem Parms{};

	Parms.Bag_0 = Bag_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ITEM_Base.ITEM_Base_C.SetInventoryLocation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInventoryBag_C*                  NewBag                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewSlotIndex                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::SetInventoryLocation(class UInventoryBag_C* NewBag, int32 NewSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "SetInventoryLocation");

	Params::ITEM_Base_C_SetInventoryLocation Parms{};

	Parms.NewBag = NewBag;
	Parms.NewSlotIndex = NewSlotIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ITEM_Base.ITEM_Base_C.OnAddedToInventory
// (Public, BlueprintCallable, BlueprintEvent)

void UITEM_Base_C::OnAddedToInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "OnAddedToInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ITEM_Base.ITEM_Base_C.GetCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetCount(int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetCount");

	Params::ITEM_Base_C_GetCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetSlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetSlotIndex(int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetSlotIndex");

	Params::ITEM_Base_C_GetSlotIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetBag
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UInventoryBag_C*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetBag(class UInventoryBag_C** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetBag");

	Params::ITEM_Base_C_GetBag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.ShouldForceEquip
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::ShouldForceEquip(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "ShouldForceEquip");

	Params::ITEM_Base_C_ShouldForceEquip Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.CanUnslot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::CanUnslot(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "CanUnslot");

	Params::ITEM_Base_C_CanUnslot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.OnBeginPlay
// (Public, BlueprintCallable, BlueprintEvent)

void UITEM_Base_C::OnBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "OnBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ITEM_Base.ITEM_Base_C.CanDropItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::CanDropItem(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "CanDropItem");

	Params::ITEM_Base_C_CanDropItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.IsDestructible
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::IsDestructible(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "IsDestructible");

	Params::ITEM_Base_C_IsDestructible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.DestroyItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::DestroyItem(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "DestroyItem");

	Params::ITEM_Base_C_DestroyItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.OnRemovedFromInventory
// (Public, BlueprintCallable, BlueprintEvent)

void UITEM_Base_C::OnRemovedFromInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "OnRemovedFromInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ITEM_Base.ITEM_Base_C.TryDropItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        RelativeOffset                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::TryDropItem(class USceneComponent* SceneComponent, const struct FVector2D& RelativeOffset, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "TryDropItem");

	Params::ITEM_Base_C_TryDropItem Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.RelativeOffset = std::move(RelativeOffset);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.IsDeployed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::IsDeployed(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "IsDeployed");

	Params::ITEM_Base_C_IsDeployed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.TryDropAndPushItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        RelativeOffset                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::TryDropAndPushItem(class USceneComponent* SceneComponent, const struct FVector2D& RelativeOffset, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "TryDropAndPushItem");

	Params::ITEM_Base_C_TryDropAndPushItem Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.RelativeOffset = std::move(RelativeOffset);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.CreateDroppedPickupItem
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        RelativeOffset                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APICKUP_Base_C*                   PickupActor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::CreateDroppedPickupItem(class USceneComponent* SceneComponent, const struct FVector2D& RelativeOffset, class APICKUP_Base_C** PickupActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "CreateDroppedPickupItem");

	Params::ITEM_Base_C_CreateDroppedPickupItem Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.RelativeOffset = std::move(RelativeOffset);

	UObject::ProcessEvent(Func, &Parms);

	if (PickupActor != nullptr)
		*PickupActor = Parms.PickupActor;
}


// Function ITEM_Base.ITEM_Base_C.CreateLinkedPickupItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       PickupTransform                                        (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// class APICKUP_Base_C*                   PickupActor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::CreateLinkedPickupItem(const struct FTransform& PickupTransform, class APICKUP_Base_C** PickupActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "CreateLinkedPickupItem");

	Params::ITEM_Base_C_CreateLinkedPickupItem Parms{};

	Parms.PickupTransform = std::move(PickupTransform);

	UObject::ProcessEvent(Func, &Parms);

	if (PickupActor != nullptr)
		*PickupActor = Parms.PickupActor;
}


// Function ITEM_Base.ITEM_Base_C.SetLinkedPickup
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APICKUP_Base_C*                   PickupActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::SetLinkedPickup(class APICKUP_Base_C* PickupActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "SetLinkedPickup");

	Params::ITEM_Base_C_SetLinkedPickup Parms{};

	Parms.PickupActor = PickupActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ITEM_Base.ITEM_Base_C.IsSlotted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::IsSlotted(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "IsSlotted");

	Params::ITEM_Base_C_IsSlotted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.IsEquipped
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::IsEquipped(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "IsEquipped");

	Params::ITEM_Base_C_IsEquipped Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.IsActivatable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::IsActivatable(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "IsActivatable");

	Params::ITEM_Base_C_IsActivatable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.SetItemGridSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FIntPoint                        NewSize                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::SetItemGridSize(const struct FIntPoint& NewSize, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "SetItemGridSize");

	Params::ITEM_Base_C_SetItemGridSize Parms{};

	Parms.NewSize = std::move(NewSize);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.OnBecomeActivatable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::OnBecomeActivatable(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "OnBecomeActivatable");

	Params::ITEM_Base_C_OnBecomeActivatable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.OnBecomeUnactivatable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::OnBecomeUnactivatable(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "OnBecomeUnactivatable");

	Params::ITEM_Base_C_OnBecomeUnactivatable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.SetEquipped
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::SetEquipped(bool State, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "SetEquipped");

	Params::ITEM_Base_C_SetEquipped Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.SetActivatableInternal
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::SetActivatableInternal(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "SetActivatableInternal");

	Params::ITEM_Base_C_SetActivatableInternal Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ITEM_Base.ITEM_Base_C.Activate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::Activate(class APAWN_SystemShockCharacter_C* Character, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "Activate");

	Params::ITEM_Base_C_Activate Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.Deactivate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::Deactivate(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "Deactivate");

	Params::ITEM_Base_C_Deactivate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.IsEquippable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::IsEquippable(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "IsEquippable");

	Params::ITEM_Base_C_IsEquippable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetInventoryItemDetailsClass
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UClass*                           InventoryItemDetailsWidget                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetInventoryItemDetailsClass(class UClass** InventoryItemDetailsWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetInventoryItemDetailsClass");

	Params::ITEM_Base_C_GetInventoryItemDetailsClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InventoryItemDetailsWidget != nullptr)
		*InventoryItemDetailsWidget = Parms.InventoryItemDetailsWidget;
}


// Function ITEM_Base.ITEM_Base_C.TryHandleDropEvent
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        RelativeOffset                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::TryHandleDropEvent(class USceneComponent* SceneComponent, const struct FVector2D& RelativeOffset, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "TryHandleDropEvent");

	Params::ITEM_Base_C_TryHandleDropEvent Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.RelativeOffset = std::move(RelativeOffset);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.ForceHandleDropEvent
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        RelativeOffset                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::ForceHandleDropEvent(class USceneComponent* SceneComponent, const struct FVector2D& RelativeOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "ForceHandleDropEvent");

	Params::ITEM_Base_C_ForceHandleDropEvent Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.RelativeOffset = std::move(RelativeOffset);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ITEM_Base.ITEM_Base_C.CanBecomeActivatable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::CanBecomeActivatable(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "CanBecomeActivatable");

	Params::ITEM_Base_C_CanBecomeActivatable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetHotbarSlottableObject
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TScriptInterface<class IINTERF_HotbarSlottable_C>SlottableObject                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::GetHotbarSlottableObject(bool* Valid, TScriptInterface<class IINTERF_HotbarSlottable_C>* SlottableObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetHotbarSlottableObject");

	Params::ITEM_Base_C_GetHotbarSlottableObject Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;

	if (SlottableObject != nullptr)
		*SlottableObject = Parms.SlottableObject;
}


// Function ITEM_Base.ITEM_Base_C.GetIsActivated
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::GetIsActivated(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetIsActivated");

	Params::ITEM_Base_C_GetIsActivated Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetDisplayName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             Result                                                 (Parm, OutParm)

void UITEM_Base_C::GetDisplayName(class FText* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetDisplayName");

	Params::ITEM_Base_C_GetDisplayName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function ITEM_Base.ITEM_Base_C.GetShortDisplayName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             Result                                                 (Parm, OutParm)

void UITEM_Base_C::GetShortDisplayName(class FText* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetShortDisplayName");

	Params::ITEM_Base_C_GetShortDisplayName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function ITEM_Base.ITEM_Base_C.GetDescription
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             Result                                                 (Parm, OutParm)

void UITEM_Base_C::GetDescription(class FText* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetDescription");

	Params::ITEM_Base_C_GetDescription Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function ITEM_Base.ITEM_Base_C.CanActivate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::CanActivate(class APAWN_SystemShockCharacter_C* Character, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "CanActivate");

	Params::ITEM_Base_C_CanActivate Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetOwnerActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    PrevIfNoInventory                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           Actor                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetOwnerActor(bool PrevIfNoInventory, class AActor** Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetOwnerActor");

	Params::ITEM_Base_C_GetOwnerActor Parms{};

	Parms.PrevIfNoInventory = PrevIfNoInventory;

	UObject::ProcessEvent(Func, &Parms);

	if (Actor != nullptr)
		*Actor = Parms.Actor;
}


// Function ITEM_Base.ITEM_Base_C.GetOwnerCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Character                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetOwnerCharacter(class APAWN_SystemShockCharacter_C** Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetOwnerCharacter");

	Params::ITEM_Base_C_GetOwnerCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Character != nullptr)
		*Character = Parms.Character;
}


// Function ITEM_Base.ITEM_Base_C.GetBestPickupClass
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UClass*                           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetBestPickupClass(class UClass** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetBestPickupClass");

	Params::ITEM_Base_C_GetBestPickupClass Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetIconRenderClassCollection
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FObjectClassCollection           Result                                                 (Parm, OutParm, HasGetValueTypeHash)

void UITEM_Base_C::GetIconRenderClassCollection(struct FObjectClassCollection* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetIconRenderClassCollection");

	Params::ITEM_Base_C_GetIconRenderClassCollection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function ITEM_Base.ITEM_Base_C.TryRotateItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    RequiresUnslot                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::TryRotateItem(bool* Result, bool* RequiresUnslot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "TryRotateItem");

	Params::ITEM_Base_C_TryRotateItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (RequiresUnslot != nullptr)
		*RequiresUnslot = Parms.RequiresUnslot;
}


// Function ITEM_Base.ITEM_Base_C.SetIsRotated
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewIsRotated                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::SetIsRotated(bool NewIsRotated, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "SetIsRotated");

	Params::ITEM_Base_C_SetIsRotated Parms{};

	Parms.NewIsRotated = NewIsRotated;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function ITEM_Base.ITEM_Base_C.CanRotateItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    RequiresUnslot                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::CanRotateItem(bool* Result, bool* RequiresUnslot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "CanRotateItem");

	Params::ITEM_Base_C_CanRotateItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (RequiresUnslot != nullptr)
		*RequiresUnslot = Parms.RequiresUnslot;
}


// Function ITEM_Base.ITEM_Base_C.IsItemRotated
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::IsItemRotated(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "IsItemRotated");

	Params::ITEM_Base_C_IsItemRotated Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function ITEM_Base.ITEM_Base_C.GetOriginalGridSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FIntPoint                        Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetOriginalGridSize(struct FIntPoint* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetOriginalGridSize");

	Params::ITEM_Base_C_GetOriginalGridSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function ITEM_Base.ITEM_Base_C.GetRotatedGridSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FIntPoint                        Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetRotatedGridSize(struct FIntPoint* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetRotatedGridSize");

	Params::ITEM_Base_C_GetRotatedGridSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function ITEM_Base.ITEM_Base_C.EVENT_OnPushDroppedPickup
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APICKUP_Base_C*                   Pickup                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::EVENT_OnPushDroppedPickup(class APICKUP_Base_C* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "EVENT_OnPushDroppedPickup");

	Params::ITEM_Base_C_EVENT_OnPushDroppedPickup Parms{};

	Parms.Pickup = Pickup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ITEM_Base.ITEM_Base_C.GetGridSizeForDesiredRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    DesiredState                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FIntPoint                        Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UITEM_Base_C::GetGridSizeForDesiredRotation(bool DesiredState, struct FIntPoint* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "GetGridSizeForDesiredRotation");

	Params::ITEM_Base_C_GetGridSizeForDesiredRotation Parms{};

	Parms.DesiredState = DesiredState;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function ITEM_Base.ITEM_Base_C.HasWorldInteraction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UITEM_Base_C::HasWorldInteraction(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ITEM_Base_C", "HasWorldInteraction");

	Params::ITEM_Base_C_HasWorldInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}

}

