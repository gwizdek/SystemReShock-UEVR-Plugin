#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: COMP_HackerInventory

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "AttributeSystem_structs.hpp"
#include "STRUCT_WeaponRecoilTemplate_structs.hpp"


namespace SDK::Params
{

// Function COMP_HackerInventory.COMP_HackerInventory_C.OnWeaponHolstered__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct COMP_HackerInventory_C_OnWeaponHolstered__DelegateSignature final
{
public:
	class UITEM_WeaponBase_C*                     Weapon;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_OnWeaponHolstered__DelegateSignature) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_OnWeaponHolstered__DelegateSignature");
static_assert(sizeof(COMP_HackerInventory_C_OnWeaponHolstered__DelegateSignature) == 0x000008, "Wrong size on COMP_HackerInventory_C_OnWeaponHolstered__DelegateSignature");
static_assert(offsetof(COMP_HackerInventory_C_OnWeaponHolstered__DelegateSignature, Weapon) == 0x000000, "Member 'COMP_HackerInventory_C_OnWeaponHolstered__DelegateSignature::Weapon' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.OnWeaponDrawn__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct COMP_HackerInventory_C_OnWeaponDrawn__DelegateSignature final
{
public:
	class UITEM_WeaponBase_C*                     Weapon;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_OnWeaponDrawn__DelegateSignature) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_OnWeaponDrawn__DelegateSignature");
static_assert(sizeof(COMP_HackerInventory_C_OnWeaponDrawn__DelegateSignature) == 0x000008, "Wrong size on COMP_HackerInventory_C_OnWeaponDrawn__DelegateSignature");
static_assert(offsetof(COMP_HackerInventory_C_OnWeaponDrawn__DelegateSignature, Weapon) == 0x000000, "Member 'COMP_HackerInventory_C_OnWeaponDrawn__DelegateSignature::Weapon' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.OnEquippedWeaponChanged__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct COMP_HackerInventory_C_OnEquippedWeaponChanged__DelegateSignature final
{
public:
	class UITEM_WeaponBase_C*                     EquippedWeapon;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_OnEquippedWeaponChanged__DelegateSignature) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_OnEquippedWeaponChanged__DelegateSignature");
static_assert(sizeof(COMP_HackerInventory_C_OnEquippedWeaponChanged__DelegateSignature) == 0x000008, "Wrong size on COMP_HackerInventory_C_OnEquippedWeaponChanged__DelegateSignature");
static_assert(offsetof(COMP_HackerInventory_C_OnEquippedWeaponChanged__DelegateSignature, EquippedWeapon) == 0x000000, "Member 'COMP_HackerInventory_C_OnEquippedWeaponChanged__DelegateSignature::EquippedWeapon' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.ExecuteUbergraph_COMP_HackerInventory
// 0x0008 (0x0008 - 0x0000)
struct COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory final
{
public:
	int32                                         EntryPoint;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         K2Node_Event_DeltaSeconds;                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory) == 0x000004, "Wrong alignment on COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory");
static_assert(sizeof(COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory) == 0x000008, "Wrong size on COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory");
static_assert(offsetof(COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory, EntryPoint) == 0x000000, "Member 'COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory::EntryPoint' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory, K2Node_Event_DeltaSeconds) == 0x000004, "Member 'COMP_HackerInventory_C_ExecuteUbergraph_COMP_HackerInventory::K2Node_Event_DeltaSeconds' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.ReceiveTick
// 0x0004 (0x0004 - 0x0000)
struct COMP_HackerInventory_C_ReceiveTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_ReceiveTick) == 0x000004, "Wrong alignment on COMP_HackerInventory_C_ReceiveTick");
static_assert(sizeof(COMP_HackerInventory_C_ReceiveTick) == 0x000004, "Wrong size on COMP_HackerInventory_C_ReceiveTick");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveTick, DeltaSeconds) == 0x000000, "Member 'COMP_HackerInventory_C_ReceiveTick::DeltaSeconds' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.HasDiscoveredHeroicItem
// 0x0020 (0x0020 - 0x0000)
struct COMP_HackerInventory_C_HasDiscoveredHeroicItem final
{
public:
	class UClass*                                 HeroicItemClass;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CallFunc_GetHeroicItemClass_HeroicItemClass;       // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Set_Contains_ReturnValue;                 // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_HasDiscoveredHeroicItem) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_HasDiscoveredHeroicItem");
static_assert(sizeof(COMP_HackerInventory_C_HasDiscoveredHeroicItem) == 0x000020, "Wrong size on COMP_HackerInventory_C_HasDiscoveredHeroicItem");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredHeroicItem, HeroicItemClass) == 0x000000, "Member 'COMP_HackerInventory_C_HasDiscoveredHeroicItem::HeroicItemClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredHeroicItem, Result) == 0x000008, "Member 'COMP_HackerInventory_C_HasDiscoveredHeroicItem::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredHeroicItem, CallFunc_GetHeroicItemClass_HeroicItemClass) == 0x000010, "Member 'COMP_HackerInventory_C_HasDiscoveredHeroicItem::CallFunc_GetHeroicItemClass_HeroicItemClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredHeroicItem, CallFunc_Set_Contains_ReturnValue) == 0x000018, "Member 'COMP_HackerInventory_C_HasDiscoveredHeroicItem::CallFunc_Set_Contains_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.HasDiscoveredSuperiorHeroicItem
// 0x0068 (0x0068 - 0x0000)
struct COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem final
{
public:
	class UClass*                                 HeroicItemClass;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 HeroricUpgradeClass;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 K2Node_ClassDynamicCast_AsITEM_Upgrade_Base;       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_ClassDynamicCast_bSuccess;                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Temp_int_Array_Index_Variable;                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         Temp_int_Loop_Counter_Variable;                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Add_IntInt_ReturnValue;                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UClass*>                         CallFunc_Set_ToArray_Result;                       // 0x0030(0x0010)(ReferenceParm)
	int32                                         CallFunc_Array_Length_ReturnValue;                 // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CallFunc_Array_Get_Item;                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Less_IntInt_ReturnValue;                  // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 K2Node_ClassDynamicCast_AsITEM_Upgrade_Base_1;     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_ClassDynamicCast_bSuccess_1;                // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsUpgradeRecurse_Result;                  // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem");
static_assert(sizeof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem) == 0x000068, "Wrong size on COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, HeroicItemClass) == 0x000000, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::HeroicItemClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, Result) == 0x000008, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, HeroricUpgradeClass) == 0x000010, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::HeroricUpgradeClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, K2Node_ClassDynamicCast_AsITEM_Upgrade_Base) == 0x000018, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::K2Node_ClassDynamicCast_AsITEM_Upgrade_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, K2Node_ClassDynamicCast_bSuccess) == 0x000020, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::K2Node_ClassDynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, Temp_int_Array_Index_Variable) == 0x000024, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::Temp_int_Array_Index_Variable' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, Temp_int_Loop_Counter_Variable) == 0x000028, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::Temp_int_Loop_Counter_Variable' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, CallFunc_Add_IntInt_ReturnValue) == 0x00002C, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::CallFunc_Add_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, CallFunc_Set_ToArray_Result) == 0x000030, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::CallFunc_Set_ToArray_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, CallFunc_Array_Length_ReturnValue) == 0x000040, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::CallFunc_Array_Length_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, CallFunc_Array_Get_Item) == 0x000048, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::CallFunc_Array_Get_Item' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, CallFunc_Less_IntInt_ReturnValue) == 0x000050, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::CallFunc_Less_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, K2Node_ClassDynamicCast_AsITEM_Upgrade_Base_1) == 0x000058, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::K2Node_ClassDynamicCast_AsITEM_Upgrade_Base_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, K2Node_ClassDynamicCast_bSuccess_1) == 0x000060, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::K2Node_ClassDynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem, CallFunc_IsUpgradeRecurse_Result) == 0x000061, "Member 'COMP_HackerInventory_C_HasDiscoveredSuperiorHeroicItem::CallFunc_IsUpgradeRecurse_Result' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.CanPlayHeroicAction
// 0x0068 (0x0068 - 0x0000)
struct COMP_HackerInventory_C_CanPlayHeroicAction final
{
public:
	TSoftObjectPtr<class UAnimMontage>            Montage;                                           // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  HackerPawn;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsTeleporting_Result;                     // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CallFunc_LoadAsset_Blocking_ReturnValue;           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           K2Node_DynamicCast_AsAnim_Montage;                 // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsCinematicMontage_Result;                // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_CanStandUp_Result;                        // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsCrouchingOrTransitioning_Result;        // 0x0053(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue_1;                // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsEquipmentDisabled_Result;               // 0x0062(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsHeroicActionQueued_Result;              // 0x0063(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue_2;                // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue_3;                // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_CanPlayHeroicAction) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_CanPlayHeroicAction");
static_assert(sizeof(COMP_HackerInventory_C_CanPlayHeroicAction) == 0x000068, "Wrong size on COMP_HackerInventory_C_CanPlayHeroicAction");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, Montage) == 0x000000, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::Montage' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, Result) == 0x000028, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, HackerPawn) == 0x000030, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::HackerPawn' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_IsTeleporting_Result) == 0x000038, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_IsTeleporting_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_Not_PreBool_ReturnValue) == 0x000039, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_LoadAsset_Blocking_ReturnValue) == 0x000040, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_LoadAsset_Blocking_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, K2Node_DynamicCast_AsAnim_Montage) == 0x000048, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::K2Node_DynamicCast_AsAnim_Montage' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, K2Node_DynamicCast_bSuccess) == 0x000050, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_IsCinematicMontage_Result) == 0x000051, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_IsCinematicMontage_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_CanStandUp_Result) == 0x000052, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_CanStandUp_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_IsCrouchingOrTransitioning_Result) == 0x000053, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_IsCrouchingOrTransitioning_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_GetHackerOwner_Hacker) == 0x000058, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_IsValid_ReturnValue) == 0x000060, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_Not_PreBool_ReturnValue_1) == 0x000061, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_Not_PreBool_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_IsEquipmentDisabled_Result) == 0x000062, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_IsEquipmentDisabled_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_IsHeroicActionQueued_Result) == 0x000063, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_IsHeroicActionQueued_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_Not_PreBool_ReturnValue_2) == 0x000064, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_Not_PreBool_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CanPlayHeroicAction, CallFunc_Not_PreBool_ReturnValue_3) == 0x000065, "Member 'COMP_HackerInventory_C_CanPlayHeroicAction::CallFunc_Not_PreBool_ReturnValue_3' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.IsHeroicActionQueued
// 0x0002 (0x0002 - 0x0000)
struct COMP_HackerInventory_C_IsHeroicActionQueued final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_IsHeroicActionQueued) == 0x000001, "Wrong alignment on COMP_HackerInventory_C_IsHeroicActionQueued");
static_assert(sizeof(COMP_HackerInventory_C_IsHeroicActionQueued) == 0x000002, "Wrong size on COMP_HackerInventory_C_IsHeroicActionQueued");
static_assert(offsetof(COMP_HackerInventory_C_IsHeroicActionQueued, Result) == 0x000000, "Member 'COMP_HackerInventory_C_IsHeroicActionQueued::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_IsHeroicActionQueued, CallFunc_IsValid_ReturnValue) == 0x000001, "Member 'COMP_HackerInventory_C_IsHeroicActionQueued::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.HasQueuedCinematicHeroicAction
// 0x0003 (0x0003 - 0x0000)
struct COMP_HackerInventory_C_HasQueuedCinematicHeroicAction final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsCinematicMontage_Result;                // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_HasQueuedCinematicHeroicAction) == 0x000001, "Wrong alignment on COMP_HackerInventory_C_HasQueuedCinematicHeroicAction");
static_assert(sizeof(COMP_HackerInventory_C_HasQueuedCinematicHeroicAction) == 0x000003, "Wrong size on COMP_HackerInventory_C_HasQueuedCinematicHeroicAction");
static_assert(offsetof(COMP_HackerInventory_C_HasQueuedCinematicHeroicAction, Result) == 0x000000, "Member 'COMP_HackerInventory_C_HasQueuedCinematicHeroicAction::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasQueuedCinematicHeroicAction, CallFunc_IsCinematicMontage_Result) == 0x000001, "Member 'COMP_HackerInventory_C_HasQueuedCinematicHeroicAction::CallFunc_IsCinematicMontage_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasQueuedCinematicHeroicAction, CallFunc_IsValid_ReturnValue) == 0x000002, "Member 'COMP_HackerInventory_C_HasQueuedCinematicHeroicAction::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.GetOverrideHandheldDisplayProperties
// 0x0050 (0x0050 - 0x0000)
struct COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 AnimInstanceClass;                                 // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     OverrideMaterial;                                  // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TScriptInterface<class IINTERF_DisplayItem_C> K2Node_DynamicCast_AsINTERF_Display_Item;          // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          CallFunc_GetDisplayProperties_SkeletalMesh;        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 CallFunc_GetDisplayProperties_AnimInstanceClass;   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     CallFunc_GetDisplayProperties_OverrideMaterial;    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties");
static_assert(sizeof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties) == 0x000050, "Wrong size on COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, SkeletalMesh) == 0x000000, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, AnimInstanceClass) == 0x000008, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, OverrideMaterial) == 0x000010, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::OverrideMaterial' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, K2Node_DynamicCast_AsINTERF_Display_Item) == 0x000018, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::K2Node_DynamicCast_AsINTERF_Display_Item' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, K2Node_DynamicCast_bSuccess) == 0x000028, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, CallFunc_GetDisplayProperties_SkeletalMesh) == 0x000030, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::CallFunc_GetDisplayProperties_SkeletalMesh' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, CallFunc_GetDisplayProperties_AnimInstanceClass) == 0x000038, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::CallFunc_GetDisplayProperties_AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, CallFunc_GetDisplayProperties_OverrideMaterial) == 0x000040, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::CallFunc_GetDisplayProperties_OverrideMaterial' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties, CallFunc_IsValid_ReturnValue) == 0x000048, "Member 'COMP_HackerInventory_C_GetOverrideHandheldDisplayProperties::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.GrantHeroicItem
// 0x00D8 (0x00D8 - 0x0000)
struct COMP_HackerInventory_C_GrantHeroicItem final
{
public:
	class UITEM_Base_C*                           HeroicItem;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class UAnimMontage>            HeroicMontage;                                     // 0x0008(0x0028)(BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
	class UInventoryBag_C*                        PreferredBag;                                      // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         PreferredSlotIndex;                                // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWIDGET_PlayerHUD_C*                    PlayerHUDWidget;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  HackerPawn;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBag_C*                        CallFunc_GetBag_Result;                            // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCOMP_Inventory_C*                      CallFunc_GetInventory_Inventory;                   // 0x0060(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_Base_C*                           CallFunc_RemoveItem_RemovedItem;                   // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue_2;                    // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_3;                    // 0x0071(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCOMP_Inventory_C*                      CallFunc_GetInventory_Inventory_1;                 // 0x0080(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_EqualEqual_ObjectObject_ReturnValue;      // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Implant_C*                 K2Node_DynamicCast_AsPAWN_Hacker_Implant;          // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWIDGET_PlayerHUD_C*                    CallFunc_GetNeuralHUD_Result;                      // 0x00A0(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsWaitingToHolster_Result;                // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_4;                    // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CallFunc_LoadAsset_Blocking_ReturnValue;           // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           K2Node_DynamicCast_AsAnim_Montage;                 // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_1;                     // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             K2Node_CreateDelegate_OutputDelegate;              // 0x00C4(0x0010)(ZeroConstructor, NoDestructor)
	bool                                          CallFunc_IsInventoryVisible_Result;                // 0x00D4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_GrantHeroicItem) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_GrantHeroicItem");
static_assert(sizeof(COMP_HackerInventory_C_GrantHeroicItem) == 0x0000D8, "Wrong size on COMP_HackerInventory_C_GrantHeroicItem");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, HeroicItem) == 0x000000, "Member 'COMP_HackerInventory_C_GrantHeroicItem::HeroicItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, HeroicMontage) == 0x000008, "Member 'COMP_HackerInventory_C_GrantHeroicItem::HeroicMontage' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, PreferredBag) == 0x000030, "Member 'COMP_HackerInventory_C_GrantHeroicItem::PreferredBag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, PreferredSlotIndex) == 0x000038, "Member 'COMP_HackerInventory_C_GrantHeroicItem::PreferredSlotIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, PlayerHUDWidget) == 0x000040, "Member 'COMP_HackerInventory_C_GrantHeroicItem::PlayerHUDWidget' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, HackerPawn) == 0x000048, "Member 'COMP_HackerInventory_C_GrantHeroicItem::HackerPawn' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_IsValid_ReturnValue) == 0x000050, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_IsValid_ReturnValue_1) == 0x000051, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_GetBag_Result) == 0x000058, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_GetBag_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_GetInventory_Inventory) == 0x000060, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_GetInventory_Inventory' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_RemoveItem_RemovedItem) == 0x000068, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_RemoveItem_RemovedItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_IsValid_ReturnValue_2) == 0x000070, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_IsValid_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_IsValid_ReturnValue_3) == 0x000071, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_IsValid_ReturnValue_3' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_GetHackerOwner_Hacker) == 0x000078, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_GetInventory_Inventory_1) == 0x000080, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_GetInventory_Inventory_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_EqualEqual_ObjectObject_ReturnValue) == 0x000088, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_EqualEqual_ObjectObject_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, K2Node_DynamicCast_AsPAWN_Hacker_Implant) == 0x000090, "Member 'COMP_HackerInventory_C_GrantHeroicItem::K2Node_DynamicCast_AsPAWN_Hacker_Implant' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, K2Node_DynamicCast_bSuccess) == 0x000098, "Member 'COMP_HackerInventory_C_GrantHeroicItem::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_GetNeuralHUD_Result) == 0x0000A0, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_GetNeuralHUD_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_IsWaitingToHolster_Result) == 0x0000A8, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_IsWaitingToHolster_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_IsValid_ReturnValue_4) == 0x0000A9, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_IsValid_ReturnValue_4' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_LoadAsset_Blocking_ReturnValue) == 0x0000B0, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_LoadAsset_Blocking_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, K2Node_DynamicCast_AsAnim_Montage) == 0x0000B8, "Member 'COMP_HackerInventory_C_GrantHeroicItem::K2Node_DynamicCast_AsAnim_Montage' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, K2Node_DynamicCast_bSuccess_1) == 0x0000C0, "Member 'COMP_HackerInventory_C_GrantHeroicItem::K2Node_DynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, K2Node_CreateDelegate_OutputDelegate) == 0x0000C4, "Member 'COMP_HackerInventory_C_GrantHeroicItem::K2Node_CreateDelegate_OutputDelegate' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GrantHeroicItem, CallFunc_IsInventoryVisible_Result) == 0x0000D4, "Member 'COMP_HackerInventory_C_GrantHeroicItem::CallFunc_IsInventoryVisible_Result' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.TryAddHeroicItemToInventory
// 0x0040 (0x0040 - 0x0000)
struct COMP_HackerInventory_C_TryAddHeroicItemToInventory final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBag_C*                        BestBag;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  HackerPawn;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_AddItemToSlot_Result;                     // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CallFunc_GetOuterObject_ReturnValue;               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_AddItem_Result;                           // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_EqualEqual_ObjectObject_ReturnValue;      // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_TryAddHeroicItemToInventory) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_TryAddHeroicItemToInventory");
static_assert(sizeof(COMP_HackerInventory_C_TryAddHeroicItemToInventory) == 0x000040, "Wrong size on COMP_HackerInventory_C_TryAddHeroicItemToInventory");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, Result) == 0x000000, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, BestBag) == 0x000008, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::BestBag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, HackerPawn) == 0x000010, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::HackerPawn' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, CallFunc_IsValid_ReturnValue) == 0x000018, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, CallFunc_AddItemToSlot_Result) == 0x000019, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::CallFunc_AddItemToSlot_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, CallFunc_GetOuterObject_ReturnValue) == 0x000020, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::CallFunc_GetOuterObject_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, CallFunc_AddItem_Result) == 0x000028, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::CallFunc_AddItem_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, CallFunc_IsValid_ReturnValue_1) == 0x000029, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, CallFunc_GetHackerOwner_Hacker) == 0x000030, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryAddHeroicItemToInventory, CallFunc_EqualEqual_ObjectObject_ReturnValue) == 0x000038, "Member 'COMP_HackerInventory_C_TryAddHeroicItemToInventory::CallFunc_EqualEqual_ObjectObject_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.PostInitializeEquipmentState
// 0x0110 (0x0110 - 0x0000)
struct COMP_HackerInventory_C_PostInitializeEquipmentState final
{
public:
	class UITEM_ConsumableBase_C*                 ConsumableBeingHeld;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           HeroicPickupMontage;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_WeaponBase_C*                     HeroicWeapon;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCharacterAction_C*                     CurrentAction;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  HackerPawn;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_ExplosiveBase_C*                  K2Node_DynamicCast_AsITEM_Explosive_Base;          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_HandheldConsumable_Base_C*        CallFunc_GetOrCreateHandheldItem_HandheldItem;     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          CallFunc_GetOverrideHandheldDisplayProperties_SkeletalMesh; // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 CallFunc_GetOverrideHandheldDisplayProperties_AnimInstanceClass; // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     CallFunc_GetOverrideHandheldDisplayProperties_OverrideMaterial; // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue_2;                    // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SetDisplayMesh_Result;                    // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             K2Node_CreateDelegate_OutputDelegate;              // 0x0064(0x0010)(ZeroConstructor, NoDestructor)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CallFunc_GetBestPickupClass_Result;                // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_WeaponBase_C*                     K2Node_DynamicCast_AsITEM_Weapon_Base;             // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_1;                     // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CallFunc_LoadAsset_Blocking_ReturnValue;           // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           K2Node_DynamicCast_AsAnim_Montage;                 // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_2;                     // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Deactivate_Result;                        // 0x00A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBag_C*                        CallFunc_GetBag_Result;                            // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue_3;                    // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_ConsumableBase_C*                 K2Node_DynamicCast_AsITEM_Consumable_Base;         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_3;                     // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_4;                    // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterAction_C*                     CallFunc_GetCurrentAction_CurrentAction;           // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TDelegate<void()>                             K2Node_CreateDelegate_OutputDelegate_1;            // 0x00D8(0x0010)(ZeroConstructor, NoDestructor)
	bool                                          CallFunc_TryBecomeActivatableImmediately_Result;   // 0x00E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CallFunc_GetMontage_Result;                        // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_EqualEqual_ObjectObject_ReturnValue;      // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_5;                    // 0x00F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             K2Node_CreateDelegate_OutputDelegate_2;            // 0x00FC(0x0010)(ZeroConstructor, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_PostInitializeEquipmentState) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_PostInitializeEquipmentState");
static_assert(sizeof(COMP_HackerInventory_C_PostInitializeEquipmentState) == 0x000110, "Wrong size on COMP_HackerInventory_C_PostInitializeEquipmentState");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, ConsumableBeingHeld) == 0x000000, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::ConsumableBeingHeld' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, HeroicPickupMontage) == 0x000008, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::HeroicPickupMontage' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, HeroicWeapon) == 0x000010, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::HeroicWeapon' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CurrentAction) == 0x000018, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CurrentAction' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, HackerPawn) == 0x000020, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::HackerPawn' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_DynamicCast_AsITEM_Explosive_Base) == 0x000028, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_DynamicCast_AsITEM_Explosive_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_DynamicCast_bSuccess) == 0x000030, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetOrCreateHandheldItem_HandheldItem) == 0x000038, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetOrCreateHandheldItem_HandheldItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_IsValid_ReturnValue) == 0x000040, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_IsValid_ReturnValue_1) == 0x000041, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetOverrideHandheldDisplayProperties_SkeletalMesh) == 0x000048, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetOverrideHandheldDisplayProperties_SkeletalMesh' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetOverrideHandheldDisplayProperties_AnimInstanceClass) == 0x000050, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetOverrideHandheldDisplayProperties_AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetOverrideHandheldDisplayProperties_OverrideMaterial) == 0x000058, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetOverrideHandheldDisplayProperties_OverrideMaterial' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_IsValid_ReturnValue_2) == 0x000060, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_IsValid_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_SetDisplayMesh_Result) == 0x000061, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_SetDisplayMesh_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_CreateDelegate_OutputDelegate) == 0x000064, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_CreateDelegate_OutputDelegate' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetBestPickupClass_Result) == 0x000078, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetBestPickupClass_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_DynamicCast_AsITEM_Weapon_Base) == 0x000080, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_DynamicCast_AsITEM_Weapon_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_DynamicCast_bSuccess_1) == 0x000088, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_DynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_LoadAsset_Blocking_ReturnValue) == 0x000090, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_LoadAsset_Blocking_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_DynamicCast_AsAnim_Montage) == 0x000098, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_DynamicCast_AsAnim_Montage' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_DynamicCast_bSuccess_2) == 0x0000A0, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_DynamicCast_bSuccess_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_Deactivate_Result) == 0x0000A1, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_Deactivate_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetBag_Result) == 0x0000A8, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetBag_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_IsValid_ReturnValue_3) == 0x0000B0, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_IsValid_ReturnValue_3' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_DynamicCast_AsITEM_Consumable_Base) == 0x0000B8, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_DynamicCast_AsITEM_Consumable_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_DynamicCast_bSuccess_3) == 0x0000C0, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_DynamicCast_bSuccess_3' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_IsValid_ReturnValue_4) == 0x0000C1, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_IsValid_ReturnValue_4' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetCurrentAction_CurrentAction) == 0x0000C8, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetCurrentAction_CurrentAction' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetHackerOwner_Hacker) == 0x0000D0, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_CreateDelegate_OutputDelegate_1) == 0x0000D8, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_CreateDelegate_OutputDelegate_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_TryBecomeActivatableImmediately_Result) == 0x0000E8, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_TryBecomeActivatableImmediately_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_GetMontage_Result) == 0x0000F0, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_GetMontage_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_EqualEqual_ObjectObject_ReturnValue) == 0x0000F8, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_EqualEqual_ObjectObject_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, CallFunc_IsValid_ReturnValue_5) == 0x0000F9, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::CallFunc_IsValid_ReturnValue_5' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_PostInitializeEquipmentState, K2Node_CreateDelegate_OutputDelegate_2) == 0x0000FC, "Member 'COMP_HackerInventory_C_PostInitializeEquipmentState::K2Node_CreateDelegate_OutputDelegate_2' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.MoveGrabBagItemsToInventory
// 0x0088 (0x0088 - 0x0000)
struct COMP_HackerInventory_C_MoveGrabBagItemsToInventory final
{
public:
	class UInventoryBag_C*                        BestBag;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_Base_C*                           GrabItem;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UInventoryBag_C*                        GrabBag;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         Temp_int_Array_Index_Variable;                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBag_C*                        CallFunc_GetBagByName_Bag;                         // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 CallFunc_GetOwner_ReturnValue;                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  K2Node_DynamicCast_AsPAWN_Hacker_Simple;           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_Base_C*                           CallFunc_RemoveItem_RemovedItem;                   // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_NotEqual_ObjectObject_ReturnValue;        // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_TryDropItem_Result;                       // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_AddItem_Result;                           // 0x004A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x004B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBag_C*                        CallFunc_GetBagByType_Bag;                         // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         Temp_int_Loop_Counter_Variable;                    // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Add_IntInt_ReturnValue;                   // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UITEM_Base_C*>                   CallFunc_GetItemArray_Items;                       // 0x0060(0x0010)(ReferenceParm)
	int32                                         CallFunc_Array_Length_ReturnValue;                 // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_Base_C*                           CallFunc_Array_Get_Item;                           // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Less_IntInt_ReturnValue;                  // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_MoveGrabBagItemsToInventory");
static_assert(sizeof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory) == 0x000088, "Wrong size on COMP_HackerInventory_C_MoveGrabBagItemsToInventory");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, BestBag) == 0x000000, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::BestBag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, GrabItem) == 0x000008, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::GrabItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, GrabBag) == 0x000010, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::GrabBag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, Temp_int_Array_Index_Variable) == 0x000018, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::Temp_int_Array_Index_Variable' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_IsValid_ReturnValue) == 0x00001C, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_GetBagByName_Bag) == 0x000020, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_GetBagByName_Bag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_GetOwner_ReturnValue) == 0x000028, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_GetOwner_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, K2Node_DynamicCast_AsPAWN_Hacker_Simple) == 0x000030, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::K2Node_DynamicCast_AsPAWN_Hacker_Simple' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, K2Node_DynamicCast_bSuccess) == 0x000038, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_IsValid_ReturnValue_1) == 0x000039, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_RemoveItem_RemovedItem) == 0x000040, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_RemoveItem_RemovedItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_NotEqual_ObjectObject_ReturnValue) == 0x000048, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_NotEqual_ObjectObject_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_TryDropItem_Result) == 0x000049, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_TryDropItem_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_AddItem_Result) == 0x00004A, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_AddItem_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_Not_PreBool_ReturnValue) == 0x00004B, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_GetBagByType_Bag) == 0x000050, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_GetBagByType_Bag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, Temp_int_Loop_Counter_Variable) == 0x000058, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::Temp_int_Loop_Counter_Variable' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_Add_IntInt_ReturnValue) == 0x00005C, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_Add_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_GetItemArray_Items) == 0x000060, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_GetItemArray_Items' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_Array_Length_ReturnValue) == 0x000070, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_Array_Length_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_Array_Get_Item) == 0x000078, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_Array_Get_Item' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_MoveGrabBagItemsToInventory, CallFunc_Less_IntInt_ReturnValue) == 0x000080, "Member 'COMP_HackerInventory_C_MoveGrabBagItemsToInventory::CallFunc_Less_IntInt_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.ReceiveAnimationMessage
// 0x0030 (0x0030 - 0x0000)
struct COMP_HackerInventory_C_ReceiveAnimationMessage final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_ReceiveAnimationMessage_Result;           // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IINTERF_DisplayItem_C> K2Node_DynamicCast_AsINTERF_Display_Item;          // 0x0018(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_TryAddHeroicItemToInventory_Result;       // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_ReceiveAnimationMessage_Result_1;         // 0x002A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_EqualEqual_StrStr_ReturnValue;            // 0x002B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_ReceiveAnimationMessage) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_ReceiveAnimationMessage");
static_assert(sizeof(COMP_HackerInventory_C_ReceiveAnimationMessage) == 0x000030, "Wrong size on COMP_HackerInventory_C_ReceiveAnimationMessage");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, Message) == 0x000000, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::Message' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, Result) == 0x000010, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, CallFunc_IsValid_ReturnValue) == 0x000011, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, CallFunc_ReceiveAnimationMessage_Result) == 0x000012, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::CallFunc_ReceiveAnimationMessage_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, CallFunc_IsValid_ReturnValue_1) == 0x000013, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, K2Node_DynamicCast_AsINTERF_Display_Item) == 0x000018, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::K2Node_DynamicCast_AsINTERF_Display_Item' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, K2Node_DynamicCast_bSuccess) == 0x000028, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, CallFunc_TryAddHeroicItemToInventory_Result) == 0x000029, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::CallFunc_TryAddHeroicItemToInventory_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, CallFunc_ReceiveAnimationMessage_Result_1) == 0x00002A, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::CallFunc_ReceiveAnimationMessage_Result_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ReceiveAnimationMessage, CallFunc_EqualEqual_StrStr_ReturnValue) == 0x00002B, "Member 'COMP_HackerInventory_C_ReceiveAnimationMessage::CallFunc_EqualEqual_StrStr_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.EVENT_PlayHeroicAction
// 0x00D8 (0x00D8 - 0x0000)
struct COMP_HackerInventory_C_EVENT_PlayHeroicAction final
{
public:
	class UITEM_WeaponBase_C*                     HeroicWeapon;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  HackerPawn;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_ExplosiveBase_C*                  K2Node_DynamicCast_AsITEM_Explosive_Base;          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Implant_C*                 K2Node_DynamicCast_AsPAWN_Hacker_Implant;          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_1;                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_HandheldConsumable_Base_C*        CallFunc_GetOrCreateHandheldItem_HandheldItem;     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UWIDGET_PlayerHUD_C*                    CallFunc_GetNeuralHUD_Result;                      // 0x0038(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_ShowMultiFunctionDisplay_MainDisplayVisible; // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          CallFunc_GetOverrideHandheldDisplayProperties_SkeletalMesh; // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 CallFunc_GetOverrideHandheldDisplayProperties_AnimInstanceClass; // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     CallFunc_GetOverrideHandheldDisplayProperties_OverrideMaterial; // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SetDisplayMesh_Result;                    // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CallFunc_GetObjectClass_ReturnValue;               // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_WeaponBase_C*                     K2Node_DynamicCast_AsITEM_Weapon_Base;             // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_2;                     // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CallFunc_GetHeroicItemClass_HeroicItemClass;       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FAttribModApplyData>            K2Node_MakeArray_Array;                            // 0x0088(0x0010)(ConstParm, ReferenceParm)
	bool                                          CallFunc_TryAddHeroicItemToInventory_Result;       // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAttribMod*>                     CallFunc_ApplyMods_ReturnValue;                    // 0x00A0(0x0010)(ReferenceParm)
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_TryBecomeActivatableImmediately_Result;   // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_GetSlotIndex_Result;                      // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UInventoryBag_C*                        CallFunc_GetBag_Result;                            // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_ForceEquipItemInSlot_Result;              // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x00C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_2;                    // 0x00CA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterAction_C*                     CallFunc_TryBeginAction_Action;                    // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_EVENT_PlayHeroicAction) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_EVENT_PlayHeroicAction");
static_assert(sizeof(COMP_HackerInventory_C_EVENT_PlayHeroicAction) == 0x0000D8, "Wrong size on COMP_HackerInventory_C_EVENT_PlayHeroicAction");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, HeroicWeapon) == 0x000000, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::HeroicWeapon' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, HackerPawn) == 0x000008, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::HackerPawn' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, K2Node_DynamicCast_AsITEM_Explosive_Base) == 0x000010, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::K2Node_DynamicCast_AsITEM_Explosive_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, K2Node_DynamicCast_bSuccess) == 0x000018, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, K2Node_DynamicCast_AsPAWN_Hacker_Implant) == 0x000020, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::K2Node_DynamicCast_AsPAWN_Hacker_Implant' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, K2Node_DynamicCast_bSuccess_1) == 0x000028, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::K2Node_DynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetOrCreateHandheldItem_HandheldItem) == 0x000030, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetOrCreateHandheldItem_HandheldItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetNeuralHUD_Result) == 0x000038, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetNeuralHUD_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_ShowMultiFunctionDisplay_MainDisplayVisible) == 0x000040, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_ShowMultiFunctionDisplay_MainDisplayVisible' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetOverrideHandheldDisplayProperties_SkeletalMesh) == 0x000048, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetOverrideHandheldDisplayProperties_SkeletalMesh' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetOverrideHandheldDisplayProperties_AnimInstanceClass) == 0x000050, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetOverrideHandheldDisplayProperties_AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetOverrideHandheldDisplayProperties_OverrideMaterial) == 0x000058, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetOverrideHandheldDisplayProperties_OverrideMaterial' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_IsValid_ReturnValue) == 0x000060, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_SetDisplayMesh_Result) == 0x000061, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_SetDisplayMesh_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetObjectClass_ReturnValue) == 0x000068, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetObjectClass_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, K2Node_DynamicCast_AsITEM_Weapon_Base) == 0x000070, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::K2Node_DynamicCast_AsITEM_Weapon_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, K2Node_DynamicCast_bSuccess_2) == 0x000078, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::K2Node_DynamicCast_bSuccess_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetHeroicItemClass_HeroicItemClass) == 0x000080, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetHeroicItemClass_HeroicItemClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, K2Node_MakeArray_Array) == 0x000088, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::K2Node_MakeArray_Array' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_TryAddHeroicItemToInventory_Result) == 0x000098, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_TryAddHeroicItemToInventory_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_ApplyMods_ReturnValue) == 0x0000A0, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_ApplyMods_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetHackerOwner_Hacker) == 0x0000B0, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_TryBecomeActivatableImmediately_Result) == 0x0000B8, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_TryBecomeActivatableImmediately_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetSlotIndex_Result) == 0x0000BC, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetSlotIndex_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_GetBag_Result) == 0x0000C0, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_GetBag_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_ForceEquipItemInSlot_Result) == 0x0000C8, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_ForceEquipItemInSlot_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_IsValid_ReturnValue_1) == 0x0000C9, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_IsValid_ReturnValue_2) == 0x0000CA, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_IsValid_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_PlayHeroicAction, CallFunc_TryBeginAction_Action) == 0x0000D0, "Member 'COMP_HackerInventory_C_EVENT_PlayHeroicAction::CallFunc_TryBeginAction_Action' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.SetOverrideItemBeingHeld
// 0x0028 (0x0028 - 0x0000)
struct COMP_HackerInventory_C_SetOverrideItemBeingHeld final
{
public:
	class UITEM_Base_C*                           OverrideItem;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCharacterAction_C*                     Action;                                            // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TDelegate<void()>                             K2Node_CreateDelegate_OutputDelegate;              // 0x0010(0x0010)(ZeroConstructor, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_SetOverrideItemBeingHeld) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_SetOverrideItemBeingHeld");
static_assert(sizeof(COMP_HackerInventory_C_SetOverrideItemBeingHeld) == 0x000028, "Wrong size on COMP_HackerInventory_C_SetOverrideItemBeingHeld");
static_assert(offsetof(COMP_HackerInventory_C_SetOverrideItemBeingHeld, OverrideItem) == 0x000000, "Member 'COMP_HackerInventory_C_SetOverrideItemBeingHeld::OverrideItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SetOverrideItemBeingHeld, Action) == 0x000008, "Member 'COMP_HackerInventory_C_SetOverrideItemBeingHeld::Action' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SetOverrideItemBeingHeld, K2Node_CreateDelegate_OutputDelegate) == 0x000010, "Member 'COMP_HackerInventory_C_SetOverrideItemBeingHeld::K2Node_CreateDelegate_OutputDelegate' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SetOverrideItemBeingHeld, CallFunc_IsValid_ReturnValue) == 0x000020, "Member 'COMP_HackerInventory_C_SetOverrideItemBeingHeld::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.GetHackerOwner
// 0x0020 (0x0020 - 0x0000)
struct COMP_HackerInventory_C_GetHackerOwner final
{
public:
	class APAWN_Hacker_Simple_C*                  Hacker;                                            // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 CallFunc_GetOwner_ReturnValue;                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  K2Node_DynamicCast_AsPAWN_Hacker_Simple;           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_GetHackerOwner) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_GetHackerOwner");
static_assert(sizeof(COMP_HackerInventory_C_GetHackerOwner) == 0x000020, "Wrong size on COMP_HackerInventory_C_GetHackerOwner");
static_assert(offsetof(COMP_HackerInventory_C_GetHackerOwner, Hacker) == 0x000000, "Member 'COMP_HackerInventory_C_GetHackerOwner::Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHackerOwner, CallFunc_GetOwner_ReturnValue) == 0x000008, "Member 'COMP_HackerInventory_C_GetHackerOwner::CallFunc_GetOwner_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHackerOwner, K2Node_DynamicCast_AsPAWN_Hacker_Simple) == 0x000010, "Member 'COMP_HackerInventory_C_GetHackerOwner::K2Node_DynamicCast_AsPAWN_Hacker_Simple' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHackerOwner, K2Node_DynamicCast_bSuccess) == 0x000018, "Member 'COMP_HackerInventory_C_GetHackerOwner::K2Node_DynamicCast_bSuccess' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.GetEquippedWeapon
// 0x0008 (0x0008 - 0x0000)
struct COMP_HackerInventory_C_GetEquippedWeapon final
{
public:
	class UITEM_WeaponBase_C*                     Weapon;                                            // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_GetEquippedWeapon) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_GetEquippedWeapon");
static_assert(sizeof(COMP_HackerInventory_C_GetEquippedWeapon) == 0x000008, "Wrong size on COMP_HackerInventory_C_GetEquippedWeapon");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeapon, Weapon) == 0x000000, "Member 'COMP_HackerInventory_C_GetEquippedWeapon::Weapon' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.EVENT_OnOverrideHandheldMontageEnded
// 0x0050 (0x0050 - 0x0000)
struct COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded final
{
public:
	class APAWN_Hacker_Simple_C*                  HackerPawn;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_ConsumableBase_C*                 K2Node_DynamicCast_AsITEM_Consumable_Base;         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_WeaponBase_C*                     K2Node_DynamicCast_AsITEM_Weapon_Base;             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_1;                     // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_ExpireModsWithCategory_ReturnValue;       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_SetDisplayMesh_Result;                    // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_TryAddHeroicItemToInventory_Result;       // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_ExplosiveBase_C*                  K2Node_DynamicCast_AsITEM_Explosive_Base;          // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_2;                     // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SetDisplayMesh_Result_1;                  // 0x0049(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded");
static_assert(sizeof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded) == 0x000050, "Wrong size on COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, HackerPawn) == 0x000000, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::HackerPawn' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, K2Node_DynamicCast_AsITEM_Consumable_Base) == 0x000008, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::K2Node_DynamicCast_AsITEM_Consumable_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, K2Node_DynamicCast_bSuccess) == 0x000010, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, K2Node_DynamicCast_AsITEM_Weapon_Base) == 0x000018, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::K2Node_DynamicCast_AsITEM_Weapon_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, K2Node_DynamicCast_bSuccess_1) == 0x000020, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::K2Node_DynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, CallFunc_ExpireModsWithCategory_ReturnValue) == 0x000024, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::CallFunc_ExpireModsWithCategory_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, CallFunc_SetDisplayMesh_Result) == 0x000028, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::CallFunc_SetDisplayMesh_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, CallFunc_GetHackerOwner_Hacker) == 0x000030, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, CallFunc_TryAddHeroicItemToInventory_Result) == 0x000038, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::CallFunc_TryAddHeroicItemToInventory_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, K2Node_DynamicCast_AsITEM_Explosive_Base) == 0x000040, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::K2Node_DynamicCast_AsITEM_Explosive_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, K2Node_DynamicCast_bSuccess_2) == 0x000048, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::K2Node_DynamicCast_bSuccess_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded, CallFunc_SetDisplayMesh_Result_1) == 0x000049, "Member 'COMP_HackerInventory_C_EVENT_OnOverrideHandheldMontageEnded::CallFunc_SetDisplayMesh_Result_1' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.SetCurrentEquippedWeapon
// 0x0010 (0x0010 - 0x0000)
struct COMP_HackerInventory_C_SetCurrentEquippedWeapon final
{
public:
	class UITEM_WeaponBase_C*                     Weapon;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_NotEqual_ObjectObject_ReturnValue;        // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_SetCurrentEquippedWeapon) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_SetCurrentEquippedWeapon");
static_assert(sizeof(COMP_HackerInventory_C_SetCurrentEquippedWeapon) == 0x000010, "Wrong size on COMP_HackerInventory_C_SetCurrentEquippedWeapon");
static_assert(offsetof(COMP_HackerInventory_C_SetCurrentEquippedWeapon, Weapon) == 0x000000, "Member 'COMP_HackerInventory_C_SetCurrentEquippedWeapon::Weapon' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SetCurrentEquippedWeapon, CallFunc_IsValid_ReturnValue) == 0x000008, "Member 'COMP_HackerInventory_C_SetCurrentEquippedWeapon::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SetCurrentEquippedWeapon, CallFunc_IsValid_ReturnValue_1) == 0x000009, "Member 'COMP_HackerInventory_C_SetCurrentEquippedWeapon::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SetCurrentEquippedWeapon, CallFunc_NotEqual_ObjectObject_ReturnValue) == 0x00000A, "Member 'COMP_HackerInventory_C_SetCurrentEquippedWeapon::CallFunc_NotEqual_ObjectObject_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.HandlePrimaryAttack
// 0x0060 (0x0060 - 0x0000)
struct COMP_HackerInventory_C_HandlePrimaryAttack final
{
public:
	bool                                          InputState;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  HackerPawn;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsChannelingWithAnyInteractable_Result;   // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Implant_C*                 K2Node_DynamicCast_AsPAWN_Hacker_Implant;          // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWIDGET_PlayerHUD_C*                    CallFunc_GetNeuralHUD_Result;                      // 0x0030(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Not_PreBool_ReturnValue_1;                // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue_2;                // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue_3;                // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_BooleanOR_ReturnValue;                    // 0x003B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsGamePaused_ReturnValue;                 // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue_4;                // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Deactivate_Result;                        // 0x003E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Activate_Result;                          // 0x003F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameInstance*                          CallFunc_GetGameInstance_ReturnValue;              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UGI_SinglePlayer_C*                     K2Node_DynamicCast_AsGI_Single_Player;             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_1;                     // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_TryCompleteTutorial_Result;               // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_HandlePrimaryAttack) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_HandlePrimaryAttack");
static_assert(sizeof(COMP_HackerInventory_C_HandlePrimaryAttack) == 0x000060, "Wrong size on COMP_HackerInventory_C_HandlePrimaryAttack");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, InputState) == 0x000000, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::InputState' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, HackerPawn) == 0x000008, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::HackerPawn' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_GetHackerOwner_Hacker) == 0x000010, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_IsChannelingWithAnyInteractable_Result) == 0x000018, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_IsChannelingWithAnyInteractable_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_Not_PreBool_ReturnValue) == 0x000019, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, K2Node_DynamicCast_AsPAWN_Hacker_Implant) == 0x000020, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::K2Node_DynamicCast_AsPAWN_Hacker_Implant' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, K2Node_DynamicCast_bSuccess) == 0x000028, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_GetNeuralHUD_Result) == 0x000030, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_GetNeuralHUD_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_Not_PreBool_ReturnValue_1) == 0x000038, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_Not_PreBool_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_Not_PreBool_ReturnValue_2) == 0x000039, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_Not_PreBool_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_Not_PreBool_ReturnValue_3) == 0x00003A, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_Not_PreBool_ReturnValue_3' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_BooleanOR_ReturnValue) == 0x00003B, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_BooleanOR_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_IsGamePaused_ReturnValue) == 0x00003C, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_IsGamePaused_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_Not_PreBool_ReturnValue_4) == 0x00003D, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_Not_PreBool_ReturnValue_4' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_Deactivate_Result) == 0x00003E, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_Deactivate_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_Activate_Result) == 0x00003F, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_Activate_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_IsValid_ReturnValue) == 0x000040, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_GetGameInstance_ReturnValue) == 0x000048, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_GetGameInstance_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, K2Node_DynamicCast_AsGI_Single_Player) == 0x000050, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::K2Node_DynamicCast_AsGI_Single_Player' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, K2Node_DynamicCast_bSuccess_1) == 0x000058, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::K2Node_DynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HandlePrimaryAttack, CallFunc_TryCompleteTutorial_Result) == 0x000059, "Member 'COMP_HackerInventory_C_HandlePrimaryAttack::CallFunc_TryCompleteTutorial_Result' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.ToggleWeaponEquipState
// 0x0002 (0x0002 - 0x0000)
struct COMP_HackerInventory_C_ToggleWeaponEquipState final
{
public:
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_ToggleWeaponEquipState) == 0x000001, "Wrong alignment on COMP_HackerInventory_C_ToggleWeaponEquipState");
static_assert(sizeof(COMP_HackerInventory_C_ToggleWeaponEquipState) == 0x000002, "Wrong size on COMP_HackerInventory_C_ToggleWeaponEquipState");
static_assert(offsetof(COMP_HackerInventory_C_ToggleWeaponEquipState, CallFunc_IsValid_ReturnValue) == 0x000000, "Member 'COMP_HackerInventory_C_ToggleWeaponEquipState::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_ToggleWeaponEquipState, CallFunc_IsValid_ReturnValue_1) == 0x000001, "Member 'COMP_HackerInventory_C_ToggleWeaponEquipState::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.CycleWeaponMode
// 0x0038 (0x0038 - 0x0000)
struct COMP_HackerInventory_C_CycleWeaponMode final
{
public:
	bool                                          Previous;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsGamePaused_ReturnValue;                 // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Implant_C*                 K2Node_DynamicCast_AsPAWN_Hacker_Implant;          // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWIDGET_PlayerHUD_C*                    CallFunc_GetNeuralHUD_Result;                      // 0x0028(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Not_PreBool_ReturnValue_1;                // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_CycleCurrentMode_Result;                  // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_CycleWeaponMode) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_CycleWeaponMode");
static_assert(sizeof(COMP_HackerInventory_C_CycleWeaponMode) == 0x000038, "Wrong size on COMP_HackerInventory_C_CycleWeaponMode");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, Previous) == 0x000000, "Member 'COMP_HackerInventory_C_CycleWeaponMode::Previous' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, CallFunc_IsGamePaused_ReturnValue) == 0x000001, "Member 'COMP_HackerInventory_C_CycleWeaponMode::CallFunc_IsGamePaused_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, CallFunc_GetHackerOwner_Hacker) == 0x000008, "Member 'COMP_HackerInventory_C_CycleWeaponMode::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, CallFunc_Not_PreBool_ReturnValue) == 0x000010, "Member 'COMP_HackerInventory_C_CycleWeaponMode::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, K2Node_DynamicCast_AsPAWN_Hacker_Implant) == 0x000018, "Member 'COMP_HackerInventory_C_CycleWeaponMode::K2Node_DynamicCast_AsPAWN_Hacker_Implant' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, K2Node_DynamicCast_bSuccess) == 0x000020, "Member 'COMP_HackerInventory_C_CycleWeaponMode::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, CallFunc_GetNeuralHUD_Result) == 0x000028, "Member 'COMP_HackerInventory_C_CycleWeaponMode::CallFunc_GetNeuralHUD_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, CallFunc_Not_PreBool_ReturnValue_1) == 0x000030, "Member 'COMP_HackerInventory_C_CycleWeaponMode::CallFunc_Not_PreBool_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, CallFunc_IsValid_ReturnValue) == 0x000031, "Member 'COMP_HackerInventory_C_CycleWeaponMode::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleWeaponMode, CallFunc_CycleCurrentMode_Result) == 0x000032, "Member 'COMP_HackerInventory_C_CycleWeaponMode::CallFunc_CycleCurrentMode_Result' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.TryReloadWeapon
// 0x0028 (0x0028 - 0x0000)
struct COMP_HackerInventory_C_TryReloadWeapon final
{
public:
	bool                                          CallFunc_IsGamePaused_ReturnValue;                 // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_TryBeginReloading_Result;                 // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Implant_C*                 K2Node_DynamicCast_AsPAWN_Hacker_Implant;          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWIDGET_PlayerHUD_C*                    CallFunc_GetNeuralHUD_Result;                      // 0x0020(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_TryReloadWeapon) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_TryReloadWeapon");
static_assert(sizeof(COMP_HackerInventory_C_TryReloadWeapon) == 0x000028, "Wrong size on COMP_HackerInventory_C_TryReloadWeapon");
static_assert(offsetof(COMP_HackerInventory_C_TryReloadWeapon, CallFunc_IsGamePaused_ReturnValue) == 0x000000, "Member 'COMP_HackerInventory_C_TryReloadWeapon::CallFunc_IsGamePaused_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryReloadWeapon, CallFunc_Not_PreBool_ReturnValue) == 0x000001, "Member 'COMP_HackerInventory_C_TryReloadWeapon::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryReloadWeapon, CallFunc_IsValid_ReturnValue) == 0x000002, "Member 'COMP_HackerInventory_C_TryReloadWeapon::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryReloadWeapon, CallFunc_TryBeginReloading_Result) == 0x000003, "Member 'COMP_HackerInventory_C_TryReloadWeapon::CallFunc_TryBeginReloading_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryReloadWeapon, CallFunc_GetHackerOwner_Hacker) == 0x000008, "Member 'COMP_HackerInventory_C_TryReloadWeapon::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryReloadWeapon, K2Node_DynamicCast_AsPAWN_Hacker_Implant) == 0x000010, "Member 'COMP_HackerInventory_C_TryReloadWeapon::K2Node_DynamicCast_AsPAWN_Hacker_Implant' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryReloadWeapon, K2Node_DynamicCast_bSuccess) == 0x000018, "Member 'COMP_HackerInventory_C_TryReloadWeapon::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TryReloadWeapon, CallFunc_GetNeuralHUD_Result) == 0x000020, "Member 'COMP_HackerInventory_C_TryReloadWeapon::CallFunc_GetNeuralHUD_Result' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.GetEquippedWeaponHotbarSlot
// 0x0058 (0x0058 - 0x0000)
struct COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot final
{
public:
	class UCOMP_Hotbar_C*                         HotbarComponent;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         HotbarSlotIndex;                                   // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         SlotIndex;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCOMP_Hotbar_C*                         WeaponHotbar;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_WeaponBase_C*                     WeaponToUse;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_GreaterEqual_IntInt_ReturnValue;          // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IINTERF_HotbarSlottable_C> CallFunc_GetSlotIndex_SlottableObject_CastInput;   // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor)
	int32                                         CallFunc_GetSlotIndex_SlotIndex;                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Implant_C*                 K2Node_DynamicCast_AsPAWN_Hacker_Implant;          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot");
static_assert(sizeof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot) == 0x000058, "Wrong size on COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, HotbarComponent) == 0x000000, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::HotbarComponent' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, HotbarSlotIndex) == 0x000008, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::HotbarSlotIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, SlotIndex) == 0x00000C, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, WeaponHotbar) == 0x000010, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::WeaponHotbar' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, WeaponToUse) == 0x000018, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::WeaponToUse' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, CallFunc_IsValid_ReturnValue) == 0x000020, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, CallFunc_GreaterEqual_IntInt_ReturnValue) == 0x000021, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::CallFunc_GreaterEqual_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, CallFunc_IsValid_ReturnValue_1) == 0x000022, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, CallFunc_GetSlotIndex_SlottableObject_CastInput) == 0x000028, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::CallFunc_GetSlotIndex_SlottableObject_CastInput' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, CallFunc_GetSlotIndex_SlotIndex) == 0x000038, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::CallFunc_GetSlotIndex_SlotIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, CallFunc_GetHackerOwner_Hacker) == 0x000040, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, K2Node_DynamicCast_AsPAWN_Hacker_Implant) == 0x000048, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::K2Node_DynamicCast_AsPAWN_Hacker_Implant' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot, K2Node_DynamicCast_bSuccess) == 0x000050, "Member 'COMP_HackerInventory_C_GetEquippedWeaponHotbarSlot::K2Node_DynamicCast_bSuccess' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.CycleEquippedWeaponFromHotbarSlot
// 0x00B0 (0x00B0 - 0x0000)
struct COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot final
{
public:
	class UCOMP_Hotbar_C*                         HotbarComponent;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         HotbarSlotIndex;                                   // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Previous;                                          // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 IgnoreClass;                                       // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Success;                                           // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_WeaponBase_C*                     WeaponToEquip;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Implant_C*                 K2Node_DynamicCast_AsPAWN_Hacker_Implant;          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_GetFirstOccupiedSlotIndex_SlotIndex;      // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_GetSlotIndex_Result;                      // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IINTERF_HotbarSlottable_C> CallFunc_GetSlotAtIndex_SlottableObject;           // 0x0050(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor)
	class UInventoryBag_C*                        CallFunc_GetBag_Result;                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UObject*                                CallFunc_Conv_InterfaceToObject_ReturnValue;       // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_ForceEquipItemInSlot_Result;              // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_WeaponBase_C*                     K2Node_DynamicCast_AsITEM_Weapon_Base;             // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_1;                     // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_CycleFromSlot_CycleIndex;                 // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TScriptInterface<class IINTERF_HotbarSlottable_C> CallFunc_GetSlotAtIndex_SlottableObject_1;         // 0x0088(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor)
	class UObject*                                CallFunc_Conv_InterfaceToObject_ReturnValue_1;     // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_WeaponBase_C*                     K2Node_DynamicCast_AsITEM_Weapon_Base_1;           // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_2;                     // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot");
static_assert(sizeof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot) == 0x0000B0, "Wrong size on COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, HotbarComponent) == 0x000000, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::HotbarComponent' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, HotbarSlotIndex) == 0x000008, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::HotbarSlotIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, Previous) == 0x00000C, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::Previous' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, IgnoreClass) == 0x000010, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::IgnoreClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, Success) == 0x000018, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::Success' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, WeaponToEquip) == 0x000020, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::WeaponToEquip' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_GetHackerOwner_Hacker) == 0x000028, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_IsValid_ReturnValue) == 0x000030, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, K2Node_DynamicCast_AsPAWN_Hacker_Implant) == 0x000038, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::K2Node_DynamicCast_AsPAWN_Hacker_Implant' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, K2Node_DynamicCast_bSuccess) == 0x000040, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_GetFirstOccupiedSlotIndex_SlotIndex) == 0x000044, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_GetFirstOccupiedSlotIndex_SlotIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_GetSlotIndex_Result) == 0x000048, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_GetSlotIndex_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_GetSlotAtIndex_SlottableObject) == 0x000050, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_GetSlotAtIndex_SlottableObject' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_GetBag_Result) == 0x000060, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_GetBag_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_Conv_InterfaceToObject_ReturnValue) == 0x000068, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_Conv_InterfaceToObject_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_ForceEquipItemInSlot_Result) == 0x000070, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_ForceEquipItemInSlot_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, K2Node_DynamicCast_AsITEM_Weapon_Base) == 0x000078, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::K2Node_DynamicCast_AsITEM_Weapon_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, K2Node_DynamicCast_bSuccess_1) == 0x000080, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::K2Node_DynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_CycleFromSlot_CycleIndex) == 0x000084, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_CycleFromSlot_CycleIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_GetSlotAtIndex_SlottableObject_1) == 0x000088, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_GetSlotAtIndex_SlottableObject_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, CallFunc_Conv_InterfaceToObject_ReturnValue_1) == 0x000098, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::CallFunc_Conv_InterfaceToObject_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, K2Node_DynamicCast_AsITEM_Weapon_Base_1) == 0x0000A0, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::K2Node_DynamicCast_AsITEM_Weapon_Base_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot, K2Node_DynamicCast_bSuccess_2) == 0x0000A8, "Member 'COMP_HackerInventory_C_CycleEquippedWeaponFromHotbarSlot::K2Node_DynamicCast_bSuccess_2' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.CycleEquippedWeapon
// 0x0030 (0x0030 - 0x0000)
struct COMP_HackerInventory_C_CycleEquippedWeapon final
{
public:
	bool                                          Previous;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 IgnoreClass;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Success;                                           // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCOMP_Hotbar_C*                         WeaponHotbar;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UCOMP_Hotbar_C*                         CallFunc_GetEquippedWeaponHotbarSlot_HotbarComponent; // 0x0020(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_GetEquippedWeaponHotbarSlot_HotbarSlotIndex; // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_CycleEquippedWeaponFromHotbarSlot_Success; // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_CycleEquippedWeapon) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_CycleEquippedWeapon");
static_assert(sizeof(COMP_HackerInventory_C_CycleEquippedWeapon) == 0x000030, "Wrong size on COMP_HackerInventory_C_CycleEquippedWeapon");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeapon, Previous) == 0x000000, "Member 'COMP_HackerInventory_C_CycleEquippedWeapon::Previous' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeapon, IgnoreClass) == 0x000008, "Member 'COMP_HackerInventory_C_CycleEquippedWeapon::IgnoreClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeapon, Success) == 0x000010, "Member 'COMP_HackerInventory_C_CycleEquippedWeapon::Success' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeapon, WeaponHotbar) == 0x000018, "Member 'COMP_HackerInventory_C_CycleEquippedWeapon::WeaponHotbar' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeapon, CallFunc_GetEquippedWeaponHotbarSlot_HotbarComponent) == 0x000020, "Member 'COMP_HackerInventory_C_CycleEquippedWeapon::CallFunc_GetEquippedWeaponHotbarSlot_HotbarComponent' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeapon, CallFunc_GetEquippedWeaponHotbarSlot_HotbarSlotIndex) == 0x000028, "Member 'COMP_HackerInventory_C_CycleEquippedWeapon::CallFunc_GetEquippedWeaponHotbarSlot_HotbarSlotIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_CycleEquippedWeapon, CallFunc_CycleEquippedWeaponFromHotbarSlot_Success) == 0x00002C, "Member 'COMP_HackerInventory_C_CycleEquippedWeapon::CallFunc_CycleEquippedWeaponFromHotbarSlot_Success' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.IsEquipmentDisabled
// 0x0001 (0x0001 - 0x0000)
struct COMP_HackerInventory_C_IsEquipmentDisabled final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_IsEquipmentDisabled) == 0x000001, "Wrong alignment on COMP_HackerInventory_C_IsEquipmentDisabled");
static_assert(sizeof(COMP_HackerInventory_C_IsEquipmentDisabled) == 0x000001, "Wrong size on COMP_HackerInventory_C_IsEquipmentDisabled");
static_assert(offsetof(COMP_HackerInventory_C_IsEquipmentDisabled, Result) == 0x000000, "Member 'COMP_HackerInventory_C_IsEquipmentDisabled::Result' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.UpdateItemActivationState
// 0x0028 (0x0028 - 0x0000)
struct COMP_HackerInventory_C_UpdateItemActivationState final
{
public:
	class UITEM_Base_C*                           Item;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_EqualEqual_ObjectObject_ReturnValue;      // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_OnBecomeUnactivatable_Result;             // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_OnBecomeActivatable_Result;               // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_CanBecomeActivatable_Result;              // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsActivatable_Result;                     // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsActivatable_Result_1;                   // 0x0017(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsEquipped_Result;                        // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallFunc_GetCurrentObstructionDistance_Distance;   // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsEquippable_Result;                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_LessEqual_FloatFloat_ReturnValue;         // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_BooleanAND_ReturnValue;                   // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsEquipmentDisabled_Result;               // 0x0023(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue_1;                // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_BooleanAND_ReturnValue_1;                 // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_UpdateItemActivationState) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_UpdateItemActivationState");
static_assert(sizeof(COMP_HackerInventory_C_UpdateItemActivationState) == 0x000028, "Wrong size on COMP_HackerInventory_C_UpdateItemActivationState");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, Item) == 0x000000, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::Item' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_GetHackerOwner_Hacker) == 0x000008, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_IsValid_ReturnValue) == 0x000010, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_IsValid_ReturnValue_1) == 0x000011, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_EqualEqual_ObjectObject_ReturnValue) == 0x000012, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_EqualEqual_ObjectObject_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_OnBecomeUnactivatable_Result) == 0x000013, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_OnBecomeUnactivatable_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_OnBecomeActivatable_Result) == 0x000014, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_OnBecomeActivatable_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_CanBecomeActivatable_Result) == 0x000015, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_CanBecomeActivatable_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_IsActivatable_Result) == 0x000016, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_IsActivatable_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_IsActivatable_Result_1) == 0x000017, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_IsActivatable_Result_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_Not_PreBool_ReturnValue) == 0x000018, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_IsEquipped_Result) == 0x000019, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_IsEquipped_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_GetCurrentObstructionDistance_Distance) == 0x00001C, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_GetCurrentObstructionDistance_Distance' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_IsEquippable_Result) == 0x000020, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_IsEquippable_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_LessEqual_FloatFloat_ReturnValue) == 0x000021, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_LessEqual_FloatFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_BooleanAND_ReturnValue) == 0x000022, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_BooleanAND_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_IsEquipmentDisabled_Result) == 0x000023, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_IsEquipmentDisabled_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_Not_PreBool_ReturnValue_1) == 0x000024, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_Not_PreBool_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateItemActivationState, CallFunc_BooleanAND_ReturnValue_1) == 0x000025, "Member 'COMP_HackerInventory_C_UpdateItemActivationState::CallFunc_BooleanAND_ReturnValue_1' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.SetEquipmentDisabled
// 0x0002 (0x0002 - 0x0000)
struct COMP_HackerInventory_C_SetEquipmentDisabled final
{
public:
	bool                                          Disable;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_NotEqual_BoolBool_ReturnValue;            // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_SetEquipmentDisabled) == 0x000001, "Wrong alignment on COMP_HackerInventory_C_SetEquipmentDisabled");
static_assert(sizeof(COMP_HackerInventory_C_SetEquipmentDisabled) == 0x000002, "Wrong size on COMP_HackerInventory_C_SetEquipmentDisabled");
static_assert(offsetof(COMP_HackerInventory_C_SetEquipmentDisabled, Disable) == 0x000000, "Member 'COMP_HackerInventory_C_SetEquipmentDisabled::Disable' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SetEquipmentDisabled, CallFunc_NotEqual_BoolBool_ReturnValue) == 0x000001, "Member 'COMP_HackerInventory_C_SetEquipmentDisabled::CallFunc_NotEqual_BoolBool_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.UpdateEquippedWeaponState
// 0x0001 (0x0001 - 0x0000)
struct COMP_HackerInventory_C_UpdateEquippedWeaponState final
{
public:
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_UpdateEquippedWeaponState) == 0x000001, "Wrong alignment on COMP_HackerInventory_C_UpdateEquippedWeaponState");
static_assert(sizeof(COMP_HackerInventory_C_UpdateEquippedWeaponState) == 0x000001, "Wrong size on COMP_HackerInventory_C_UpdateEquippedWeaponState");
static_assert(offsetof(COMP_HackerInventory_C_UpdateEquippedWeaponState, CallFunc_IsValid_ReturnValue) == 0x000000, "Member 'COMP_HackerInventory_C_UpdateEquippedWeaponState::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.IsOverrideHandheldBeingUsed
// 0x0010 (0x0010 - 0x0000)
struct COMP_HackerInventory_C_IsOverrideHandheldBeingUsed final
{
public:
	class UITEM_Base_C*                           Item;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_EqualEqual_ObjectObject_ReturnValue;      // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_IsOverrideHandheldBeingUsed) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_IsOverrideHandheldBeingUsed");
static_assert(sizeof(COMP_HackerInventory_C_IsOverrideHandheldBeingUsed) == 0x000010, "Wrong size on COMP_HackerInventory_C_IsOverrideHandheldBeingUsed");
static_assert(offsetof(COMP_HackerInventory_C_IsOverrideHandheldBeingUsed, Item) == 0x000000, "Member 'COMP_HackerInventory_C_IsOverrideHandheldBeingUsed::Item' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_IsOverrideHandheldBeingUsed, Result) == 0x000008, "Member 'COMP_HackerInventory_C_IsOverrideHandheldBeingUsed::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_IsOverrideHandheldBeingUsed, CallFunc_EqualEqual_ObjectObject_ReturnValue) == 0x000009, "Member 'COMP_HackerInventory_C_IsOverrideHandheldBeingUsed::CallFunc_EqualEqual_ObjectObject_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.DeactivateCurrentItem
// 0x0018 (0x0018 - 0x0000)
struct COMP_HackerInventory_C_DeactivateCurrentItem final
{
public:
	bool                                          CallFunc_Deactivate_Result;                        // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Deactivate_Result_1;                      // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_ConsumableBase_C*                 K2Node_DynamicCast_AsITEM_Consumable_Base;         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_DeactivateCurrentItem) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_DeactivateCurrentItem");
static_assert(sizeof(COMP_HackerInventory_C_DeactivateCurrentItem) == 0x000018, "Wrong size on COMP_HackerInventory_C_DeactivateCurrentItem");
static_assert(offsetof(COMP_HackerInventory_C_DeactivateCurrentItem, CallFunc_Deactivate_Result) == 0x000000, "Member 'COMP_HackerInventory_C_DeactivateCurrentItem::CallFunc_Deactivate_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_DeactivateCurrentItem, CallFunc_IsValid_ReturnValue) == 0x000001, "Member 'COMP_HackerInventory_C_DeactivateCurrentItem::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_DeactivateCurrentItem, CallFunc_Deactivate_Result_1) == 0x000002, "Member 'COMP_HackerInventory_C_DeactivateCurrentItem::CallFunc_Deactivate_Result_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_DeactivateCurrentItem, K2Node_DynamicCast_AsITEM_Consumable_Base) == 0x000008, "Member 'COMP_HackerInventory_C_DeactivateCurrentItem::K2Node_DynamicCast_AsITEM_Consumable_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_DeactivateCurrentItem, K2Node_DynamicCast_bSuccess) == 0x000010, "Member 'COMP_HackerInventory_C_DeactivateCurrentItem::K2Node_DynamicCast_bSuccess' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.HasReachedEquipCapacity
// 0x0018 (0x0018 - 0x0000)
struct COMP_HackerInventory_C_HasReachedEquipCapacity final
{
public:
	class UInventoryBag_C*                        Bag;                                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_Base_C*                           Item;                                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_HasReachedEquipCapacity_Result;           // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_HasReachedEquipCapacity) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_HasReachedEquipCapacity");
static_assert(sizeof(COMP_HackerInventory_C_HasReachedEquipCapacity) == 0x000018, "Wrong size on COMP_HackerInventory_C_HasReachedEquipCapacity");
static_assert(offsetof(COMP_HackerInventory_C_HasReachedEquipCapacity, Bag) == 0x000000, "Member 'COMP_HackerInventory_C_HasReachedEquipCapacity::Bag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasReachedEquipCapacity, Item) == 0x000008, "Member 'COMP_HackerInventory_C_HasReachedEquipCapacity::Item' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasReachedEquipCapacity, Result) == 0x000010, "Member 'COMP_HackerInventory_C_HasReachedEquipCapacity::Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasReachedEquipCapacity, CallFunc_HasReachedEquipCapacity_Result) == 0x000011, "Member 'COMP_HackerInventory_C_HasReachedEquipCapacity::CallFunc_HasReachedEquipCapacity_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_HasReachedEquipCapacity, CallFunc_IsValid_ReturnValue) == 0x000012, "Member 'COMP_HackerInventory_C_HasReachedEquipCapacity::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.GetFirstEquippedItem
// 0x0010 (0x0010 - 0x0000)
struct COMP_HackerInventory_C_GetFirstEquippedItem final
{
public:
	class UInventoryBag_C*                        Bag;                                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UITEM_Base_C*                           Item;                                              // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_GetFirstEquippedItem) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_GetFirstEquippedItem");
static_assert(sizeof(COMP_HackerInventory_C_GetFirstEquippedItem) == 0x000010, "Wrong size on COMP_HackerInventory_C_GetFirstEquippedItem");
static_assert(offsetof(COMP_HackerInventory_C_GetFirstEquippedItem, Bag) == 0x000000, "Member 'COMP_HackerInventory_C_GetFirstEquippedItem::Bag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetFirstEquippedItem, Item) == 0x000008, "Member 'COMP_HackerInventory_C_GetFirstEquippedItem::Item' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.InitializeBags
// 0x0020 (0x0020 - 0x0000)
struct COMP_HackerInventory_C_InitializeBags final
{
public:
	class APAWN_Hacker_Simple_C*                  HackerPawn;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsHolsterActionPlaying_Result;            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_TryBecomeActivatableImmediately_Result;   // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsEquipmentDisabled_Result;               // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsEquipped_Result;                        // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterAction_C*                     CallFunc_GetCurrentAction_CurrentAction;           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_InitializeBags) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_InitializeBags");
static_assert(sizeof(COMP_HackerInventory_C_InitializeBags) == 0x000020, "Wrong size on COMP_HackerInventory_C_InitializeBags");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, HackerPawn) == 0x000000, "Member 'COMP_HackerInventory_C_InitializeBags::HackerPawn' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, CallFunc_GetHackerOwner_Hacker) == 0x000008, "Member 'COMP_HackerInventory_C_InitializeBags::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, CallFunc_IsHolsterActionPlaying_Result) == 0x000010, "Member 'COMP_HackerInventory_C_InitializeBags::CallFunc_IsHolsterActionPlaying_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, CallFunc_TryBecomeActivatableImmediately_Result) == 0x000011, "Member 'COMP_HackerInventory_C_InitializeBags::CallFunc_TryBecomeActivatableImmediately_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, CallFunc_IsEquipmentDisabled_Result) == 0x000012, "Member 'COMP_HackerInventory_C_InitializeBags::CallFunc_IsEquipmentDisabled_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, CallFunc_IsEquipped_Result) == 0x000013, "Member 'COMP_HackerInventory_C_InitializeBags::CallFunc_IsEquipped_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, CallFunc_Not_PreBool_ReturnValue) == 0x000014, "Member 'COMP_HackerInventory_C_InitializeBags::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, CallFunc_IsValid_ReturnValue) == 0x000015, "Member 'COMP_HackerInventory_C_InitializeBags::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_InitializeBags, CallFunc_GetCurrentAction_CurrentAction) == 0x000018, "Member 'COMP_HackerInventory_C_InitializeBags::CallFunc_GetCurrentAction_CurrentAction' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.TickCurrentEquippedWeapon
// 0x0008 (0x0008 - 0x0000)
struct COMP_HackerInventory_C_TickCurrentEquippedWeapon final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsActivatable_Result;                     // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_TickCurrentEquippedWeapon) == 0x000004, "Wrong alignment on COMP_HackerInventory_C_TickCurrentEquippedWeapon");
static_assert(sizeof(COMP_HackerInventory_C_TickCurrentEquippedWeapon) == 0x000008, "Wrong size on COMP_HackerInventory_C_TickCurrentEquippedWeapon");
static_assert(offsetof(COMP_HackerInventory_C_TickCurrentEquippedWeapon, DeltaTime) == 0x000000, "Member 'COMP_HackerInventory_C_TickCurrentEquippedWeapon::DeltaTime' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TickCurrentEquippedWeapon, CallFunc_IsActivatable_Result) == 0x000004, "Member 'COMP_HackerInventory_C_TickCurrentEquippedWeapon::CallFunc_IsActivatable_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TickCurrentEquippedWeapon, CallFunc_IsValid_ReturnValue) == 0x000005, "Member 'COMP_HackerInventory_C_TickCurrentEquippedWeapon::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.GetHeroicItemClass
// 0x0058 (0x0058 - 0x0000)
struct COMP_HackerInventory_C_GetHeroicItemClass final
{
public:
	class UClass*                                 ItemClass;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 HeroicItemClass;                                   // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<TSoftObjectPtr<class UAnimMontage>>    Temp_softobject_Variable;                          // 0x0010(0x0010)(ReferenceParm)
	class UClass*                                 CallFunc_LoadClassAsset_Blocking_ReturnValue;      // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 CallFunc_GetSuperClass_ReturnValue;                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 K2Node_ClassDynamicCast_AsPICKUP_Base;             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_ClassDynamicCast_bSuccess;                  // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 K2Node_ClassDynamicCast_AsITEM_Base;               // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_ClassDynamicCast_bSuccess_1;                // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_Array_Length_ReturnValue;                 // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_IntInt_ReturnValue;               // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_GetHeroicItemClass) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_GetHeroicItemClass");
static_assert(sizeof(COMP_HackerInventory_C_GetHeroicItemClass) == 0x000058, "Wrong size on COMP_HackerInventory_C_GetHeroicItemClass");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, ItemClass) == 0x000000, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::ItemClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, HeroicItemClass) == 0x000008, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::HeroicItemClass' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, Temp_softobject_Variable) == 0x000010, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::Temp_softobject_Variable' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, CallFunc_LoadClassAsset_Blocking_ReturnValue) == 0x000020, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::CallFunc_LoadClassAsset_Blocking_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, CallFunc_GetSuperClass_ReturnValue) == 0x000028, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::CallFunc_GetSuperClass_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, K2Node_ClassDynamicCast_AsPICKUP_Base) == 0x000030, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::K2Node_ClassDynamicCast_AsPICKUP_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, K2Node_ClassDynamicCast_bSuccess) == 0x000038, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::K2Node_ClassDynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, K2Node_ClassDynamicCast_AsITEM_Base) == 0x000040, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::K2Node_ClassDynamicCast_AsITEM_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, K2Node_ClassDynamicCast_bSuccess_1) == 0x000048, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::K2Node_ClassDynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, CallFunc_Array_Length_ReturnValue) == 0x00004C, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::CallFunc_Array_Length_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetHeroicItemClass, CallFunc_Greater_IntInt_ReturnValue) == 0x000050, "Member 'COMP_HackerInventory_C_GetHeroicItemClass::CallFunc_Greater_IntInt_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.OnWeaponDrawStarted
// 0x0028 (0x0028 - 0x0000)
struct COMP_HackerInventory_C_OnWeaponDrawStarted final
{
public:
	class UITEM_WeaponBase_C*                     Weapon;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FSTRUCT_WeaponRecoilTemplate           CallFunc_GetRecoilTemplate_Result;                 // 0x0008(0x0018)(IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_OnWeaponDrawStarted) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_OnWeaponDrawStarted");
static_assert(sizeof(COMP_HackerInventory_C_OnWeaponDrawStarted) == 0x000028, "Wrong size on COMP_HackerInventory_C_OnWeaponDrawStarted");
static_assert(offsetof(COMP_HackerInventory_C_OnWeaponDrawStarted, Weapon) == 0x000000, "Member 'COMP_HackerInventory_C_OnWeaponDrawStarted::Weapon' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_OnWeaponDrawStarted, CallFunc_GetRecoilTemplate_Result) == 0x000008, "Member 'COMP_HackerInventory_C_OnWeaponDrawStarted::CallFunc_GetRecoilTemplate_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_OnWeaponDrawStarted, CallFunc_GetHackerOwner_Hacker) == 0x000020, "Member 'COMP_HackerInventory_C_OnWeaponDrawStarted::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.OnWeaponHolsterStarted
// 0x0008 (0x0008 - 0x0000)
struct COMP_HackerInventory_C_OnWeaponHolsterStarted final
{
public:
	class UITEM_WeaponBase_C*                     Weapon;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_OnWeaponHolsterStarted) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_OnWeaponHolsterStarted");
static_assert(sizeof(COMP_HackerInventory_C_OnWeaponHolsterStarted) == 0x000008, "Wrong size on COMP_HackerInventory_C_OnWeaponHolsterStarted");
static_assert(offsetof(COMP_HackerInventory_C_OnWeaponHolsterStarted, Weapon) == 0x000000, "Member 'COMP_HackerInventory_C_OnWeaponHolsterStarted::Weapon' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.OnWeaponHolsterFinished
// 0x0010 (0x0010 - 0x0000)
struct COMP_HackerInventory_C_OnWeaponHolsterFinished final
{
public:
	class UITEM_WeaponBase_C*                     Weapon;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_OnWeaponHolsterFinished) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_OnWeaponHolsterFinished");
static_assert(sizeof(COMP_HackerInventory_C_OnWeaponHolsterFinished) == 0x000010, "Wrong size on COMP_HackerInventory_C_OnWeaponHolsterFinished");
static_assert(offsetof(COMP_HackerInventory_C_OnWeaponHolsterFinished, Weapon) == 0x000000, "Member 'COMP_HackerInventory_C_OnWeaponHolsterFinished::Weapon' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_OnWeaponHolsterFinished, CallFunc_GetHackerOwner_Hacker) == 0x000008, "Member 'COMP_HackerInventory_C_OnWeaponHolsterFinished::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.UpdateWeaponObstruction
// 0x0060 (0x0060 - 0x0000)
struct COMP_HackerInventory_C_UpdateWeaponObstruction final
{
public:
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue_1;                // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_BooleanAND_ReturnValue;                   // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_MeleeWeapon_Base_C*               K2Node_DynamicCast_AsITEM_Melee_Weapon_Base;       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Not_PreBool_ReturnValue_2;                // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 CallFunc_GetActionMeshComponent_SkeletalMeshComponent; // 0x0028(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_BooleanOR_ReturnValue;                    // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimInstance*                          CallFunc_GetAnimInstance_ReturnValue;              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_BooleanAND_ReturnValue_1;                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IINTERF_ANIM_Hacker_C> K2Node_DynamicCast_AsINTERF_ANIM_Hacker;           // 0x0048(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          K2Node_DynamicCast_bSuccess_1;                     // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SetWeaponObstructed_Result;               // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_UpdateWeaponObstruction) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_UpdateWeaponObstruction");
static_assert(sizeof(COMP_HackerInventory_C_UpdateWeaponObstruction) == 0x000060, "Wrong size on COMP_HackerInventory_C_UpdateWeaponObstruction");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_IsValid_ReturnValue) == 0x000000, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_Not_PreBool_ReturnValue) == 0x000001, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_Not_PreBool_ReturnValue_1) == 0x000002, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_Not_PreBool_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_BooleanAND_ReturnValue) == 0x000003, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_BooleanAND_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, K2Node_DynamicCast_AsITEM_Melee_Weapon_Base) == 0x000008, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::K2Node_DynamicCast_AsITEM_Melee_Weapon_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, K2Node_DynamicCast_bSuccess) == 0x000010, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_GetHackerOwner_Hacker) == 0x000018, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_Not_PreBool_ReturnValue_2) == 0x000020, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_Not_PreBool_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_GetActionMeshComponent_SkeletalMeshComponent) == 0x000028, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_GetActionMeshComponent_SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_BooleanOR_ReturnValue) == 0x000030, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_BooleanOR_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_GetAnimInstance_ReturnValue) == 0x000038, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_GetAnimInstance_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_BooleanAND_ReturnValue_1) == 0x000040, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_BooleanAND_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, K2Node_DynamicCast_AsINTERF_ANIM_Hacker) == 0x000048, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::K2Node_DynamicCast_AsINTERF_ANIM_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, K2Node_DynamicCast_bSuccess_1) == 0x000058, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::K2Node_DynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstruction, CallFunc_SetWeaponObstructed_Result) == 0x000059, "Member 'COMP_HackerInventory_C_UpdateWeaponObstruction::CallFunc_SetWeaponObstructed_Result' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.GetCurrentObstructionDistance
// 0x000C (0x000C - 0x0000)
struct COMP_HackerInventory_C_GetCurrentObstructionDistance final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_GetWeaponObstructionDistance_Distance;    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_GetCurrentObstructionDistance) == 0x000004, "Wrong alignment on COMP_HackerInventory_C_GetCurrentObstructionDistance");
static_assert(sizeof(COMP_HackerInventory_C_GetCurrentObstructionDistance) == 0x00000C, "Wrong size on COMP_HackerInventory_C_GetCurrentObstructionDistance");
static_assert(offsetof(COMP_HackerInventory_C_GetCurrentObstructionDistance, Distance) == 0x000000, "Member 'COMP_HackerInventory_C_GetCurrentObstructionDistance::Distance' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetCurrentObstructionDistance, CallFunc_GetWeaponObstructionDistance_Distance) == 0x000004, "Member 'COMP_HackerInventory_C_GetCurrentObstructionDistance::CallFunc_GetWeaponObstructionDistance_Distance' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_GetCurrentObstructionDistance, CallFunc_IsValid_ReturnValue) == 0x000008, "Member 'COMP_HackerInventory_C_GetCurrentObstructionDistance::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.UpdateWeaponObstructionDistance
// 0x0004 (0x0004 - 0x0000)
struct COMP_HackerInventory_C_UpdateWeaponObstructionDistance final
{
public:
	float                                         CallFunc_GetWeaponObstructionDistance_Distance;    // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_UpdateWeaponObstructionDistance) == 0x000004, "Wrong alignment on COMP_HackerInventory_C_UpdateWeaponObstructionDistance");
static_assert(sizeof(COMP_HackerInventory_C_UpdateWeaponObstructionDistance) == 0x000004, "Wrong size on COMP_HackerInventory_C_UpdateWeaponObstructionDistance");
static_assert(offsetof(COMP_HackerInventory_C_UpdateWeaponObstructionDistance, CallFunc_GetWeaponObstructionDistance_Distance) == 0x000000, "Member 'COMP_HackerInventory_C_UpdateWeaponObstructionDistance::CallFunc_GetWeaponObstructionDistance_Distance' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.TraceWeaponObstruction
// 0x01D0 (0x01D0 - 0x0000)
struct COMP_HackerInventory_C_TraceWeaponObstruction final
{
public:
	float                                         HitDistance;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    HitPrimitive;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                TargetTraceLocation;                               // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                TraceDirection;                                    // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                SourceTraceLocation;                               // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CallFunc_GetOwner_ReturnValue;                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Enemy_C*                          K2Node_DynamicCast_AsPAWN_Enemy;                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallFunc_GetCurrentObstructionDistance_Distance;   // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Subtract_FloatFloat_ReturnValue;          // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_LessEqual_FloatFloat_ReturnValue;         // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_BooleanAND_ReturnValue;                   // 0x005D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CallFunc_GetOwner_ReturnValue_1;                   // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class AActor*>                         K2Node_MakeArray_Array;                            // 0x0068(0x0010)(ConstParm, ReferenceParm)
	struct FVector                                CallFunc_Multiply_VectorFloat_ReturnValue;         // 0x0078(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_Add_VectorVector_ReturnValue;             // 0x0084(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FHitResult                             CallFunc_SphereTraceSingle_OutHit;                 // 0x0090(0x0088)(IsPlainOldData, NoDestructor, ContainsInstancedReference)
	bool                                          CallFunc_SphereTraceSingle_ReturnValue;            // 0x0118(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_BreakHitResult_bBlockingHit;              // 0x0119(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_BreakHitResult_bInitialOverlap;           // 0x011A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_11B[0x1];                                      // 0x011B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallFunc_BreakHitResult_Time;                      // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_BreakHitResult_Distance;                  // 0x0120(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_BreakHitResult_Location;                  // 0x0124(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_BreakHitResult_ImpactPoint;               // 0x0130(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_BreakHitResult_Normal;                    // 0x013C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_BreakHitResult_ImpactNormal;              // 0x0148(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      CallFunc_BreakHitResult_PhysMat;                   // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 CallFunc_BreakHitResult_HitActor;                  // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    CallFunc_BreakHitResult_HitComponent;              // 0x0168(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   CallFunc_BreakHitResult_HitBoneName;               // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_BreakHitResult_HitItem;                   // 0x0178(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_BreakHitResult_ElementIndex;              // 0x017C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_BreakHitResult_FaceIndex;                 // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_BreakHitResult_TraceStart;                // 0x0184(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_BreakHitResult_TraceEnd;                  // 0x0190(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker;                    // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_GetForwardVector_ReturnValue;             // 0x01A8(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_Hacker_Simple_C*                  CallFunc_GetHackerOwner_Hacker_1;                  // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_K2_GetComponentLocation_ReturnValue;      // 0x01C0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_TraceWeaponObstruction) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_TraceWeaponObstruction");
static_assert(sizeof(COMP_HackerInventory_C_TraceWeaponObstruction) == 0x0001D0, "Wrong size on COMP_HackerInventory_C_TraceWeaponObstruction");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, HitDistance) == 0x000000, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::HitDistance' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, HitPrimitive) == 0x000008, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::HitPrimitive' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, TargetTraceLocation) == 0x000010, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::TargetTraceLocation' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, TraceDirection) == 0x00001C, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::TraceDirection' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, SourceTraceLocation) == 0x000028, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::SourceTraceLocation' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_GetOwner_ReturnValue) == 0x000038, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_GetOwner_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_IsValid_ReturnValue) == 0x000040, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, K2Node_DynamicCast_AsPAWN_Enemy) == 0x000048, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::K2Node_DynamicCast_AsPAWN_Enemy' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, K2Node_DynamicCast_bSuccess) == 0x000050, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_IsValid_ReturnValue_1) == 0x000051, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_GetCurrentObstructionDistance_Distance) == 0x000054, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_GetCurrentObstructionDistance_Distance' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_Subtract_FloatFloat_ReturnValue) == 0x000058, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_Subtract_FloatFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_LessEqual_FloatFloat_ReturnValue) == 0x00005C, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_LessEqual_FloatFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BooleanAND_ReturnValue) == 0x00005D, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BooleanAND_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_GetOwner_ReturnValue_1) == 0x000060, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_GetOwner_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, K2Node_MakeArray_Array) == 0x000068, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::K2Node_MakeArray_Array' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_Multiply_VectorFloat_ReturnValue) == 0x000078, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_Multiply_VectorFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_Add_VectorVector_ReturnValue) == 0x000084, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_Add_VectorVector_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_SphereTraceSingle_OutHit) == 0x000090, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_SphereTraceSingle_OutHit' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_SphereTraceSingle_ReturnValue) == 0x000118, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_SphereTraceSingle_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_bBlockingHit) == 0x000119, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_bBlockingHit' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_bInitialOverlap) == 0x00011A, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_bInitialOverlap' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_Time) == 0x00011C, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_Time' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_Distance) == 0x000120, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_Distance' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_Location) == 0x000124, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_Location' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_ImpactPoint) == 0x000130, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_ImpactPoint' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_Normal) == 0x00013C, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_Normal' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_ImpactNormal) == 0x000148, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_ImpactNormal' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_PhysMat) == 0x000158, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_PhysMat' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_HitActor) == 0x000160, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_HitActor' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_HitComponent) == 0x000168, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_HitComponent' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_HitBoneName) == 0x000170, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_HitBoneName' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_HitItem) == 0x000178, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_HitItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_ElementIndex) == 0x00017C, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_ElementIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_FaceIndex) == 0x000180, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_FaceIndex' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_TraceStart) == 0x000184, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_TraceStart' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_BreakHitResult_TraceEnd) == 0x000190, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_BreakHitResult_TraceEnd' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_GetHackerOwner_Hacker) == 0x0001A0, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_GetHackerOwner_Hacker' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_GetForwardVector_ReturnValue) == 0x0001A8, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_GetForwardVector_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_GetHackerOwner_Hacker_1) == 0x0001B8, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_GetHackerOwner_Hacker_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_TraceWeaponObstruction, CallFunc_K2_GetComponentLocation_ReturnValue) == 0x0001C0, "Member 'COMP_HackerInventory_C_TraceWeaponObstruction::CallFunc_K2_GetComponentLocation_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.VaporizeJunkItems
// 0x0068 (0x0068 - 0x0000)
struct COMP_HackerInventory_C_VaporizeJunkItems final
{
public:
	class UITEM_Junk_Base_C*                      JunkItem;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UInventoryBag_C*                        GeneralBag;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         Temp_int_Loop_Counter_Variable;                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Add_IntInt_ReturnValue;                   // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         Temp_int_Array_Index_Variable;                     // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsDestructible_Result;                    // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CallFunc_GetObjectClass_ReturnValue;               // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_NotEqual_ClassClass_ReturnValue;          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_VaporizeJunkItem_Result;                  // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBag_C*                        CallFunc_GetBagByIndex_Bag;                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UITEM_Base_C*>                   CallFunc_GetItemArray_Items;                       // 0x0038(0x0010)(ReferenceParm)
	class UITEM_Base_C*                           CallFunc_Array_Get_Item;                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Array_Length_ReturnValue;                 // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UITEM_Junk_Base_C*                      K2Node_DynamicCast_AsITEM_Junk_Base;               // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Less_IntInt_ReturnValue;                  // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(COMP_HackerInventory_C_VaporizeJunkItems) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_VaporizeJunkItems");
static_assert(sizeof(COMP_HackerInventory_C_VaporizeJunkItems) == 0x000068, "Wrong size on COMP_HackerInventory_C_VaporizeJunkItems");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, JunkItem) == 0x000000, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::JunkItem' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, GeneralBag) == 0x000008, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::GeneralBag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, Temp_int_Loop_Counter_Variable) == 0x000010, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::Temp_int_Loop_Counter_Variable' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_Add_IntInt_ReturnValue) == 0x000014, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_Add_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, Temp_int_Array_Index_Variable) == 0x000018, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::Temp_int_Array_Index_Variable' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_IsDestructible_Result) == 0x00001C, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_IsDestructible_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_IsValid_ReturnValue) == 0x00001D, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_GetObjectClass_ReturnValue) == 0x000020, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_GetObjectClass_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_NotEqual_ClassClass_ReturnValue) == 0x000028, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_NotEqual_ClassClass_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_VaporizeJunkItem_Result) == 0x000029, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_VaporizeJunkItem_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_GetBagByIndex_Bag) == 0x000030, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_GetBagByIndex_Bag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_GetItemArray_Items) == 0x000038, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_GetItemArray_Items' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_Array_Get_Item) == 0x000048, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_Array_Get_Item' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_Array_Length_ReturnValue) == 0x000050, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_Array_Length_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, K2Node_DynamicCast_AsITEM_Junk_Base) == 0x000058, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::K2Node_DynamicCast_AsITEM_Junk_Base' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, K2Node_DynamicCast_bSuccess) == 0x000060, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_VaporizeJunkItems, CallFunc_Less_IntInt_ReturnValue) == 0x000061, "Member 'COMP_HackerInventory_C_VaporizeJunkItems::CallFunc_Less_IntInt_ReturnValue' has a wrong offset!");

// Function COMP_HackerInventory.COMP_HackerInventory_C.SortMainInventory
// 0x0020 (0x0020 - 0x0000)
struct COMP_HackerInventory_C_SortMainInventory final
{
public:
	class UITEM_WeaponBase_C*                     EquippedWeaponPriorToSort;                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UInventoryBag_C*                        GeneralBag;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_SortBag_Result;                           // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryBag_C*                        CallFunc_GetBagByIndex_Bag;                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(COMP_HackerInventory_C_SortMainInventory) == 0x000008, "Wrong alignment on COMP_HackerInventory_C_SortMainInventory");
static_assert(sizeof(COMP_HackerInventory_C_SortMainInventory) == 0x000020, "Wrong size on COMP_HackerInventory_C_SortMainInventory");
static_assert(offsetof(COMP_HackerInventory_C_SortMainInventory, EquippedWeaponPriorToSort) == 0x000000, "Member 'COMP_HackerInventory_C_SortMainInventory::EquippedWeaponPriorToSort' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SortMainInventory, GeneralBag) == 0x000008, "Member 'COMP_HackerInventory_C_SortMainInventory::GeneralBag' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SortMainInventory, CallFunc_IsValid_ReturnValue) == 0x000010, "Member 'COMP_HackerInventory_C_SortMainInventory::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SortMainInventory, CallFunc_SortBag_Result) == 0x000011, "Member 'COMP_HackerInventory_C_SortMainInventory::CallFunc_SortBag_Result' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SortMainInventory, CallFunc_IsValid_ReturnValue_1) == 0x000012, "Member 'COMP_HackerInventory_C_SortMainInventory::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(COMP_HackerInventory_C_SortMainInventory, CallFunc_GetBagByIndex_Bag) == 0x000018, "Member 'COMP_HackerInventory_C_SortMainInventory::CallFunc_GetBagByIndex_Bag' has a wrong offset!");

}

