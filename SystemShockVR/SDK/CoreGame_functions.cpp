#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreGame

#include "Basic.hpp"

#include "CoreGame_classes.hpp"
#include "CoreGame_parameters.hpp"


namespace SDK
{

// Function CoreGame.CoreGameFunctionLibrary.AddDataTableRow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::AddDataTableRow(class UDataTable* DataTable, class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "AddDataTableRow");

	Params::CoreGameFunctionLibrary_AddDataTableRow Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.AddStaticMeshComponent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       RelativeTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* UCoreGameFunctionLibrary::AddStaticMeshComponent(class USceneComponent* AttachToComponent, class UStaticMesh* StaticMesh, class FName SocketName, const struct FTransform& RelativeTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "AddStaticMeshComponent");

	Params::CoreGameFunctionLibrary_AddStaticMeshComponent Parms{};

	Parms.AttachToComponent = AttachToComponent;
	Parms.StaticMesh = StaticMesh;
	Parms.SocketName = SocketName;
	Parms.RelativeTransform = std::move(RelativeTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.AddStaticMeshComponentInEditor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       RelativeTransform                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* UCoreGameFunctionLibrary::AddStaticMeshComponentInEditor(class AActor* Owner, class UStaticMesh* StaticMesh, const struct FTransform& RelativeTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "AddStaticMeshComponentInEditor");

	Params::CoreGameFunctionLibrary_AddStaticMeshComponentInEditor Parms{};

	Parms.Owner = Owner;
	Parms.StaticMesh = StaticMesh;
	Parms.RelativeTransform = std::move(RelativeTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.AngleBetweenNormals
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::AngleBetweenNormals(const struct FVector& SourceVector, const struct FVector& TargetVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "AngleBetweenNormals");

	Params::CoreGameFunctionLibrary_AngleBetweenNormals Parms{};

	Parms.SourceVector = std::move(SourceVector);
	Parms.TargetVector = std::move(TargetVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.AngleBetweenVectors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::AngleBetweenVectors(const struct FVector& SourceVector, const struct FVector& TargetVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "AngleBetweenVectors");

	Params::CoreGameFunctionLibrary_AngleBetweenVectors Parms{};

	Parms.SourceVector = std::move(SourceVector);
	Parms.TargetVector = std::move(TargetVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ApplySkeletalMeshBodyTransforms
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               BodyTransforms                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::ApplySkeletalMeshBodyTransforms(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<struct FTransform>& BodyTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ApplySkeletalMeshBodyTransforms");

	Params::CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.BodyTransforms = std::move(BodyTransforms);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.AttachAndModifyComponentOwnership
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  TransferComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::AttachAndModifyComponentOwnership(class USceneComponent* TransferComponent, class USceneComponent* AttachToComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "AttachAndModifyComponentOwnership");

	Params::CoreGameFunctionLibrary_AttachAndModifyComponentOwnership Parms{};

	Parms.TransferComponent = TransferComponent;
	Parms.AttachToComponent = AttachToComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.AttachDistanceFieldMeshesToSkeletalMeshComponent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStaticMesh*>              StaticMeshes                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CollisionProfileName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PrefixKey                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Delimiter                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RelativeRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::AttachDistanceFieldMeshesToSkeletalMeshComponent(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class UStaticMesh*>& StaticMeshes, bool bVisible, class FName CollisionProfileName, const class FString& PrefixKey, const class FString& Delimiter, const struct FRotator& RelativeRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "AttachDistanceFieldMeshesToSkeletalMeshComponent");

	Params::CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.StaticMeshes = std::move(StaticMeshes);
	Parms.bVisible = bVisible;
	Parms.CollisionProfileName = CollisionProfileName;
	Parms.PrefixKey = std::move(PrefixKey);
	Parms.Delimiter = std::move(Delimiter);
	Parms.RelativeRotation = std::move(RelativeRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.BatchSetCustomPrimitiveData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UPrimitiveComponent*>      PrimitiveComponents                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::BatchSetCustomPrimitiveData(const TArray<class UPrimitiveComponent*>& PrimitiveComponents, int32 DataIndex, const TArray<float>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "BatchSetCustomPrimitiveData");

	Params::CoreGameFunctionLibrary_BatchSetCustomPrimitiveData Parms{};

	Parms.PrimitiveComponents = std::move(PrimitiveComponents);
	Parms.DataIndex = DataIndex;
	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.BindMontageOnBlendOutStarted
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UAnimMontage* Montage, bool bInterrupted)>Event                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::BindMontageOnBlendOutStarted(class UAnimInstance* AnimInstance, class UAnimMontage* Montage, const TDelegate<void(class UAnimMontage* Montage, bool bInterrupted)>& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "BindMontageOnBlendOutStarted");

	Params::CoreGameFunctionLibrary_BindMontageOnBlendOutStarted Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Montage = Montage;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.BindMontageOnEnded
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UAnimMontage* Montage, bool bInterrupted)>Event                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::BindMontageOnEnded(class UAnimInstance* AnimInstance, class UAnimMontage* Montage, const TDelegate<void(class UAnimMontage* Montage, bool bInterrupted)>& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "BindMontageOnEnded");

	Params::CoreGameFunctionLibrary_BindMontageOnEnded Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Montage = Montage;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.BitShiftLeft
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ShiftBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::BitShiftLeft(int32 Value, int32 ShiftBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "BitShiftLeft");

	Params::CoreGameFunctionLibrary_BitShiftLeft Parms{};

	Parms.Value = Value;
	Parms.ShiftBy = ShiftBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.BitShiftRight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ShiftBy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::BitShiftRight(int32 Value, int32 ShiftBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "BitShiftRight");

	Params::CoreGameFunctionLibrary_BitShiftRight Parms{};

	Parms.Value = Value;
	Parms.ShiftBy = ShiftBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.BoneIsChildOf
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParentBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::BoneIsChildOf(class USkeletalMesh* SkeletalMesh, class FName BoneName, class FName ParentBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "BoneIsChildOf");

	Params::CoreGameFunctionLibrary_BoneIsChildOf Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.BoneName = BoneName;
	Parms.ParentBoneName = ParentBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.BreakEnumHandleToNames
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEnumHandle                      EnumHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             EnumHandleName                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EnumeratorName                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::BreakEnumHandleToNames(const struct FEnumHandle& EnumHandle, class FName* EnumHandleName, class FName* EnumeratorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "BreakEnumHandleToNames");

	Params::CoreGameFunctionLibrary_BreakEnumHandleToNames Parms{};

	Parms.EnumHandle = std::move(EnumHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EnumHandleName != nullptr)
		*EnumHandleName = Parms.EnumHandleName;

	if (EnumeratorName != nullptr)
		*EnumeratorName = Parms.EnumeratorName;
}


// Function CoreGame.CoreGameFunctionLibrary.BreakEnumHandleToStrings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEnumHandle                      EnumHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           EnumHandleString                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           EnumeratorString                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::BreakEnumHandleToStrings(const struct FEnumHandle& EnumHandle, class FString* EnumHandleString, class FString* EnumeratorString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "BreakEnumHandleToStrings");

	Params::CoreGameFunctionLibrary_BreakEnumHandleToStrings Parms{};

	Parms.EnumHandle = std::move(EnumHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EnumHandleString != nullptr)
		*EnumHandleString = std::move(Parms.EnumHandleString);

	if (EnumeratorString != nullptr)
		*EnumeratorString = std::move(Parms.EnumeratorString);
}


// Function CoreGame.CoreGameFunctionLibrary.CallEventByHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLatentEventHandle               EventHandle                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::CallEventByHandle(const struct FLatentEventHandle& EventHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CallEventByHandle");

	Params::CoreGameFunctionLibrary_CallEventByHandle Parms{};

	Parms.EventHandle = std::move(EventHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CallObjectEventByHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLatentObjectEventHandle         EventHandle                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::CallObjectEventByHandle(const struct FLatentObjectEventHandle& EventHandle, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CallObjectEventByHandle");

	Params::CoreGameFunctionLibrary_CallObjectEventByHandle Parms{};

	Parms.EventHandle = std::move(EventHandle);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CapsuleOverlapComponents
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsuleLocation                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsuleAxis                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::CapsuleOverlapComponents(const class UObject* WorldContextObject, const struct FVector& CapsuleLocation, const struct FVector& CapsuleAxis, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, TSubclassOf<class UActorComponent> ClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CapsuleOverlapComponents");

	Params::CoreGameFunctionLibrary_CapsuleOverlapComponents Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CapsuleLocation = std::move(CapsuleLocation);
	Parms.CapsuleAxis = std::move(CapsuleAxis);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.TraceChannel = TraceChannel;
	Parms.ClassFilter = ClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ClampAxes2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        MinAxisValues                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        MaxAxisValues                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCoreGameFunctionLibrary::ClampAxes2D(const struct FVector2D& Vector, const struct FVector2D& MinAxisValues, const struct FVector2D& MaxAxisValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ClampAxes2D");

	Params::CoreGameFunctionLibrary_ClampAxes2D Parms{};

	Parms.Vector = std::move(Vector);
	Parms.MinAxisValues = std::move(MinAxisValues);
	Parms.MaxAxisValues = std::move(MaxAxisValues);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ClampPointToLozenge2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LozengeCenter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LozengeHalfExtents                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LozengeRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UCoreGameFunctionLibrary::ClampPointToLozenge2D(const struct FVector2D& Point, const struct FVector2D& LozengeCenter, const struct FVector2D& LozengeHalfExtents, float LozengeRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ClampPointToLozenge2D");

	Params::CoreGameFunctionLibrary_ClampPointToLozenge2D Parms{};

	Parms.Point = std::move(Point);
	Parms.LozengeCenter = std::move(LozengeCenter);
	Parms.LozengeHalfExtents = std::move(LozengeHalfExtents);
	Parms.LozengeRadius = LozengeRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ClearStaticMeshOverrideColorsForVertices
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<int32>                             VertexIndices                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::ClearStaticMeshOverrideColorsForVertices(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, const TSet<int32>& VertexIndices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ClearStaticMeshOverrideColorsForVertices");

	Params::CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LODIndex = LODIndex;
	Parms.VertexIndices = std::move(VertexIndices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ClosestPointOnBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FBox                             Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCoreGameFunctionLibrary::ClosestPointOnBox(const struct FBox& Box, const struct FVector& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ClosestPointOnBox");

	Params::CoreGameFunctionLibrary_ClosestPointOnBox Parms{};

	Parms.Box = std::move(Box);
	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ClosestPointsOnSegments
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          SegmentAStart                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentAEnd                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentBStart                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentBEnd                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ClosestOnA                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ClosestOnB                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::ClosestPointsOnSegments(const struct FVector& SegmentAStart, const struct FVector& SegmentAEnd, const struct FVector& SegmentBStart, const struct FVector& SegmentBEnd, struct FVector* ClosestOnA, struct FVector* ClosestOnB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ClosestPointsOnSegments");

	Params::CoreGameFunctionLibrary_ClosestPointsOnSegments Parms{};

	Parms.SegmentAStart = std::move(SegmentAStart);
	Parms.SegmentAEnd = std::move(SegmentAEnd);
	Parms.SegmentBStart = std::move(SegmentBStart);
	Parms.SegmentBEnd = std::move(SegmentBEnd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ClosestOnA != nullptr)
		*ClosestOnA = std::move(Parms.ClosestOnA);

	if (ClosestOnB != nullptr)
		*ClosestOnB = std::move(Parms.ClosestOnB);
}


// Function CoreGame.CoreGameFunctionLibrary.ComponentOverlapActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::ComponentOverlapActors(class UPrimitiveComponent* Component, TSubclassOf<class AActor> ClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ComponentOverlapActors");

	Params::CoreGameFunctionLibrary_ComponentOverlapActors Parms{};

	Parms.Component = Component;
	Parms.ClassFilter = ClassFilter;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ComponentOverlapComponents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::ComponentOverlapComponents(class UPrimitiveComponent* Component, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ComponentOverlapComponents");

	Params::CoreGameFunctionLibrary_ComponentOverlapComponents Parms{};

	Parms.Component = Component;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ComputeHorizontalFOV
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   VerticalFOV                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ViewportSize                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::ComputeHorizontalFOV(float VerticalFOV, const struct FVector2D& ViewportSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ComputeHorizontalFOV");

	Params::CoreGameFunctionLibrary_ComputeHorizontalFOV Parms{};

	Parms.VerticalFOV = VerticalFOV;
	Parms.ViewportSize = std::move(ViewportSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ComputeVerticalFOV
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   HorizontalFOV                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ViewportSize                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::ComputeVerticalFOV(float HorizontalFOV, const struct FVector2D& ViewportSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ComputeVerticalFOV");

	Params::CoreGameFunctionLibrary_ComputeVerticalFOV Parms{};

	Parms.HorizontalFOV = HorizontalFOV;
	Parms.ViewportSize = std::move(ViewportSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ConditionalDestroyObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::ConditionalDestroyObject(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ConditionalDestroyObject");

	Params::CoreGameFunctionLibrary_ConditionalDestroyObject Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CopyCustomPrimitiveData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              SourcePrimitiveComponent                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              TargetPrimitiveComponent                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetDefaults                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::CopyCustomPrimitiveData(class UPrimitiveComponent* SourcePrimitiveComponent, class UPrimitiveComponent* TargetPrimitiveComponent, bool bSetDefaults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CopyCustomPrimitiveData");

	Params::CoreGameFunctionLibrary_CopyCustomPrimitiveData Parms{};

	Parms.SourcePrimitiveComponent = SourcePrimitiveComponent;
	Parms.TargetPrimitiveComponent = TargetPrimitiveComponent;
	Parms.bSetDefaults = bSetDefaults;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.CountBits
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Bits                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::CountBits(int32 Bits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CountBits");

	Params::CoreGameFunctionLibrary_CountBits Parms{};

	Parms.Bits = Bits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateAudioComponentAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EAttachLocation                         LocationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAttachedToDestroyed                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UCoreGameFunctionLibrary::CreateAudioComponentAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateAudioComponentAttached");

	Params::CoreGameFunctionLibrary_CreateAudioComponentAttached Parms{};

	Parms.Sound = Sound;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateCompositeSkeletalMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           PackagePath                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MeshName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USkeletalMesh*>            SkeletalMeshes                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* UCoreGameFunctionLibrary::CreateCompositeSkeletalMesh(const class FString& PackagePath, const class FString& MeshName, const TArray<class USkeletalMesh*>& SkeletalMeshes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateCompositeSkeletalMesh");

	Params::CoreGameFunctionLibrary_CreateCompositeSkeletalMesh Parms{};

	Parms.PackagePath = std::move(PackagePath);
	Parms.MeshName = std::move(MeshName);
	Parms.SkeletalMeshes = std::move(SkeletalMeshes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateEventHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TDelegate<void()>                       Event                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLatentEventHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLatentEventHandle UCoreGameFunctionLibrary::CreateEventHandle(const TDelegate<void()>& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateEventHandle");

	Params::CoreGameFunctionLibrary_CreateEventHandle Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateIntRectangle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntPoint                        DesiredMin                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        DesiredMax                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntRectangle                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntRectangle UCoreGameFunctionLibrary::CreateIntRectangle(const struct FIntPoint& DesiredMin, const struct FIntPoint& DesiredMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateIntRectangle");

	Params::CoreGameFunctionLibrary_CreateIntRectangle Parms{};

	Parms.DesiredMin = std::move(DesiredMin);
	Parms.DesiredMax = std::move(DesiredMax);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateObjectEventHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TDelegate<void(class UObject* Object)>  Event                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FLatentObjectEventHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FLatentObjectEventHandle UCoreGameFunctionLibrary::CreateObjectEventHandle(const TDelegate<void(class UObject* Object)>& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateObjectEventHandle");

	Params::CoreGameFunctionLibrary_CreateObjectEventHandle Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateResizedTextureFromRenderTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DesiredWidth                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DesiredHeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCoreGameFunctionLibrary::CreateResizedTextureFromRenderTarget(class UTextureRenderTarget2D* RenderTarget, int32 DesiredWidth, int32 DesiredHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateResizedTextureFromRenderTarget");

	Params::CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget Parms{};

	Parms.RenderTarget = RenderTarget;
	Parms.DesiredWidth = DesiredWidth;
	Parms.DesiredHeight = DesiredHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateSceneCaptureWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WorldName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWantsTick                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneCaptureComponent2D*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneCaptureComponent2D* UCoreGameFunctionLibrary::CreateSceneCaptureWorld(const class UObject* WorldContextObject, class FName WorldName, bool bWantsTick, class UTextureRenderTarget2D* RenderTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateSceneCaptureWorld");

	Params::CoreGameFunctionLibrary_CreateSceneCaptureWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldName = WorldName;
	Parms.bWantsTick = bWantsTick;
	Parms.RenderTarget = RenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateStaticMeshesFromPhysicsAssetHulls
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPhysicsAsset*                    PhysicsAsset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMergeMirroredMeshes                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ExcludeBones                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SubDirectory                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStaticMesh*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UStaticMesh*> UCoreGameFunctionLibrary::CreateStaticMeshesFromPhysicsAssetHulls(class UPhysicsAsset* PhysicsAsset, class UMaterialInterface* Material, bool bMergeMirroredMeshes, const TArray<class FName>& ExcludeBones, const class FString& Prefix, const class FString& SubDirectory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateStaticMeshesFromPhysicsAssetHulls");

	Params::CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls Parms{};

	Parms.PhysicsAsset = PhysicsAsset;
	Parms.Material = Material;
	Parms.bMergeMirroredMeshes = bMergeMirroredMeshes;
	Parms.ExcludeBones = std::move(ExcludeBones);
	Parms.Prefix = std::move(Prefix);
	Parms.SubDirectory = std::move(SubDirectory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.CreateTextureFromRenderTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UCoreGameFunctionLibrary::CreateTextureFromRenderTarget(class UTextureRenderTarget2D* RenderTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "CreateTextureFromRenderTarget");

	Params::CoreGameFunctionLibrary_CreateTextureFromRenderTarget Parms{};

	Parms.RenderTarget = RenderTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.DestroySceneCaptureWorld
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneCaptureComponent2D*         SceneCaptureComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::DestroySceneCaptureWorld(class USceneCaptureComponent2D* SceneCaptureComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "DestroySceneCaptureWorld");

	Params::CoreGameFunctionLibrary_DestroySceneCaptureWorld Parms{};

	Parms.SceneCaptureComponent = SceneCaptureComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.DisableBodyCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecreatePhysics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::DisableBodyCollision(class USkeletalMeshComponent* SkeletalMeshComponent, class FName BoneName, bool bRecreatePhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "DisableBodyCollision");

	Params::CoreGameFunctionLibrary_DisableBodyCollision Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.BoneName = BoneName;
	Parms.bRecreatePhysics = bRecreatePhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.DuplicateObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UCoreGameFunctionLibrary::DuplicateObject(class UObject* WorldContextObject, class UObject* SourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "DuplicateObject");

	Params::CoreGameFunctionLibrary_DuplicateObject Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SourceObject = SourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.FillCylinderMeshBuffersFromSplineComponent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USplineComponent*                 SplineComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SegmentLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        TextureArea                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RingVertexCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTrimFromStart                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Vertices                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           Triangles                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Normals                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FVector2D>                TexCoords                                              (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::FillCylinderMeshBuffersFromSplineComponent(class USplineComponent* SplineComponent, float Radius, float SegmentLength, const struct FVector2D& TextureArea, int32 RingVertexCount, bool bTrimFromStart, TArray<struct FVector>& Vertices, TArray<int32>& Triangles, TArray<struct FVector>& Normals, TArray<struct FVector2D>& TexCoords)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "FillCylinderMeshBuffersFromSplineComponent");

	Params::CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent Parms{};

	Parms.SplineComponent = SplineComponent;
	Parms.Radius = Radius;
	Parms.SegmentLength = SegmentLength;
	Parms.TextureArea = std::move(TextureArea);
	Parms.RingVertexCount = RingVertexCount;
	Parms.bTrimFromStart = bTrimFromStart;
	Parms.Vertices = std::move(Vertices);
	Parms.Triangles = std::move(Triangles);
	Parms.Normals = std::move(Normals);
	Parms.TexCoords = std::move(TexCoords);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Vertices = std::move(Parms.Vertices);
	Triangles = std::move(Parms.Triangles);
	Normals = std::move(Parms.Normals);
	TexCoords = std::move(Parms.TexCoords);
}


// Function CoreGame.CoreGameFunctionLibrary.FindBestAxisVectors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutAxis1                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutAxis2                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::FindBestAxisVectors(const struct FVector& Vector, struct FVector* OutAxis1, struct FVector* OutAxis2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "FindBestAxisVectors");

	Params::CoreGameFunctionLibrary_FindBestAxisVectors Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAxis1 != nullptr)
		*OutAxis1 = std::move(Parms.OutAxis1);

	if (OutAxis2 != nullptr)
		*OutAxis2 = std::move(Parms.OutAxis2);
}


// Function CoreGame.CoreGameFunctionLibrary.ForceRecreatePhysicsState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::ForceRecreatePhysicsState(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ForceRecreatePhysicsState");

	Params::CoreGameFunctionLibrary_ForceRecreatePhysicsState Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.ForceRedrawAllViewports
// (Final, Native, Static, Public, BlueprintCallable)

void UCoreGameFunctionLibrary::ForceRedrawAllViewports()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ForceRedrawAllViewports");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.ForceUpdateBounds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::ForceUpdateBounds(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ForceUpdateBounds");

	Params::CoreGameFunctionLibrary_ForceUpdateBounds Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.GetActorByNameInSubLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                           SubLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCoreGameFunctionLibrary::GetActorByNameInSubLevel(class ULevel* SubLevel, class FName ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetActorByNameInSubLevel");

	Params::CoreGameFunctionLibrary_GetActorByNameInSubLevel Parms{};

	Parms.SubLevel = SubLevel;
	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetActorComponentByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ComponentName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UCoreGameFunctionLibrary::GetActorComponentByName(class AActor* Actor, class FName ComponentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetActorComponentByName");

	Params::CoreGameFunctionLibrary_GetActorComponentByName Parms{};

	Parms.Actor = Actor;
	Parms.ComponentName = ComponentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetActorLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* UCoreGameFunctionLibrary::GetActorLevel(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetActorLevel");

	Params::CoreGameFunctionLibrary_GetActorLevel Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetActorOfClassInSubLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                           SubLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCoreGameFunctionLibrary::GetActorOfClassInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> ClassFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetActorOfClassInSubLevel");

	Params::CoreGameFunctionLibrary_GetActorOfClassInSubLevel Parms{};

	Parms.SubLevel = SubLevel;
	Parms.ClassFilter = ClassFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetActorOfClassInSubLevelByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SubLevelName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCoreGameFunctionLibrary::GetActorOfClassInSubLevelByName(const class UObject* WorldContextObject, class FName SubLevelName, TSubclassOf<class AActor> ClassFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetActorOfClassInSubLevelByName");

	Params::CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SubLevelName = SubLevelName;
	Parms.ClassFilter = ClassFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetActorOfClassWithTagInSubLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                           SubLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCoreGameFunctionLibrary::GetActorOfClassWithTagInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> ClassFilter, class FName ActorTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetActorOfClassWithTagInSubLevel");

	Params::CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel Parms{};

	Parms.SubLevel = SubLevel;
	Parms.ClassFilter = ClassFilter;
	Parms.ActorTag = ActorTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetAllActorsOfClassInSubLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                           SubLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UCoreGameFunctionLibrary::GetAllActorsOfClassInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> ClassFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetAllActorsOfClassInSubLevel");

	Params::CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel Parms{};

	Parms.SubLevel = SubLevel;
	Parms.ClassFilter = ClassFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetAllActorsOfClassInSubLevelByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SubLevelName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UCoreGameFunctionLibrary::GetAllActorsOfClassInSubLevelByName(const class UObject* WorldContextObject, class FName SubLevelName, TSubclassOf<class AActor> ClassFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetAllActorsOfClassInSubLevelByName");

	Params::CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SubLevelName = SubLevelName;
	Parms.ClassFilter = ClassFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetAngleAroundAxis
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Axis                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetAngleAroundAxis(const struct FVector& SourceVector, const struct FVector& TargetVector, const struct FVector& Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetAngleAroundAxis");

	Params::CoreGameFunctionLibrary_GetAngleAroundAxis Parms{};

	Parms.SourceVector = std::move(SourceVector);
	Parms.TargetVector = std::move(TargetVector);
	Parms.Axis = std::move(Axis);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetBlueprintClasses
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           BaseClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Folder                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UClass*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UClass*> UCoreGameFunctionLibrary::GetBlueprintClasses(class UClass* BaseClass, const class FString& Name_0, const class FString& Folder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetBlueprintClasses");

	Params::CoreGameFunctionLibrary_GetBlueprintClasses Parms{};

	Parms.BaseClass = BaseClass;
	Parms.Name_0 = std::move(Name_0);
	Parms.Folder = std::move(Folder);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetBodyBoneNamesFromPhysicsAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPhysicsAsset*                    PhysicsAsset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCoreGameFunctionLibrary::GetBodyBoneNamesFromPhysicsAsset(class UPhysicsAsset* PhysicsAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetBodyBoneNamesFromPhysicsAsset");

	Params::CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset Parms{};

	Parms.PhysicsAsset = PhysicsAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetBoxContainmentOffset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ContentOffset                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ContentHalfExtent                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ContainerHalfExtent                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCoreGameFunctionLibrary::GetBoxContainmentOffset(const struct FVector& ContentOffset, const struct FVector& ContentHalfExtent, const struct FVector& ContainerHalfExtent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetBoxContainmentOffset");

	Params::CoreGameFunctionLibrary_GetBoxContainmentOffset Parms{};

	Parms.ContentOffset = std::move(ContentOffset);
	Parms.ContentHalfExtent = std::move(ContentHalfExtent);
	Parms.ContainerHalfExtent = std::move(ContainerHalfExtent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetBytesFromInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OutByteA                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OutByteB                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OutByteC                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OutByteD                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::GetBytesFromInt(int32 Value, uint8* OutByteA, uint8* OutByteB, uint8* OutByteC, uint8* OutByteD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetBytesFromInt");

	Params::CoreGameFunctionLibrary_GetBytesFromInt Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutByteA != nullptr)
		*OutByteA = Parms.OutByteA;

	if (OutByteB != nullptr)
		*OutByteB = Parms.OutByteB;

	if (OutByteC != nullptr)
		*OutByteC = Parms.OutByteC;

	if (OutByteD != nullptr)
		*OutByteD = Parms.OutByteD;
}


// Function CoreGame.CoreGameFunctionLibrary.GetChildComponentByClassAndSuffix
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Suffix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UCoreGameFunctionLibrary::GetChildComponentByClassAndSuffix(class USceneComponent* SceneComponent, TSubclassOf<class UActorComponent> ClassFilter, const class FString& Suffix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetChildComponentByClassAndSuffix");

	Params::CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.ClassFilter = ClassFilter;
	Parms.Suffix = std::move(Suffix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetChildComponentByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UCoreGameFunctionLibrary::GetChildComponentByTag(class USceneComponent* SceneComponent, TSubclassOf<class UActorComponent> ClassFilter, class FName Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetChildComponentByTag");

	Params::CoreGameFunctionLibrary_GetChildComponentByTag Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.ClassFilter = ClassFilter;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetChildComponentsByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDescendants                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCoreGameFunctionLibrary::GetChildComponentsByClass(class USceneComponent* SceneComponent, TSubclassOf<class UActorComponent> ClassFilter, bool bIncludeDescendants)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetChildComponentsByClass");

	Params::CoreGameFunctionLibrary_GetChildComponentsByClass Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.ClassFilter = ClassFilter;
	Parms.bIncludeDescendants = bIncludeDescendants;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetChildComponentsByClassFromArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USceneComponent*>          SceneComponents                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeDescendants                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCoreGameFunctionLibrary::GetChildComponentsByClassFromArray(const TArray<class USceneComponent*>& SceneComponents, TSubclassOf<class UActorComponent> ClassFilter, bool bIncludeDescendants)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetChildComponentsByClassFromArray");

	Params::CoreGameFunctionLibrary_GetChildComponentsByClassFromArray Parms{};

	Parms.SceneComponents = std::move(SceneComponents);
	Parms.ClassFilter = ClassFilter;
	Parms.bIncludeDescendants = bIncludeDescendants;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetClassComponentTemplate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UCoreGameFunctionLibrary::GetClassComponentTemplate(TSubclassOf<class AActor> ActorClass, TSubclassOf<class UActorComponent> ComponentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetClassComponentTemplate");

	Params::CoreGameFunctionLibrary_GetClassComponentTemplate Parms{};

	Parms.ActorClass = ActorClass;
	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetClassComponentTemplateByName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ComponentName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UCoreGameFunctionLibrary::GetClassComponentTemplateByName(TSubclassOf<class AActor> ActorClass, const class FString& ComponentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetClassComponentTemplateByName");

	Params::CoreGameFunctionLibrary_GetClassComponentTemplateByName Parms{};

	Parms.ActorClass = ActorClass;
	Parms.ComponentName = std::move(ComponentName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetClassDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UCoreGameFunctionLibrary::GetClassDefaultObject(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetClassDefaultObject");

	Params::CoreGameFunctionLibrary_GetClassDefaultObject Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetCurveValueSumOverTimeInterval
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCurveFloat*                      CurveFloat                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SampleCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SampleInterval                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetCurveValueSumOverTimeInterval(const class UCurveFloat* CurveFloat, int32 SampleCount, float SampleInterval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetCurveValueSumOverTimeInterval");

	Params::CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval Parms{};

	Parms.CurveFloat = CurveFloat;
	Parms.SampleCount = SampleCount;
	Parms.SampleInterval = SampleInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetCustomPrimitiveDataFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetCustomPrimitiveDataFloat(class UPrimitiveComponent* PrimitiveComponent, int32 DataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetCustomPrimitiveDataFloat");

	Params::CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.DataIndex = DataIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetCustomPrimitiveDataVector4
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector4 UCoreGameFunctionLibrary::GetCustomPrimitiveDataVector4(class UPrimitiveComponent* PrimitiveComponent, int32 DataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetCustomPrimitiveDataVector4");

	Params::CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4 Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.DataIndex = DataIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetDataTableRowCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::GetDataTableRowCount(class UDataTable* DataTable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetDataTableRowCount");

	Params::CoreGameFunctionLibrary_GetDataTableRowCount Parms{};

	Parms.DataTable = DataTable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetDistanceAlongPathAtElapsedTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   TotalPathLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AccelerationTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetDistanceAlongPathAtElapsedTime(float TotalPathLength, float MaxSpeed, float AccelerationTime, float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetDistanceAlongPathAtElapsedTime");

	Params::CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime Parms{};

	Parms.TotalPathLength = TotalPathLength;
	Parms.MaxSpeed = MaxSpeed;
	Parms.AccelerationTime = AccelerationTime;
	Parms.ElapsedTime = ElapsedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetDistanceBetweenShapeAndSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UShapeComponent*                  ShapeComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentStart                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SegmentEnd                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetDistanceBetweenShapeAndSegment(class UShapeComponent* ShapeComponent, const struct FVector& SegmentStart, const struct FVector& SegmentEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetDistanceBetweenShapeAndSegment");

	Params::CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment Parms{};

	Parms.ShapeComponent = ShapeComponent;
	Parms.SegmentStart = std::move(SegmentStart);
	Parms.SegmentEnd = std::move(SegmentEnd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetEnumeratorTextFromHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEnumHandle                      EnumHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCoreGameFunctionLibrary::GetEnumeratorTextFromHandle(const struct FEnumHandle& EnumHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetEnumeratorTextFromHandle");

	Params::CoreGameFunctionLibrary_GetEnumeratorTextFromHandle Parms{};

	Parms.EnumHandle = std::move(EnumHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetEnumValueByName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                            Enum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UCoreGameFunctionLibrary::GetEnumValueByName(class UEnum* Enum, class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetEnumValueByName");

	Params::CoreGameFunctionLibrary_GetEnumValueByName Parms{};

	Parms.Enum = Enum;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetExactStaticMeshBoundsWithTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UCoreGameFunctionLibrary::GetExactStaticMeshBoundsWithTransform(class UStaticMesh* StaticMesh, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetExactStaticMeshBoundsWithTransform");

	Params::CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetExactStaticMeshCollisionBoundsForComponent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UCoreGameFunctionLibrary::GetExactStaticMeshCollisionBoundsForComponent(class UStaticMeshComponent* StaticMeshComponent, bool bIncludeChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetExactStaticMeshCollisionBoundsForComponent");

	Params::CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.bIncludeChildren = bIncludeChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetExactStaticMeshCollisionBoundsWithTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UCoreGameFunctionLibrary::GetExactStaticMeshCollisionBoundsWithTransform(class UStaticMesh* StaticMesh, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetExactStaticMeshCollisionBoundsWithTransform");

	Params::CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetFilteredActorsInSubLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                           SubLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               RequireActorClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               IgnoreActorClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      RequireComponentClass                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmobile                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMobile                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UCoreGameFunctionLibrary::GetFilteredActorsInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> RequireActorClass, TSubclassOf<class AActor> IgnoreActorClass, TSubclassOf<class UActorComponent> RequireComponentClass, bool bImmobile, bool bMobile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetFilteredActorsInSubLevel");

	Params::CoreGameFunctionLibrary_GetFilteredActorsInSubLevel Parms{};

	Parms.SubLevel = SubLevel;
	Parms.RequireActorClass = RequireActorClass;
	Parms.IgnoreActorClass = IgnoreActorClass;
	Parms.RequireComponentClass = RequireComponentClass;
	Parms.bImmobile = bImmobile;
	Parms.bMobile = bMobile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetFilteredComponentsInSubLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULevel*                           SubLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               RequireActorClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               IgnoreActorClass                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      RequireComponentClass                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmobile                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMobile                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCoreGameFunctionLibrary::GetFilteredComponentsInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> RequireActorClass, TSubclassOf<class AActor> IgnoreActorClass, TSubclassOf<class UActorComponent> RequireComponentClass, bool bImmobile, bool bMobile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetFilteredComponentsInSubLevel");

	Params::CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel Parms{};

	Parms.SubLevel = SubLevel;
	Parms.RequireActorClass = RequireActorClass;
	Parms.IgnoreActorClass = IgnoreActorClass;
	Parms.RequireComponentClass = RequireComponentClass;
	Parms.bImmobile = bImmobile;
	Parms.bMobile = bMobile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetFirstParentBoneLocationInCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCapsuleComponent*                CapsuleComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutBoneLocation                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutExteriorBoneNames                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCoreGameFunctionLibrary::GetFirstParentBoneLocationInCapsule(class USkeletalMeshComponent* SkeletalMeshComponent, class UCapsuleComponent* CapsuleComponent, class FName SocketName, struct FVector* OutBoneLocation, TArray<class FName>* OutExteriorBoneNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetFirstParentBoneLocationInCapsule");

	Params::CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.CapsuleComponent = CapsuleComponent;
	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBoneLocation != nullptr)
		*OutBoneLocation = std::move(Parms.OutBoneLocation);

	if (OutExteriorBoneNames != nullptr)
		*OutExteriorBoneNames = std::move(Parms.OutExteriorBoneNames);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetLagrangeInterp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector2D>                Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetLagrangeInterp(const TArray<struct FVector2D>& Points, float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetLagrangeInterp");

	Params::CoreGameFunctionLibrary_GetLagrangeInterp Parms{};

	Parms.Points = std::move(Points);
	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetLastRenderTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentTime                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetLastRenderTime(class UPrimitiveComponent* PrimitiveComponent, float* CurrentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetLastRenderTime");

	Params::CoreGameFunctionLibrary_GetLastRenderTime Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurrentTime != nullptr)
		*CurrentTime = Parms.CurrentTime;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetLocationAlongPathAtElapsedTime
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AccelerationTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCoreGameFunctionLibrary::GetLocationAlongPathAtElapsedTime(const struct FVector& SourceLocation, const struct FVector& TargetLocation, float MaxSpeed, float AccelerationTime, float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetLocationAlongPathAtElapsedTime");

	Params::CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime Parms{};

	Parms.SourceLocation = std::move(SourceLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.MaxSpeed = MaxSpeed;
	Parms.AccelerationTime = AccelerationTime;
	Parms.ElapsedTime = ElapsedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetMontageRateScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetMontageRateScale(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetMontageRateScale");

	Params::CoreGameFunctionLibrary_GetMontageRateScale Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetPitchRotationTowards
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SourceRightDirection                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetPitchRotationTowards(const struct FVector& SourceDirection, const struct FVector& SourceRightDirection, const struct FVector& TargetVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetPitchRotationTowards");

	Params::CoreGameFunctionLibrary_GetPitchRotationTowards Parms{};

	Parms.SourceDirection = std::move(SourceDirection);
	Parms.SourceRightDirection = std::move(SourceRightDirection);
	Parms.TargetVector = std::move(TargetVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetPlaneNormal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPlane                           Plane                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCoreGameFunctionLibrary::GetPlaneNormal(const struct FPlane& Plane)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetPlaneNormal");

	Params::CoreGameFunctionLibrary_GetPlaneNormal Parms{};

	Parms.Plane = std::move(Plane);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetPlaneOrigin
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPlane                           Plane                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCoreGameFunctionLibrary::GetPlaneOrigin(const struct FPlane& Plane)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetPlaneOrigin");

	Params::CoreGameFunctionLibrary_GetPlaneOrigin Parms{};

	Parms.Plane = std::move(Plane);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetProjectedShapeBoundsInWidget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UShapeComponent*                  ShapeComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBoxAsLozenge                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           OutScreenBounds                                        (Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::GetProjectedShapeBoundsInWidget(class APlayerController* PlayerController, class UShapeComponent* ShapeComponent, bool bBoxAsLozenge, struct FBox2D* OutScreenBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetProjectedShapeBoundsInWidget");

	Params::CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget Parms{};

	Parms.PlayerController = PlayerController;
	Parms.ShapeComponent = ShapeComponent;
	Parms.bBoxAsLozenge = bBoxAsLozenge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScreenBounds != nullptr)
		*OutScreenBounds = std::move(Parms.OutScreenBounds);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetProjectedSphereBoundsInWidget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           OutScreenBounds                                        (Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::GetProjectedSphereBoundsInWidget(class APlayerController* PlayerController, const struct FVector& Center, float Radius, struct FBox2D* OutScreenBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetProjectedSphereBoundsInWidget");

	Params::CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScreenBounds != nullptr)
		*OutScreenBounds = std::move(Parms.OutScreenBounds);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetRotationTowards
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SourceUpVector                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutRotationAxis                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetRotationTowards(const struct FVector& SourceVector, const struct FVector& SourceUpVector, const struct FVector& TargetVector, struct FVector* OutRotationAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetRotationTowards");

	Params::CoreGameFunctionLibrary_GetRotationTowards Parms{};

	Parms.SourceVector = std::move(SourceVector);
	Parms.SourceUpVector = std::move(SourceUpVector);
	Parms.TargetVector = std::move(TargetVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRotationAxis != nullptr)
		*OutRotationAxis = std::move(Parms.OutRotationAxis);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetRotationTowardsXY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::GetRotationTowardsXY(const struct FVector& SourceVector, const struct FVector& TargetVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetRotationTowardsXY");

	Params::CoreGameFunctionLibrary_GetRotationTowardsXY Parms{};

	Parms.SourceVector = std::move(SourceVector);
	Parms.TargetVector = std::move(TargetVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSetBitIndices
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Bits                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UCoreGameFunctionLibrary::GetSetBitIndices(int32 Bits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSetBitIndices");

	Params::CoreGameFunctionLibrary_GetSetBitIndices Parms{};

	Parms.Bits = Bits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSimulatingPhysicsComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPrimitiveComponent*> UCoreGameFunctionLibrary::GetSimulatingPhysicsComponents(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSimulatingPhysicsComponents");

	Params::CoreGameFunctionLibrary_GetSimulatingPhysicsComponents Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSkeletalMeshBodyTransforms
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTransform> UCoreGameFunctionLibrary::GetSkeletalMeshBodyTransforms(class USkeletalMeshComponent* SkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSkeletalMeshBodyTransforms");

	Params::CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSmoothApproxBoundsWithTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBox                             LocalBounds                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UCoreGameFunctionLibrary::GetSmoothApproxBoundsWithTransform(const struct FBox& LocalBounds, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSmoothApproxBoundsWithTransform");

	Params::CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform Parms{};

	Parms.LocalBounds = std::move(LocalBounds);
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSmoothMovementParameters
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   TotalPathLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AccelerationTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutAcceleration                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutConstantSpeedDuration                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutConstantSpeedDistance                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutActualAccelerationTime                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutActualAccelerationDistance                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::GetSmoothMovementParameters(float TotalPathLength, float MaxSpeed, float AccelerationTime, float* OutAcceleration, float* OutConstantSpeedDuration, float* OutConstantSpeedDistance, float* OutActualAccelerationTime, float* OutActualAccelerationDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSmoothMovementParameters");

	Params::CoreGameFunctionLibrary_GetSmoothMovementParameters Parms{};

	Parms.TotalPathLength = TotalPathLength;
	Parms.MaxSpeed = MaxSpeed;
	Parms.AccelerationTime = AccelerationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAcceleration != nullptr)
		*OutAcceleration = Parms.OutAcceleration;

	if (OutConstantSpeedDuration != nullptr)
		*OutConstantSpeedDuration = Parms.OutConstantSpeedDuration;

	if (OutConstantSpeedDistance != nullptr)
		*OutConstantSpeedDistance = Parms.OutConstantSpeedDistance;

	if (OutActualAccelerationTime != nullptr)
		*OutActualAccelerationTime = Parms.OutActualAccelerationTime;

	if (OutActualAccelerationDistance != nullptr)
		*OutActualAccelerationDistance = Parms.OutActualAccelerationDistance;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSortedChildComponentsByClassAndPrefix
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCoreGameFunctionLibrary::GetSortedChildComponentsByClassAndPrefix(class USceneComponent* SceneComponent, TSubclassOf<class UActorComponent> ClassFilter, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSortedChildComponentsByClassAndPrefix");

	Params::CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix Parms{};

	Parms.SceneComponent = SceneComponent;
	Parms.ClassFilter = ClassFilter;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSortedComponentsByClassAndPrefix
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ClassFilter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Prefix                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCoreGameFunctionLibrary::GetSortedComponentsByClassAndPrefix(class AActor* Actor, TSubclassOf<class UActorComponent> ClassFilter, const class FString& Prefix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSortedComponentsByClassAndPrefix");

	Params::CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix Parms{};

	Parms.Actor = Actor;
	Parms.ClassFilter = ClassFilter;
	Parms.Prefix = std::move(Prefix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetStaticMeshVertexIndicesOfTrianglesInBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             LocalBox                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TSet<int32>                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<int32> UCoreGameFunctionLibrary::GetStaticMeshVertexIndicesOfTrianglesInBox(class UStaticMesh* StaticMesh, int32 LODIndex, const struct FBox& LocalBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetStaticMeshVertexIndicesOfTrianglesInBox");

	Params::CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.LODIndex = LODIndex;
	Parms.LocalBox = std::move(LocalBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSubLevelByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SubLevelName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevel* UCoreGameFunctionLibrary::GetSubLevelByName(const class UObject* WorldContextObject, class FName SubLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSubLevelByName");

	Params::CoreGameFunctionLibrary_GetSubLevelByName Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SubLevelName = SubLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetSuperClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UCoreGameFunctionLibrary::GetSuperClass(class UClass* Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetSuperClass");

	Params::CoreGameFunctionLibrary_GetSuperClass Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetUClassName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                           InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCoreGameFunctionLibrary::GetUClassName(class UClass* InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetUClassName");

	Params::CoreGameFunctionLibrary_GetUClassName Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetVectorNormalAndLength
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutLength                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCoreGameFunctionLibrary::GetVectorNormalAndLength(const struct FVector& Vector, float* OutLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetVectorNormalAndLength");

	Params::CoreGameFunctionLibrary_GetVectorNormalAndLength Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLength != nullptr)
		*OutLength = Parms.OutLength;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetVoxelCoordsFromVoxelIndex
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   VoxelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        LevelSize2D                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UCoreGameFunctionLibrary::GetVoxelCoordsFromVoxelIndex(int32 VoxelIndex, const struct FIntPoint& LevelSize2D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetVoxelCoordsFromVoxelIndex");

	Params::CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex Parms{};

	Parms.VoxelIndex = VoxelIndex;
	Parms.LevelSize2D = std::move(LevelSize2D);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetVoxelIndexFromVoxelCoords
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       VoxelCoords                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        LevelSize2D                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::GetVoxelIndexFromVoxelCoords(const struct FIntVector& VoxelCoords, const struct FIntPoint& LevelSize2D)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetVoxelIndexFromVoxelCoords");

	Params::CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords Parms{};

	Parms.VoxelCoords = std::move(VoxelCoords);
	Parms.LevelSize2D = std::move(LevelSize2D);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetWeightedDistancesBetweenPointAndBodyInstances
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bScaleByMass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, class FName>          BoneRemapping                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<class FName, float>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, float> UCoreGameFunctionLibrary::GetWeightedDistancesBetweenPointAndBodyInstances(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FVector& WorldLocation, float MaxDistance, bool bScaleByMass, const TMap<class FName, class FName>& BoneRemapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetWeightedDistancesBetweenPointAndBodyInstances");

	Params::CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.MaxDistance = MaxDistance;
	Parms.bScaleByMass = bScaleByMass;
	Parms.BoneRemapping = std::move(BoneRemapping);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetWeightedRandomIndexFromFloatArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                           Weights                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::GetWeightedRandomIndexFromFloatArray(const TArray<float>& Weights)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetWeightedRandomIndexFromFloatArray");

	Params::CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray Parms{};

	Parms.Weights = std::move(Weights);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetWeightedRandomIndexFromStructArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UObject*>                  WeightedStructs                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ExcludeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::GetWeightedRandomIndexFromStructArray(const TArray<class UObject*>& WeightedStructs, int32 ExcludeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetWeightedRandomIndexFromStructArray");

	Params::CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray Parms{};

	Parms.WeightedStructs = std::move(WeightedStructs);
	Parms.ExcludeIndex = ExcludeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.GetWeightedRandomIndexFromStructArrayWithStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UObject*>                  WeightedStructs                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FRandomStream                    RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ExcludeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::GetWeightedRandomIndexFromStructArrayWithStream(const TArray<class UObject*>& WeightedStructs, const struct FRandomStream& RandomStream, int32 ExcludeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "GetWeightedRandomIndexFromStructArrayWithStream");

	Params::CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream Parms{};

	Parms.WeightedStructs = std::move(WeightedStructs);
	Parms.RandomStream = std::move(RandomStream);
	Parms.ExcludeIndex = ExcludeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.HashCombineInt32
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ValueA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ValueB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::HashCombineInt32(int32 ValueA, int32 ValueB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "HashCombineInt32");

	Params::CoreGameFunctionLibrary_HashCombineInt32 Parms{};

	Parms.ValueA = ValueA;
	Parms.ValueB = ValueB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.HashInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::HashInt64(int64 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "HashInt64");

	Params::CoreGameFunctionLibrary_HashInt64 Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.HashString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           String                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::HashString(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "HashString");

	Params::CoreGameFunctionLibrary_HashString Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.HasLoadedAllTextureMipsForForMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::HasLoadedAllTextureMipsForForMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "HasLoadedAllTextureMipsForForMaterial");

	Params::CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial Parms{};

	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.HasLoadedAllTextureMipsForStaticMeshComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildMeshComponents                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::HasLoadedAllTextureMipsForStaticMeshComponent(class UStaticMeshComponent* StaticMeshComponent, bool bIncludeChildMeshComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "HasLoadedAllTextureMipsForStaticMeshComponent");

	Params::CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.bIncludeChildMeshComponents = bIncludeChildMeshComponents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.HideActorFromPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::HideActorFromPlayer(class AActor* Actor, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "HideActorFromPlayer");

	Params::CoreGameFunctionLibrary_HideActorFromPlayer Parms{};

	Parms.Actor = Actor;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.IntersectBoxClipHull
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FBox                             Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FPlane>                   HullClipPlanes                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IntersectBoxClipHull(const struct FBox& Box, const TArray<struct FPlane>& HullClipPlanes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IntersectBoxClipHull");

	Params::CoreGameFunctionLibrary_IntersectBoxClipHull Parms{};

	Parms.Box = std::move(Box);
	Parms.HullClipPlanes = std::move(HullClipPlanes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IntersectBoxes
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FBox                             BoxA                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox                             BoxB                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IntersectBoxes(const struct FBox& BoxA, const struct FBox& BoxB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IntersectBoxes");

	Params::CoreGameFunctionLibrary_IntersectBoxes Parms{};

	Parms.BoxA = std::move(BoxA);
	Parms.BoxB = std::move(BoxB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IntersectBoxes2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FBox2D                           BoxA                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox2D                           BoxB                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IntersectBoxes2D(const struct FBox2D& BoxA, const struct FBox2D& BoxB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IntersectBoxes2D");

	Params::CoreGameFunctionLibrary_IntersectBoxes2D Parms{};

	Parms.BoxA = std::move(BoxA);
	Parms.BoxB = std::move(BoxB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IntersectRayBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          RayLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RayDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        OutTMinMax                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IntersectRayBox(const struct FVector& RayLocation, const struct FVector& RayDirection, const struct FBox& Box, struct FVector2D* OutTMinMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IntersectRayBox");

	Params::CoreGameFunctionLibrary_IntersectRayBox Parms{};

	Parms.RayLocation = std::move(RayLocation);
	Parms.RayDirection = std::move(RayDirection);
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTMinMax != nullptr)
		*OutTMinMax = std::move(Parms.OutTMinMax);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IntersectRaySphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          RayLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RayDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SphereCenter                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutTMinMax                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IntersectRaySphere(const struct FVector& RayLocation, const struct FVector& RayDirection, const struct FVector& SphereCenter, float SphereRadius, struct FVector2D* OutTMinMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IntersectRaySphere");

	Params::CoreGameFunctionLibrary_IntersectRaySphere Parms{};

	Parms.RayLocation = std::move(RayLocation);
	Parms.RayDirection = std::move(RayDirection);
	Parms.SphereCenter = std::move(SphereCenter);
	Parms.SphereRadius = SphereRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTMinMax != nullptr)
		*OutTMinMax = std::move(Parms.OutTMinMax);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IntersectSegmentBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          SourceLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          OutIntersectPoint                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IntersectSegmentBox(const struct FVector& SourceLocation, const struct FVector& TargetLocation, const struct FBox& Box, struct FVector* OutIntersectPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IntersectSegmentBox");

	Params::CoreGameFunctionLibrary_IntersectSegmentBox Parms{};

	Parms.SourceLocation = std::move(SourceLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIntersectPoint != nullptr)
		*OutIntersectPoint = std::move(Parms.OutIntersectPoint);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IntersectSegments2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        C                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        D                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IntersectSegments2D(const struct FVector2D& A, const struct FVector2D& B, const struct FVector2D& C, const struct FVector2D& D, float* OutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IntersectSegments2D");

	Params::CoreGameFunctionLibrary_IntersectSegments2D Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.C = std::move(C);
	Parms.D = std::move(D);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTime != nullptr)
		*OutTime = Parms.OutTime;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IntersectSweptSphereCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          SphereSource                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SphereTarget                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsuleCenter                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CapsuleAxis                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleHalfLength                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CapsuleRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutHitPoint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IntersectSweptSphereCapsule(const struct FVector& SphereSource, const struct FVector& SphereTarget, float SphereRadius, const struct FVector& CapsuleCenter, const struct FVector& CapsuleAxis, float CapsuleHalfLength, float CapsuleRadius, struct FVector* OutHitPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IntersectSweptSphereCapsule");

	Params::CoreGameFunctionLibrary_IntersectSweptSphereCapsule Parms{};

	Parms.SphereSource = std::move(SphereSource);
	Parms.SphereTarget = std::move(SphereTarget);
	Parms.SphereRadius = SphereRadius;
	Parms.CapsuleCenter = std::move(CapsuleCenter);
	Parms.CapsuleAxis = std::move(CapsuleAxis);
	Parms.CapsuleHalfLength = CapsuleHalfLength;
	Parms.CapsuleRadius = CapsuleRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitPoint != nullptr)
		*OutHitPoint = std::move(Parms.OutHitPoint);

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsBoxValid
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FBox                             Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsBoxValid(const struct FBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsBoxValid");

	Params::CoreGameFunctionLibrary_IsBoxValid Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsCompatibleMontageForAnimInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsCompatibleMontageForAnimInstance(class UAnimMontage* Montage, class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsCompatibleMontageForAnimInstance");

	Params::CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance Parms{};

	Parms.Montage = Montage;
	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsGame(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsGame");

	Params::CoreGameFunctionLibrary_IsGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsMontageUsingSlotName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsMontageUsingSlotName(class UAnimMontage* Montage, class FName SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsMontageUsingSlotName");

	Params::CoreGameFunctionLibrary_IsMontageUsingSlotName Parms{};

	Parms.Montage = Montage;
	Parms.SlotName = SlotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsOrthogonalRotation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsOrthogonalRotation(const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsOrthogonalRotation");

	Params::CoreGameFunctionLibrary_IsOrthogonalRotation Parms{};

	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsPointInBox2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsPointInBox2D(const struct FVector2D& Point, const struct FBox2D& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsPointInBox2D");

	Params::CoreGameFunctionLibrary_IsPointInBox2D Parms{};

	Parms.Point = std::move(Point);
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsPointInCapsule
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                CapsuleComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsPointInCapsule(class UCapsuleComponent* CapsuleComponent, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsPointInCapsule");

	Params::CoreGameFunctionLibrary_IsPointInCapsule Parms{};

	Parms.CapsuleComponent = CapsuleComponent;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsSimulatingInEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsSimulatingInEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsSimulatingInEditor");

	Params::CoreGameFunctionLibrary_IsSimulatingInEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.IsViewportInForeground
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::IsViewportInForeground(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "IsViewportInForeground");

	Params::CoreGameFunctionLibrary_IsViewportInForeground Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.MakeBoxFromPoints
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UCoreGameFunctionLibrary::MakeBoxFromPoints(const TArray<struct FVector>& Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "MakeBoxFromPoints");

	Params::CoreGameFunctionLibrary_MakeBoxFromPoints Parms{};

	Parms.Points = std::move(Points);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.MakeIntFromByteArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                           Bytes                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::MakeIntFromByteArray(const TArray<uint8>& Bytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "MakeIntFromByteArray");

	Params::CoreGameFunctionLibrary_MakeIntFromByteArray Parms{};

	Parms.Bytes = std::move(Bytes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.MakeIntFromBytes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   OutByteA                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OutByteB                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OutByteC                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OutByteD                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::MakeIntFromBytes(uint8 OutByteA, uint8 OutByteB, uint8 OutByteC, uint8 OutByteD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "MakeIntFromBytes");

	Params::CoreGameFunctionLibrary_MakeIntFromBytes Parms{};

	Parms.OutByteA = OutByteA;
	Parms.OutByteB = OutByteB;
	Parms.OutByteC = OutByteC;
	Parms.OutByteD = OutByteD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.MoveActorsToLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::MoveActorsToLevel(const TArray<class AActor*>& Actors, class ULevel* Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "MoveActorsToLevel");

	Params::CoreGameFunctionLibrary_MoveActorsToLevel Parms{};

	Parms.Actors = std::move(Actors);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.MoveActorToLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::MoveActorToLevel(class AActor* Actor, class ULevel* Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "MoveActorToLevel");

	Params::CoreGameFunctionLibrary_MoveActorToLevel Parms{};

	Parms.Actor = Actor;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.ObjectClassCollection_Identical
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FObjectClassCollection           CollectionA                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FObjectClassCollection           CollectionB                                            (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::ObjectClassCollection_Identical(const struct FObjectClassCollection& CollectionA, const struct FObjectClassCollection& CollectionB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "ObjectClassCollection_Identical");

	Params::CoreGameFunctionLibrary_ObjectClassCollection_Identical Parms{};

	Parms.CollectionA = std::move(CollectionA);
	Parms.CollectionB = std::move(CollectionB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.OutwardSpiralLoop
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   GridSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FIntPoint& OffsetPoint, bool* bExitLoop)>Event                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::OutwardSpiralLoop(int32 GridSize, const TDelegate<void(const struct FIntPoint& OffsetPoint, bool* bExitLoop)>& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "OutwardSpiralLoop");

	Params::CoreGameFunctionLibrary_OutwardSpiralLoop Parms{};

	Parms.GridSize = GridSize;
	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.PointBox2DSeparation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox2D                           Box                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::PointBox2DSeparation(const struct FVector2D& Point, const struct FBox2D& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "PointBox2DSeparation");

	Params::CoreGameFunctionLibrary_PointBox2DSeparation Parms{};

	Parms.Point = std::move(Point);
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.PoseSkeletalMeshPhysics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           FromSkeletalMeshComponent                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ToSkeletalMeshComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::PoseSkeletalMeshPhysics(class USkeletalMeshComponent* FromSkeletalMeshComponent, class USkeletalMeshComponent* ToSkeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "PoseSkeletalMeshPhysics");

	Params::CoreGameFunctionLibrary_PoseSkeletalMeshPhysics Parms{};

	Parms.FromSkeletalMeshComponent = FromSkeletalMeshComponent;
	Parms.ToSkeletalMeshComponent = ToSkeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.RandomIntegerInRangeExclusiveFromStream
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ExcludeValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRandomStream                    Stream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::RandomIntegerInRangeExclusiveFromStream(int32 Min, int32 Max, int32 ExcludeValue, const struct FRandomStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "RandomIntegerInRangeExclusiveFromStream");

	Params::CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.ExcludeValue = ExcludeValue;
	Parms.Stream = std::move(Stream);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.RandomizeBits
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   RandMinBitCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RandMaxBitCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalBitCount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequiredBitPosition                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::RandomizeBits(int32 RandMinBitCount, int32 RandMaxBitCount, int32 TotalBitCount, int32 RequiredBitPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "RandomizeBits");

	Params::CoreGameFunctionLibrary_RandomizeBits Parms{};

	Parms.RandMinBitCount = RandMinBitCount;
	Parms.RandMaxBitCount = RandMaxBitCount;
	Parms.TotalBitCount = TotalBitCount;
	Parms.RequiredBitPosition = RequiredBitPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.RemoveDataTableRow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::RemoveDataTableRow(class UDataTable* DataTable, class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "RemoveDataTableRow");

	Params::CoreGameFunctionLibrary_RemoveDataTableRow Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.RotateDirectionTowards
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          CurrentDirection                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RotationAxis                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DegreesPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutFinished                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCoreGameFunctionLibrary::RotateDirectionTowards(const struct FVector& CurrentDirection, const struct FVector& TargetDirection, const struct FVector& RotationAxis, float DegreesPerSecond, float DeltaTime, float Damping, bool* OutFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "RotateDirectionTowards");

	Params::CoreGameFunctionLibrary_RotateDirectionTowards Parms{};

	Parms.CurrentDirection = std::move(CurrentDirection);
	Parms.TargetDirection = std::move(TargetDirection);
	Parms.RotationAxis = std::move(RotationAxis);
	Parms.DegreesPerSecond = DegreesPerSecond;
	Parms.DeltaTime = DeltaTime;
	Parms.Damping = Damping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFinished != nullptr)
		*OutFinished = Parms.OutFinished;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SafeFloatDivide
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   N                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   D                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Fallback                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::SafeFloatDivide(float N, float D, float Fallback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SafeFloatDivide");

	Params::CoreGameFunctionLibrary_SafeFloatDivide Parms{};

	Parms.N = N;
	Parms.D = D;
	Parms.Fallback = Fallback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SetAutoDestroyAudioComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAudioComponent*                  AudioComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoDestroy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetAutoDestroyAudioComponent(class UAudioComponent* AudioComponent, bool bAutoDestroy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetAutoDestroyAudioComponent");

	Params::CoreGameFunctionLibrary_SetAutoDestroyAudioComponent Parms{};

	Parms.AudioComponent = AudioComponent;
	Parms.bAutoDestroy = bAutoDestroy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetCharacterUsesFastAttachedMove
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetCharacterUsesFastAttachedMove(class ACharacter* Character, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetCharacterUsesFastAttachedMove");

	Params::CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove Parms{};

	Parms.Character = Character;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetCustomPrimitiveDataArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetCustomPrimitiveDataArray(class UPrimitiveComponent* PrimitiveComponent, const TArray<float>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetCustomPrimitiveDataArray");

	Params::CoreGameFunctionLibrary_SetCustomPrimitiveDataArray Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetDataTableByteArrayProperty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::SetDataTableByteArrayProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, const TArray<uint8>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetDataTableByteArrayProperty");

	Params::CoreGameFunctionLibrary_SetDataTableByteArrayProperty Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;
	Parms.PropertyName = PropertyName;
	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SetDataTableIntegerArrayProperty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           Values                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::SetDataTableIntegerArrayProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, const TArray<int32>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetDataTableIntegerArrayProperty");

	Params::CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;
	Parms.PropertyName = PropertyName;
	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SetDataTableIntegerProperty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::SetDataTableIntegerProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetDataTableIntegerProperty");

	Params::CoreGameFunctionLibrary_SetDataTableIntegerProperty Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;
	Parms.PropertyName = PropertyName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SetDataTableObjectProperty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          DataObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::SetDataTableObjectProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, class UObject* DataObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetDataTableObjectProperty");

	Params::CoreGameFunctionLibrary_SetDataTableObjectProperty Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;
	Parms.PropertyName = PropertyName;
	Parms.DataObject = DataObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SetDataTableStructArrayProperty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PropertyName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObject*>                  StructArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::SetDataTableStructArrayProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, const TArray<class UObject*>& StructArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetDataTableStructArrayProperty");

	Params::CoreGameFunctionLibrary_SetDataTableStructArrayProperty Parms{};

	Parms.DataTable = DataTable;
	Parms.RowName = RowName;
	Parms.PropertyName = PropertyName;
	Parms.StructArray = std::move(StructArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SetDefaultCustomPrimitiveDataFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetDefaultCustomPrimitiveDataFloat(class UPrimitiveComponent* PrimitiveComponent, int32 DataIndex, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetDefaultCustomPrimitiveDataFloat");

	Params::CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.DataIndex = DataIndex;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetDefaultCustomPrimitiveDataVector4
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DataIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector4                         Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetDefaultCustomPrimitiveDataVector4(class UPrimitiveComponent* PrimitiveComponent, int32 DataIndex, const struct FVector4& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetDefaultCustomPrimitiveDataVector4");

	Params::CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4 Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.DataIndex = DataIndex;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetPrimitiveNotifyRigidBodyCollision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNotifyRigidBodyCollision                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetPrimitiveNotifyRigidBodyCollision(class UPrimitiveComponent* PrimitiveComponent, bool bNotifyRigidBodyCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetPrimitiveNotifyRigidBodyCollision");

	Params::CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.bNotifyRigidBodyCollision = bNotifyRigidBodyCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetPrimitiveStartsAwake
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartsAwake                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetPrimitiveStartsAwake(class UPrimitiveComponent* PrimitiveComponent, bool bStartsAwake)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetPrimitiveStartsAwake");

	Params::CoreGameFunctionLibrary_SetPrimitiveStartsAwake Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.bStartsAwake = bStartsAwake;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetRotationAtSplinePoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USplineComponent*                 SplineComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateSpline                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetRotationAtSplinePoint(class USplineComponent* SplineComponent, int32 PointIndex, const struct FRotator& Rotation, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetRotationAtSplinePoint");

	Params::CoreGameFunctionLibrary_SetRotationAtSplinePoint Parms{};

	Parms.SplineComponent = SplineComponent;
	Parms.PointIndex = PointIndex;
	Parms.Rotation = std::move(Rotation);
	Parms.CoordinateSpace = CoordinateSpace;
	Parms.bUpdateSpline = bUpdateSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetSkeletalMeshVertexColorsUniformSingleChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    SkeletalMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChannelIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ChannelValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::SetSkeletalMeshVertexColorsUniformSingleChannel(class USkeletalMesh* SkeletalMesh, int32 LODIndex, int32 ChannelIndex, uint8 ChannelValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetSkeletalMeshVertexColorsUniformSingleChannel");

	Params::CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.LODIndex = LODIndex;
	Parms.ChannelIndex = ChannelIndex;
	Parms.ChannelValue = ChannelValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SetSlateCursorRadius
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SetSlateCursorRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetSlateCursorRadius");

	Params::CoreGameFunctionLibrary_SetSlateCursorRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.SetStaticMeshVertexColors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, struct FLinearColor>        VertexIndexColorMap                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bConvertToSRGB                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::SetStaticMeshVertexColors(class UStaticMesh* StaticMesh, int32 LODIndex, const TMap<int32, struct FLinearColor>& VertexIndexColorMap, bool bConvertToSRGB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetStaticMeshVertexColors");

	Params::CoreGameFunctionLibrary_SetStaticMeshVertexColors Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.LODIndex = LODIndex;
	Parms.VertexIndexColorMap = std::move(VertexIndexColorMap);
	Parms.bConvertToSRGB = bConvertToSRGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SetStaticMeshVerticesToOverrideColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<int32>                             VertexIndices                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLinearColor                     FillColor                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     DefaultColor                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToSRGB                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoreGameFunctionLibrary::SetStaticMeshVerticesToOverrideColor(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, const TSet<int32>& VertexIndices, const struct FLinearColor& FillColor, const struct FLinearColor& DefaultColor, bool bConvertToSRGB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SetStaticMeshVerticesToOverrideColor");

	Params::CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor Parms{};

	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LODIndex = LODIndex;
	Parms.VertexIndices = std::move(VertexIndices);
	Parms.FillColor = std::move(FillColor);
	Parms.DefaultColor = std::move(DefaultColor);
	Parms.bConvertToSRGB = bConvertToSRGB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SignedAngleBetweenNormals
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::SignedAngleBetweenNormals(const struct FVector& SourceVector, const struct FVector& TargetVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SignedAngleBetweenNormals");

	Params::CoreGameFunctionLibrary_SignedAngleBetweenNormals Parms{};

	Parms.SourceVector = std::move(SourceVector);
	Parms.TargetVector = std::move(TargetVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SignedAngleBetweenOnPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          SourceVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetVector                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneNormal                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCoreGameFunctionLibrary::SignedAngleBetweenOnPlane(const struct FVector& SourceVector, const struct FVector& TargetVector, const struct FVector& PlaneNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SignedAngleBetweenOnPlane");

	Params::CoreGameFunctionLibrary_SignedAngleBetweenOnPlane Parms{};

	Parms.SourceVector = std::move(SourceVector);
	Parms.TargetVector = std::move(TargetVector);
	Parms.PlaneNormal = std::move(PlaneNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SortActorsByDistanceFromWorldLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UCoreGameFunctionLibrary::SortActorsByDistanceFromWorldLocation(const TArray<class AActor*>& Actors, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SortActorsByDistanceFromWorldLocation");

	Params::CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation Parms{};

	Parms.Actors = std::move(Actors);
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SortObjectsUsingPredicate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UObject*>                  Objects                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bStable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UObject* ObjectA, class UObject* ObjectB)>Predicate                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::SortObjectsUsingPredicate(TArray<class UObject*>& Objects, bool bStable, const TDelegate<void(class UObject* ObjectA, class UObject* ObjectB)>& Predicate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SortObjectsUsingPredicate");

	Params::CoreGameFunctionLibrary_SortObjectsUsingPredicate Parms{};

	Parms.Objects = std::move(Objects);
	Parms.bStable = bStable;
	Parms.Predicate = Predicate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Objects = std::move(Parms.Objects);
}


// Function CoreGame.CoreGameFunctionLibrary.SpawnActorInLevel
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ActorTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAdjustIfPossible                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCoreGameFunctionLibrary::SpawnActorInLevel(TSubclassOf<class AActor> ActorClass, const struct FTransform& ActorTransform, bool bAdjustIfPossible, class ULevel* Level, class APawn* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SpawnActorInLevel");

	Params::CoreGameFunctionLibrary_SpawnActorInLevel Parms{};

	Parms.ActorClass = ActorClass;
	Parms.ActorTransform = std::move(ActorTransform);
	Parms.bAdjustIfPossible = bAdjustIfPossible;
	Parms.Level = Level;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SpawnActorInLevelWithName
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ActorTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAdjustIfPossible                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCoreGameFunctionLibrary::SpawnActorInLevelWithName(TSubclassOf<class AActor> ActorClass, class FName ActorName, const struct FTransform& ActorTransform, bool bAdjustIfPossible, class ULevel* Level, class APawn* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SpawnActorInLevelWithName");

	Params::CoreGameFunctionLibrary_SpawnActorInLevelWithName Parms{};

	Parms.ActorClass = ActorClass;
	Parms.ActorName = ActorName;
	Parms.ActorTransform = std::move(ActorTransform);
	Parms.bAdjustIfPossible = bAdjustIfPossible;
	Parms.Level = Level;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.SpawnActorInWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ActorTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAdjustIfPossible                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCoreGameFunctionLibrary::SpawnActorInWorld(TSubclassOf<class AActor> ActorClass, const struct FTransform& ActorTransform, bool bAdjustIfPossible, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "SpawnActorInWorld");

	Params::CoreGameFunctionLibrary_SpawnActorInWorld Parms{};

	Parms.ActorClass = ActorClass;
	Parms.ActorTransform = std::move(ActorTransform);
	Parms.bAdjustIfPossible = bAdjustIfPossible;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.TimeSecondsToStringHMS
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   TotalSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCoreGameFunctionLibrary::TimeSecondsToStringHMS(int32 TotalSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "TimeSecondsToStringHMS");

	Params::CoreGameFunctionLibrary_TimeSecondsToStringHMS Parms{};

	Parms.TotalSeconds = TotalSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.TimeSecondsToStringMS
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   TotalSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCoreGameFunctionLibrary::TimeSecondsToStringMS(int32 TotalSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "TimeSecondsToStringMS");

	Params::CoreGameFunctionLibrary_TimeSecondsToStringMS Parms{};

	Parms.TotalSeconds = TotalSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.UnbindMontageOnBlendOutStarted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::UnbindMontageOnBlendOutStarted(class UAnimInstance* AnimInstance, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "UnbindMontageOnBlendOutStarted");

	Params::CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.UnbindMontageOnEnded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreGameFunctionLibrary::UnbindMontageOnEnded(class UAnimInstance* AnimInstance, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "UnbindMontageOnEnded");

	Params::CoreGameFunctionLibrary_UnbindMontageOnEnded Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.CoreGameFunctionLibrary.WrapIntLowerbound
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::WrapIntLowerbound(int32 Value, int32 Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "WrapIntLowerbound");

	Params::CoreGameFunctionLibrary_WrapIntLowerbound Parms{};

	Parms.Value = Value;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.WrapIntOnce
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::WrapIntOnce(int32 Value, int32 Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "WrapIntOnce");

	Params::CoreGameFunctionLibrary_WrapIntOnce Parms{};

	Parms.Value = Value;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.CoreGameFunctionLibrary.WrapIntUpperbound
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCoreGameFunctionLibrary::WrapIntUpperbound(int32 Value, int32 Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoreGameFunctionLibrary", "WrapIntUpperbound");

	Params::CoreGameFunctionLibrary_WrapIntUpperbound Parms{};

	Parms.Value = Value;
	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.Electrocardiogram.SetHeartRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BeatsPerMinute                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElectrocardiogram::SetHeartRate(float BeatsPerMinute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Electrocardiogram", "SetHeartRate");

	Params::Electrocardiogram_SetHeartRate Parms{};

	Parms.BeatsPerMinute = BeatsPerMinute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.Electrocardiogram.SetMovementArtifacts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElectrocardiogram::SetMovementArtifacts(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Electrocardiogram", "SetMovementArtifacts");

	Params::Electrocardiogram_SetMovementArtifacts Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.Electrocardiogram.SetPulseInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElectrocardiogram::SetPulseInterval(float Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Electrocardiogram", "SetPulseInterval");

	Params::Electrocardiogram_SetPulseInterval Parms{};

	Parms.Interval = Interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.Electrocardiogram.SetShouldUpdateAverageHeartRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUpdate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElectrocardiogram::SetShouldUpdateAverageHeartRate(bool bUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Electrocardiogram", "SetShouldUpdateAverageHeartRate");

	Params::Electrocardiogram_SetShouldUpdateAverageHeartRate Parms{};

	Parms.bUpdate = bUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.Electrocardiogram.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UElectrocardiogram::Update(float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Electrocardiogram", "Update");

	Params::Electrocardiogram_Update Parms{};

	Parms.ElapsedTime = ElapsedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.FileReader.LoadFile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FilePath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFileReader::LoadFile(const class FString& FilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FileReader", "LoadFile");

	Params::FileReader_LoadFile Parms{};

	Parms.FilePath = std::move(FilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.FileReader.ReadByteArray
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ByteCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> UFileReader::ReadByteArray(int32 ByteCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FileReader", "ReadByteArray");

	Params::FileReader_ReadByteArray Parms{};

	Parms.ByteCount = ByteCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.FileReader.ReadInteger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFileReader::ReadInteger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FileReader", "ReadInteger");

	Params::FileReader_ReadInteger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WorldObject.SetOuterObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          NewOuterObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldObject::SetOuterObject(class UObject* NewOuterObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldObject", "SetOuterObject");

	Params::WorldObject_SetOuterObject Parms{};

	Parms.NewOuterObject = NewOuterObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.WorldObject.SetOuterObjectToActorLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldObject::SetOuterObjectToActorLevel(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldObject", "SetOuterObjectToActorLevel");

	Params::WorldObject_SetOuterObjectToActorLevel Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.WorldObject.GetOuterObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UWorldObject::GetOuterObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldObject", "GetOuterObject");

	Params::WorldObject_GetOuterObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.AddWall
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FIntRectangle                    CellPair                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WallFlags                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGridLevelObject::AddWall(const struct FIntRectangle& CellPair, int32 WallFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "AddWall");

	Params::GridLevelObject_AddWall Parms{};

	Parms.CellPair = std::move(CellPair);
	Parms.WallFlags = WallFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.GridLevelObject.BreakWall
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FIntRectangle                    CellPair                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::BreakWall(const struct FIntRectangle& CellPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "BreakWall");

	Params::GridLevelObject_BreakWall Parms{};

	Parms.CellPair = std::move(CellPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.GenerateTraversableCellSets
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   TerrainTraverseFlags                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntPoint>                SourceCellLocations                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGridLevelObject::GenerateTraversableCellSets(int32 TerrainTraverseFlags, const TArray<struct FIntPoint>& SourceCellLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "GenerateTraversableCellSets");

	Params::GridLevelObject_GenerateTraversableCellSets Parms{};

	Parms.TerrainTraverseFlags = TerrainTraverseFlags;
	Parms.SourceCellLocations = std::move(SourceCellLocations);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.GridLevelObject.RemoveAllWalls
// (Final, Native, Public, BlueprintCallable)

void UGridLevelObject::RemoveAllWalls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "RemoveAllWalls");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.GridLevelObject.ResetWallBlockedStates
// (Final, Native, Public, BlueprintCallable)

void UGridLevelObject::ResetWallBlockedStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "ResetWallBlockedStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.GridLevelObject.SetCellTerrainTypes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<struct FIntPoint, uint8>           CellTerrainTypeMap                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGridLevelObject::SetCellTerrainTypes(const TMap<struct FIntPoint, uint8>& CellTerrainTypeMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "SetCellTerrainTypes");

	Params::GridLevelObject_SetCellTerrainTypes Parms{};

	Parms.CellTerrainTypeMap = std::move(CellTerrainTypeMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.GridLevelObject.SetTerrainTypeAtCellLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint                        CellLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TerrainType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::SetTerrainTypeAtCellLocation(const struct FIntPoint& CellLocation, uint8 TerrainType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "SetTerrainTypeAtCellLocation");

	Params::GridLevelObject_SetTerrainTypeAtCellLocation Parms{};

	Parms.CellLocation = std::move(CellLocation);
	Parms.TerrainType = TerrainType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.AddPathableCellsInCardinalDirections
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FIntPoint                        SourceCellLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TerrainTraverseFlags                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCellRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<struct FIntPoint>                  PathableCells                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGridLevelObject::AddPathableCellsInCardinalDirections(const struct FIntPoint& SourceCellLocation, int32 TerrainTraverseFlags, int32 MaxCellRange, TSet<struct FIntPoint>& PathableCells) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "AddPathableCellsInCardinalDirections");

	Params::GridLevelObject_AddPathableCellsInCardinalDirections Parms{};

	Parms.SourceCellLocation = std::move(SourceCellLocation);
	Parms.TerrainTraverseFlags = TerrainTraverseFlags;
	Parms.MaxCellRange = MaxCellRange;
	Parms.PathableCells = std::move(PathableCells);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PathableCells = std::move(Parms.PathableCells);
}


// Function CoreGame.GridLevelObject.AddPathableCellsInDirection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FIntPoint                        SourceCellLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        CellDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TerrainTraverseFlags                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCellRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<struct FIntPoint>                  PathableCells                                          (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGridLevelObject::AddPathableCellsInDirection(const struct FIntPoint& SourceCellLocation, const struct FIntPoint& CellDirection, int32 TerrainTraverseFlags, int32 MaxCellRange, TSet<struct FIntPoint>& PathableCells) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "AddPathableCellsInDirection");

	Params::GridLevelObject_AddPathableCellsInDirection Parms{};

	Parms.SourceCellLocation = std::move(SourceCellLocation);
	Parms.CellDirection = std::move(CellDirection);
	Parms.TerrainTraverseFlags = TerrainTraverseFlags;
	Parms.MaxCellRange = MaxCellRange;
	Parms.PathableCells = std::move(PathableCells);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PathableCells = std::move(Parms.PathableCells);

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.CanEnterCell
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        SourceCellLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        TargetCellLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::CanEnterCell(const struct FIntPoint& SourceCellLocation, const struct FIntPoint& TargetCellLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "CanEnterCell");

	Params::GridLevelObject_CanEnterCell Parms{};

	Parms.SourceCellLocation = std::move(SourceCellLocation);
	Parms.TargetCellLocation = std::move(TargetCellLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.CanEnterCellWithState
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        SourceCellLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        TargetCellLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanTraverseBreakableWalls                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TerrainTraverseFlags                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::CanEnterCellWithState(const struct FIntPoint& SourceCellLocation, const struct FIntPoint& TargetCellLocation, bool bCanTraverseBreakableWalls, int32 TerrainTraverseFlags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "CanEnterCellWithState");

	Params::GridLevelObject_CanEnterCellWithState Parms{};

	Parms.SourceCellLocation = std::move(SourceCellLocation);
	Parms.TargetCellLocation = std::move(TargetCellLocation);
	Parms.bCanTraverseBreakableWalls = bCanTraverseBreakableWalls;
	Parms.TerrainTraverseFlags = TerrainTraverseFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.CellTraceInDirection
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        SourceCellLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        CellDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TerrainTraverseFlags                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCellRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGridLevelObject::CellTraceInDirection(const struct FIntPoint& SourceCellLocation, const struct FIntPoint& CellDirection, int32 TerrainTraverseFlags, int32 MaxCellRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "CellTraceInDirection");

	Params::GridLevelObject_CellTraceInDirection Parms{};

	Parms.SourceCellLocation = std::move(SourceCellLocation);
	Parms.CellDirection = std::move(CellDirection);
	Parms.TerrainTraverseFlags = TerrainTraverseFlags;
	Parms.MaxCellRange = MaxCellRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.FindShortestPath
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector2D                        SourceLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TerrainTraverseFlags                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPathCost                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FIntPoint, float>           AddedCostMap                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FIntPoint>                OutPathLocations                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::FindShortestPath(const struct FVector2D& SourceLocation, const struct FVector2D& TargetLocation, int32 TerrainTraverseFlags, float MaxPathCost, const TMap<struct FIntPoint, float>& AddedCostMap, TArray<struct FIntPoint>* OutPathLocations) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "FindShortestPath");

	Params::GridLevelObject_FindShortestPath Parms{};

	Parms.SourceLocation = std::move(SourceLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.TerrainTraverseFlags = TerrainTraverseFlags;
	Parms.MaxPathCost = MaxPathCost;
	Parms.AddedCostMap = std::move(AddedCostMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPathLocations != nullptr)
		*OutPathLocations = std::move(Parms.OutPathLocations);

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.GetCellLocationFromLevelLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UGridLevelObject::GetCellLocationFromLevelLocation(const struct FVector2D& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "GetCellLocationFromLevelLocation");

	Params::GridLevelObject_GetCellLocationFromLevelLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.GetLevelLocationFromCellLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        CellLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UGridLevelObject::GetLevelLocationFromCellLocation(const struct FIntPoint& CellLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "GetLevelLocationFromCellLocation");

	Params::GridLevelObject_GetLevelLocationFromCellLocation Parms{};

	Parms.CellLocation = std::move(CellLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.GetPathableCellSet
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TSet<struct FIntPoint>                  ExcludeCells                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<struct FIntPoint>                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<struct FIntPoint> UGridLevelObject::GetPathableCellSet(const TSet<struct FIntPoint>& ExcludeCells) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "GetPathableCellSet");

	Params::GridLevelObject_GetPathableCellSet Parms{};

	Parms.ExcludeCells = std::move(ExcludeCells);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.GetTerrainTypeAtCellLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        CellLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UGridLevelObject::GetTerrainTypeAtCellLocation(const struct FIntPoint& CellLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "GetTerrainTypeAtCellLocation");

	Params::GridLevelObject_GetTerrainTypeAtCellLocation Parms{};

	Parms.CellLocation = std::move(CellLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.GetUnpathableCellSet
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// TSet<struct FIntPoint>                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<struct FIntPoint> UGridLevelObject::GetUnpathableCellSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "GetUnpathableCellSet");

	Params::GridLevelObject_GetUnpathableCellSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.IsCellLocationPathable
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        CellLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::IsCellLocationPathable(const struct FIntPoint& CellLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "IsCellLocationPathable");

	Params::GridLevelObject_IsCellLocationPathable Parms{};

	Parms.CellLocation = std::move(CellLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.IsCellLocationValid
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        CellLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::IsCellLocationValid(const struct FIntPoint& CellLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "IsCellLocationValid");

	Params::GridLevelObject_IsCellLocationValid Parms{};

	Parms.CellLocation = std::move(CellLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.IsTraversableTerrain
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        CellLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TerrainTraverseFlags                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::IsTraversableTerrain(const struct FIntPoint& CellLocation, int32 TerrainTraverseFlags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "IsTraversableTerrain");

	Params::GridLevelObject_IsTraversableTerrain Parms{};

	Parms.CellLocation = std::move(CellLocation);
	Parms.TerrainTraverseFlags = TerrainTraverseFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.IsWallBlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntRectangle                    CellPair                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::IsWallBlocked(const struct FIntRectangle& CellPair) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "IsWallBlocked");

	Params::GridLevelObject_IsWallBlocked Parms{};

	Parms.CellPair = std::move(CellPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.IsWallBreakable
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntRectangle                    CellPair                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::IsWallBreakable(const struct FIntRectangle& CellPair) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "IsWallBreakable");

	Params::GridLevelObject_IsWallBreakable Parms{};

	Parms.CellPair = std::move(CellPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.GridLevelObject.LineTraceGridWalls
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector2D                        SourceLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntRectangle>            IgnoreCellPairs                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGridTraceHitResult              OutHitResult                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGridLevelObject::LineTraceGridWalls(const struct FVector2D& SourceLocation, const struct FVector2D& TargetLocation, float TraceRadius, const TArray<struct FIntRectangle>& IgnoreCellPairs, struct FGridTraceHitResult* OutHitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GridLevelObject", "LineTraceGridWalls");

	Params::GridLevelObject_LineTraceGridWalls Parms{};

	Parms.SourceLocation = std::move(SourceLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.TraceRadius = TraceRadius;
	Parms.IgnoreCellPairs = std::move(IgnoreCellPairs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResult != nullptr)
		*OutHitResult = std::move(Parms.OutHitResult);

	return Parms.ReturnValue;
}


// Function CoreGame.Shuffler.GetNextIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UShuffler::GetNextIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Shuffler", "GetNextIndex");

	Params::Shuffler_GetNextIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.Shuffler.Reset
// (Final, Native, Public, BlueprintCallable)

void UShuffler::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Shuffler", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.Shuffler.SetCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   CountToSet                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShuffler::SetCount(int32 CountToSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Shuffler", "SetCount");

	Params::Shuffler_SetCount Parms{};

	Parms.CountToSet = CountToSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.SymmetricRandomWalk.GetCurrentValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SampleIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USymmetricRandomWalk::GetCurrentValue(int32 SampleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymmetricRandomWalk", "GetCurrentValue");

	Params::SymmetricRandomWalk_GetCurrentValue Parms{};

	Parms.SampleIndex = SampleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.SymmetricRandomWalk.GetCurrentValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> USymmetricRandomWalk::GetCurrentValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymmetricRandomWalk", "GetCurrentValues");

	Params::SymmetricRandomWalk_GetCurrentValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.SymmetricRandomWalk.Restart
// (Final, Native, Public, BlueprintCallable)

void USymmetricRandomWalk::Restart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymmetricRandomWalk", "Restart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.SymmetricRandomWalk.SetWalkParameters
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<float>                           InitValues                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinStep                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxStep                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinVal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxVal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLerp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USymmetricRandomWalk::SetWalkParameters(const TArray<float>& InitValues, float Interval, float MinStep, float MaxStep, float MinVal, float MaxVal, bool bLerp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymmetricRandomWalk", "SetWalkParameters");

	Params::SymmetricRandomWalk_SetWalkParameters Parms{};

	Parms.InitValues = std::move(InitValues);
	Parms.Interval = Interval;
	Parms.MinStep = MinStep;
	Parms.MaxStep = MaxStep;
	Parms.MinVal = MinVal;
	Parms.MaxVal = MaxVal;
	Parms.bLerp = bLerp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.WeightedAverageBase.SetSmoothingFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Smoothing_0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeightedAverageBase::SetSmoothingFactor(float Smoothing_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageBase", "SetSmoothingFactor");

	Params::WeightedAverageBase_SetSmoothingFactor Parms{};

	Parms.Smoothing_0 = Smoothing_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.WeightedAverageFloat.ClearHistory
// (Final, Native, Public, BlueprintCallable)

void UWeightedAverageFloat::ClearHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageFloat", "ClearHistory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.WeightedAverageFloat.GetSmoothedFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Sample                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeightedAverageFloat::GetSmoothedFloat(float Sample, float CurrentTime, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageFloat", "GetSmoothedFloat");

	Params::WeightedAverageFloat_GetSmoothedFloat Parms{};

	Parms.Sample = Sample;
	Parms.CurrentTime = CurrentTime;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WeightedAverageFloat.GetElapsedTimeSinceLastSample
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   CurrentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeightedAverageFloat::GetElapsedTimeSinceLastSample(float CurrentTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageFloat", "GetElapsedTimeSinceLastSample");

	Params::WeightedAverageFloat_GetElapsedTimeSinceLastSample Parms{};

	Parms.CurrentTime = CurrentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WeightedAverageFloat.GetTotalElapsedSampleTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeightedAverageFloat::GetTotalElapsedSampleTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageFloat", "GetTotalElapsedSampleTime");

	Params::WeightedAverageFloat_GetTotalElapsedSampleTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WeightedAverageVec2.ClearHistory
// (Final, Native, Public, BlueprintCallable)

void UWeightedAverageVec2::ClearHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageVec2", "ClearHistory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.WeightedAverageVec2.GetSmoothedVec2
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Sample                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UWeightedAverageVec2::GetSmoothedVec2(const struct FVector2D& Sample, float CurrentTime, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageVec2", "GetSmoothedVec2");

	Params::WeightedAverageVec2_GetSmoothedVec2 Parms{};

	Parms.Sample = std::move(Sample);
	Parms.CurrentTime = CurrentTime;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WeightedAverageVec2.GetElapsedTimeSinceLastSample
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   CurrentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeightedAverageVec2::GetElapsedTimeSinceLastSample(float CurrentTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageVec2", "GetElapsedTimeSinceLastSample");

	Params::WeightedAverageVec2_GetElapsedTimeSinceLastSample Parms{};

	Parms.CurrentTime = CurrentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WeightedAverageVec2.GetTotalElapsedSampleTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeightedAverageVec2::GetTotalElapsedSampleTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageVec2", "GetTotalElapsedSampleTime");

	Params::WeightedAverageVec2_GetTotalElapsedSampleTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WeightedAverageVec3.ClearHistory
// (Final, Native, Public, BlueprintCallable)

void UWeightedAverageVec3::ClearHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageVec3", "ClearHistory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CoreGame.WeightedAverageVec3.GetSmoothedVec3
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Sample                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UWeightedAverageVec3::GetSmoothedVec3(const struct FVector& Sample, float CurrentTime, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageVec3", "GetSmoothedVec3");

	Params::WeightedAverageVec3_GetSmoothedVec3 Parms{};

	Parms.Sample = std::move(Sample);
	Parms.CurrentTime = CurrentTime;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WeightedAverageVec3.GetElapsedTimeSinceLastSample
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   CurrentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeightedAverageVec3::GetElapsedTimeSinceLastSample(float CurrentTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageVec3", "GetElapsedTimeSinceLastSample");

	Params::WeightedAverageVec3_GetElapsedTimeSinceLastSample Parms{};

	Parms.CurrentTime = CurrentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CoreGame.WeightedAverageVec3.GetTotalElapsedSampleTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWeightedAverageVec3::GetTotalElapsedSampleTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeightedAverageVec3", "GetTotalElapsedSampleTime");

	Params::WeightedAverageVec3_GetTotalElapsedSampleTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

