#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreGame

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreGame_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class CoreGame.CoreGameFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UCoreGameFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddDataTableRow(class UDataTable* DataTable, class FName RowName);
	static class UStaticMeshComponent* AddStaticMeshComponent(class USceneComponent* AttachToComponent, class UStaticMesh* StaticMesh, class FName SocketName, const struct FTransform& RelativeTransform);
	static class UStaticMeshComponent* AddStaticMeshComponentInEditor(class AActor* Owner, class UStaticMesh* StaticMesh, const struct FTransform& RelativeTransform);
	static float AngleBetweenNormals(const struct FVector& SourceVector, const struct FVector& TargetVector);
	static float AngleBetweenVectors(const struct FVector& SourceVector, const struct FVector& TargetVector);
	static void ApplySkeletalMeshBodyTransforms(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<struct FTransform>& BodyTransforms);
	static bool AttachAndModifyComponentOwnership(class USceneComponent* TransferComponent, class USceneComponent* AttachToComponent);
	static void AttachDistanceFieldMeshesToSkeletalMeshComponent(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<class UStaticMesh*>& StaticMeshes, bool bVisible, class FName CollisionProfileName, const class FString& PrefixKey, const class FString& Delimiter, const struct FRotator& RelativeRotation);
	static void BatchSetCustomPrimitiveData(const TArray<class UPrimitiveComponent*>& PrimitiveComponents, int32 DataIndex, const TArray<float>& Values);
	static void BindMontageOnBlendOutStarted(class UAnimInstance* AnimInstance, class UAnimMontage* Montage, const TDelegate<void(class UAnimMontage* Montage, bool bInterrupted)>& Event);
	static void BindMontageOnEnded(class UAnimInstance* AnimInstance, class UAnimMontage* Montage, const TDelegate<void(class UAnimMontage* Montage, bool bInterrupted)>& Event);
	static int32 BitShiftLeft(int32 Value, int32 ShiftBy);
	static int32 BitShiftRight(int32 Value, int32 ShiftBy);
	static bool BoneIsChildOf(class USkeletalMesh* SkeletalMesh, class FName BoneName, class FName ParentBoneName);
	static void BreakEnumHandleToNames(const struct FEnumHandle& EnumHandle, class FName* EnumHandleName, class FName* EnumeratorName);
	static void BreakEnumHandleToStrings(const struct FEnumHandle& EnumHandle, class FString* EnumHandleString, class FString* EnumeratorString);
	static bool CallEventByHandle(const struct FLatentEventHandle& EventHandle);
	static bool CallObjectEventByHandle(const struct FLatentObjectEventHandle& EventHandle, class UObject* Object);
	static bool CapsuleOverlapComponents(const class UObject* WorldContextObject, const struct FVector& CapsuleLocation, const struct FVector& CapsuleAxis, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, TSubclassOf<class UActorComponent> ClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static struct FVector2D ClampAxes2D(const struct FVector2D& Vector, const struct FVector2D& MinAxisValues, const struct FVector2D& MaxAxisValues);
	static struct FVector2D ClampPointToLozenge2D(const struct FVector2D& Point, const struct FVector2D& LozengeCenter, const struct FVector2D& LozengeHalfExtents, float LozengeRadius);
	static bool ClearStaticMeshOverrideColorsForVertices(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, const TSet<int32>& VertexIndices);
	static struct FVector ClosestPointOnBox(const struct FBox& Box, const struct FVector& Point);
	static void ClosestPointsOnSegments(const struct FVector& SegmentAStart, const struct FVector& SegmentAEnd, const struct FVector& SegmentBStart, const struct FVector& SegmentBEnd, struct FVector* ClosestOnA, struct FVector* ClosestOnB);
	static bool ComponentOverlapActors(class UPrimitiveComponent* Component, TSubclassOf<class AActor> ClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>* OutActors);
	static bool ComponentOverlapComponents(class UPrimitiveComponent* Component, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents);
	static float ComputeHorizontalFOV(float VerticalFOV, const struct FVector2D& ViewportSize);
	static float ComputeVerticalFOV(float HorizontalFOV, const struct FVector2D& ViewportSize);
	static bool ConditionalDestroyObject(class UObject* Object);
	static void CopyCustomPrimitiveData(class UPrimitiveComponent* SourcePrimitiveComponent, class UPrimitiveComponent* TargetPrimitiveComponent, bool bSetDefaults);
	static int32 CountBits(int32 Bits);
	static class UAudioComponent* CreateAudioComponentAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bAutoDestroy);
	static class USkeletalMesh* CreateCompositeSkeletalMesh(const class FString& PackagePath, const class FString& MeshName, const TArray<class USkeletalMesh*>& SkeletalMeshes);
	static struct FLatentEventHandle CreateEventHandle(const TDelegate<void()>& Event);
	static struct FIntRectangle CreateIntRectangle(const struct FIntPoint& DesiredMin, const struct FIntPoint& DesiredMax);
	static struct FLatentObjectEventHandle CreateObjectEventHandle(const TDelegate<void(class UObject* Object)>& Event);
	static class UTexture2D* CreateResizedTextureFromRenderTarget(class UTextureRenderTarget2D* RenderTarget, int32 DesiredWidth, int32 DesiredHeight);
	static class USceneCaptureComponent2D* CreateSceneCaptureWorld(const class UObject* WorldContextObject, class FName WorldName, bool bWantsTick, class UTextureRenderTarget2D* RenderTarget);
	static TArray<class UStaticMesh*> CreateStaticMeshesFromPhysicsAssetHulls(class UPhysicsAsset* PhysicsAsset, class UMaterialInterface* Material, bool bMergeMirroredMeshes, const TArray<class FName>& ExcludeBones, const class FString& Prefix, const class FString& SubDirectory);
	static class UTexture2D* CreateTextureFromRenderTarget(class UTextureRenderTarget2D* RenderTarget);
	static bool DestroySceneCaptureWorld(class USceneCaptureComponent2D* SceneCaptureComponent);
	static bool DisableBodyCollision(class USkeletalMeshComponent* SkeletalMeshComponent, class FName BoneName, bool bRecreatePhysics);
	static class UObject* DuplicateObject(class UObject* WorldContextObject, class UObject* SourceObject);
	static void FillCylinderMeshBuffersFromSplineComponent(class USplineComponent* SplineComponent, float Radius, float SegmentLength, const struct FVector2D& TextureArea, int32 RingVertexCount, bool bTrimFromStart, TArray<struct FVector>& Vertices, TArray<int32>& Triangles, TArray<struct FVector>& Normals, TArray<struct FVector2D>& TexCoords);
	static void FindBestAxisVectors(const struct FVector& Vector, struct FVector* OutAxis1, struct FVector* OutAxis2);
	static void ForceRecreatePhysicsState(class USkeletalMeshComponent* SkeletalMeshComponent);
	static void ForceRedrawAllViewports();
	static void ForceUpdateBounds(class USkeletalMeshComponent* SkeletalMeshComponent);
	static class AActor* GetActorByNameInSubLevel(class ULevel* SubLevel, class FName ActorName);
	static class UActorComponent* GetActorComponentByName(class AActor* Actor, class FName ComponentName);
	static class ULevel* GetActorLevel(class AActor* Actor);
	static class AActor* GetActorOfClassInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> ClassFilter);
	static class AActor* GetActorOfClassInSubLevelByName(const class UObject* WorldContextObject, class FName SubLevelName, TSubclassOf<class AActor> ClassFilter);
	static class AActor* GetActorOfClassWithTagInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> ClassFilter, class FName ActorTag);
	static TArray<class AActor*> GetAllActorsOfClassInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> ClassFilter);
	static TArray<class AActor*> GetAllActorsOfClassInSubLevelByName(const class UObject* WorldContextObject, class FName SubLevelName, TSubclassOf<class AActor> ClassFilter);
	static float GetAngleAroundAxis(const struct FVector& SourceVector, const struct FVector& TargetVector, const struct FVector& Axis);
	static TArray<class UClass*> GetBlueprintClasses(class UClass* BaseClass, const class FString& Name_0, const class FString& Folder);
	static TArray<class FName> GetBodyBoneNamesFromPhysicsAsset(class UPhysicsAsset* PhysicsAsset);
	static struct FVector GetBoxContainmentOffset(const struct FVector& ContentOffset, const struct FVector& ContentHalfExtent, const struct FVector& ContainerHalfExtent);
	static void GetBytesFromInt(int32 Value, uint8* OutByteA, uint8* OutByteB, uint8* OutByteC, uint8* OutByteD);
	static class UActorComponent* GetChildComponentByClassAndSuffix(class USceneComponent* SceneComponent, TSubclassOf<class UActorComponent> ClassFilter, const class FString& Suffix);
	static class UActorComponent* GetChildComponentByTag(class USceneComponent* SceneComponent, TSubclassOf<class UActorComponent> ClassFilter, class FName Tag);
	static TArray<class UActorComponent*> GetChildComponentsByClass(class USceneComponent* SceneComponent, TSubclassOf<class UActorComponent> ClassFilter, bool bIncludeDescendants);
	static TArray<class UActorComponent*> GetChildComponentsByClassFromArray(const TArray<class USceneComponent*>& SceneComponents, TSubclassOf<class UActorComponent> ClassFilter, bool bIncludeDescendants);
	static class UActorComponent* GetClassComponentTemplate(TSubclassOf<class AActor> ActorClass, TSubclassOf<class UActorComponent> ComponentClass);
	static class UActorComponent* GetClassComponentTemplateByName(TSubclassOf<class AActor> ActorClass, const class FString& ComponentName);
	static class UObject* GetClassDefaultObject(class UClass* Class_0);
	static float GetCurveValueSumOverTimeInterval(const class UCurveFloat* CurveFloat, int32 SampleCount, float SampleInterval);
	static float GetCustomPrimitiveDataFloat(class UPrimitiveComponent* PrimitiveComponent, int32 DataIndex);
	static struct FVector4 GetCustomPrimitiveDataVector4(class UPrimitiveComponent* PrimitiveComponent, int32 DataIndex);
	static int32 GetDataTableRowCount(class UDataTable* DataTable);
	static float GetDistanceAlongPathAtElapsedTime(float TotalPathLength, float MaxSpeed, float AccelerationTime, float ElapsedTime);
	static float GetDistanceBetweenShapeAndSegment(class UShapeComponent* ShapeComponent, const struct FVector& SegmentStart, const struct FVector& SegmentEnd);
	static class FText GetEnumeratorTextFromHandle(const struct FEnumHandle& EnumHandle);
	static int64 GetEnumValueByName(class UEnum* Enum, class FName Name_0);
	static struct FBox GetExactStaticMeshBoundsWithTransform(class UStaticMesh* StaticMesh, const struct FTransform& Transform);
	static struct FBox GetExactStaticMeshCollisionBoundsForComponent(class UStaticMeshComponent* StaticMeshComponent, bool bIncludeChildren);
	static struct FBox GetExactStaticMeshCollisionBoundsWithTransform(class UStaticMesh* StaticMesh, const struct FTransform& Transform);
	static TArray<class AActor*> GetFilteredActorsInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> RequireActorClass, TSubclassOf<class AActor> IgnoreActorClass, TSubclassOf<class UActorComponent> RequireComponentClass, bool bImmobile, bool bMobile);
	static TArray<class UActorComponent*> GetFilteredComponentsInSubLevel(class ULevel* SubLevel, TSubclassOf<class AActor> RequireActorClass, TSubclassOf<class AActor> IgnoreActorClass, TSubclassOf<class UActorComponent> RequireComponentClass, bool bImmobile, bool bMobile);
	static class FName GetFirstParentBoneLocationInCapsule(class USkeletalMeshComponent* SkeletalMeshComponent, class UCapsuleComponent* CapsuleComponent, class FName SocketName, struct FVector* OutBoneLocation, TArray<class FName>* OutExteriorBoneNames);
	static float GetLagrangeInterp(const TArray<struct FVector2D>& Points, float X);
	static float GetLastRenderTime(class UPrimitiveComponent* PrimitiveComponent, float* CurrentTime);
	static struct FVector GetLocationAlongPathAtElapsedTime(const struct FVector& SourceLocation, const struct FVector& TargetLocation, float MaxSpeed, float AccelerationTime, float ElapsedTime);
	static float GetMontageRateScale(class UAnimMontage* Montage);
	static float GetPitchRotationTowards(const struct FVector& SourceDirection, const struct FVector& SourceRightDirection, const struct FVector& TargetVector);
	static struct FVector GetPlaneNormal(const struct FPlane& Plane);
	static struct FVector GetPlaneOrigin(const struct FPlane& Plane);
	static bool GetProjectedShapeBoundsInWidget(class APlayerController* PlayerController, class UShapeComponent* ShapeComponent, bool bBoxAsLozenge, struct FBox2D* OutScreenBounds);
	static bool GetProjectedSphereBoundsInWidget(class APlayerController* PlayerController, const struct FVector& Center, float Radius, struct FBox2D* OutScreenBounds);
	static float GetRotationTowards(const struct FVector& SourceVector, const struct FVector& SourceUpVector, const struct FVector& TargetVector, struct FVector* OutRotationAxis);
	static float GetRotationTowardsXY(const struct FVector& SourceVector, const struct FVector& TargetVector);
	static TArray<int32> GetSetBitIndices(int32 Bits);
	static TArray<class UPrimitiveComponent*> GetSimulatingPhysicsComponents(class AActor* Actor);
	static TArray<struct FTransform> GetSkeletalMeshBodyTransforms(class USkeletalMeshComponent* SkeletalMeshComponent);
	static struct FBox GetSmoothApproxBoundsWithTransform(const struct FBox& LocalBounds, const struct FTransform& Transform);
	static bool GetSmoothMovementParameters(float TotalPathLength, float MaxSpeed, float AccelerationTime, float* OutAcceleration, float* OutConstantSpeedDuration, float* OutConstantSpeedDistance, float* OutActualAccelerationTime, float* OutActualAccelerationDistance);
	static TArray<class UActorComponent*> GetSortedChildComponentsByClassAndPrefix(class USceneComponent* SceneComponent, TSubclassOf<class UActorComponent> ClassFilter, const class FString& Prefix);
	static TArray<class UActorComponent*> GetSortedComponentsByClassAndPrefix(class AActor* Actor, TSubclassOf<class UActorComponent> ClassFilter, const class FString& Prefix);
	static TSet<int32> GetStaticMeshVertexIndicesOfTrianglesInBox(class UStaticMesh* StaticMesh, int32 LODIndex, const struct FBox& LocalBox);
	static class ULevel* GetSubLevelByName(const class UObject* WorldContextObject, class FName SubLevelName);
	static class UClass* GetSuperClass(class UClass* Class_0);
	static class FString GetUClassName(class UClass* InClass);
	static struct FVector GetVectorNormalAndLength(const struct FVector& Vector, float* OutLength);
	static struct FIntVector GetVoxelCoordsFromVoxelIndex(int32 VoxelIndex, const struct FIntPoint& LevelSize2D);
	static int32 GetVoxelIndexFromVoxelCoords(const struct FIntVector& VoxelCoords, const struct FIntPoint& LevelSize2D);
	static TMap<class FName, float> GetWeightedDistancesBetweenPointAndBodyInstances(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FVector& WorldLocation, float MaxDistance, bool bScaleByMass, const TMap<class FName, class FName>& BoneRemapping);
	static int32 GetWeightedRandomIndexFromFloatArray(const TArray<float>& Weights);
	static int32 GetWeightedRandomIndexFromStructArray(const TArray<class UObject*>& WeightedStructs, int32 ExcludeIndex);
	static int32 GetWeightedRandomIndexFromStructArrayWithStream(const TArray<class UObject*>& WeightedStructs, const struct FRandomStream& RandomStream, int32 ExcludeIndex);
	static int32 HashCombineInt32(int32 ValueA, int32 ValueB);
	static int32 HashInt64(int64 Value);
	static int32 HashString(const class FString& String);
	static bool HasLoadedAllTextureMipsForForMaterial(class UMaterialInterface* Material);
	static bool HasLoadedAllTextureMipsForStaticMeshComponent(class UStaticMeshComponent* StaticMeshComponent, bool bIncludeChildMeshComponents);
	static void HideActorFromPlayer(class AActor* Actor, class APlayerController* PlayerController);
	static bool IntersectBoxClipHull(const struct FBox& Box, const TArray<struct FPlane>& HullClipPlanes);
	static bool IntersectBoxes(const struct FBox& BoxA, const struct FBox& BoxB);
	static bool IntersectBoxes2D(const struct FBox2D& BoxA, const struct FBox2D& BoxB);
	static bool IntersectRayBox(const struct FVector& RayLocation, const struct FVector& RayDirection, const struct FBox& Box, struct FVector2D* OutTMinMax);
	static bool IntersectRaySphere(const struct FVector& RayLocation, const struct FVector& RayDirection, const struct FVector& SphereCenter, float SphereRadius, struct FVector2D* OutTMinMax);
	static bool IntersectSegmentBox(const struct FVector& SourceLocation, const struct FVector& TargetLocation, const struct FBox& Box, struct FVector* OutIntersectPoint);
	static bool IntersectSegments2D(const struct FVector2D& A, const struct FVector2D& B, const struct FVector2D& C, const struct FVector2D& D, float* OutTime);
	static bool IntersectSweptSphereCapsule(const struct FVector& SphereSource, const struct FVector& SphereTarget, float SphereRadius, const struct FVector& CapsuleCenter, const struct FVector& CapsuleAxis, float CapsuleHalfLength, float CapsuleRadius, struct FVector* OutHitPoint);
	static bool IsBoxValid(const struct FBox& Box);
	static bool IsCompatibleMontageForAnimInstance(class UAnimMontage* Montage, class UAnimInstance* AnimInstance);
	static bool IsGame(class UObject* WorldContextObject);
	static bool IsMontageUsingSlotName(class UAnimMontage* Montage, class FName SlotName);
	static bool IsOrthogonalRotation(const struct FRotator& Rotation);
	static bool IsPointInBox2D(const struct FVector2D& Point, const struct FBox2D& Box);
	static bool IsPointInCapsule(class UCapsuleComponent* CapsuleComponent, const struct FVector& WorldLocation);
	static bool IsSimulatingInEditor();
	static bool IsViewportInForeground(class APlayerController* PlayerController);
	static struct FBox MakeBoxFromPoints(const TArray<struct FVector>& Points);
	static int32 MakeIntFromByteArray(const TArray<uint8>& Bytes);
	static int32 MakeIntFromBytes(uint8 OutByteA, uint8 OutByteB, uint8 OutByteC, uint8 OutByteD);
	static void MoveActorsToLevel(const TArray<class AActor*>& Actors, class ULevel* Level);
	static bool MoveActorToLevel(class AActor* Actor, class ULevel* Level);
	static bool ObjectClassCollection_Identical(const struct FObjectClassCollection& CollectionA, const struct FObjectClassCollection& CollectionB);
	static bool OutwardSpiralLoop(int32 GridSize, const TDelegate<void(const struct FIntPoint& OffsetPoint, bool* bExitLoop)>& Event);
	static float PointBox2DSeparation(const struct FVector2D& Point, const struct FBox2D& Box);
	static void PoseSkeletalMeshPhysics(class USkeletalMeshComponent* FromSkeletalMeshComponent, class USkeletalMeshComponent* ToSkeletalMeshComponent);
	static int32 RandomIntegerInRangeExclusiveFromStream(int32 Min, int32 Max, int32 ExcludeValue, const struct FRandomStream& Stream);
	static int32 RandomizeBits(int32 RandMinBitCount, int32 RandMaxBitCount, int32 TotalBitCount, int32 RequiredBitPosition);
	static bool RemoveDataTableRow(class UDataTable* DataTable, class FName RowName);
	static struct FVector RotateDirectionTowards(const struct FVector& CurrentDirection, const struct FVector& TargetDirection, const struct FVector& RotationAxis, float DegreesPerSecond, float DeltaTime, float Damping, bool* OutFinished);
	static float SafeFloatDivide(float N, float D, float Fallback);
	static void SetAutoDestroyAudioComponent(class UAudioComponent* AudioComponent, bool bAutoDestroy);
	static void SetCharacterUsesFastAttachedMove(class ACharacter* Character, bool bEnable);
	static void SetCustomPrimitiveDataArray(class UPrimitiveComponent* PrimitiveComponent, const TArray<float>& Values);
	static bool SetDataTableByteArrayProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, const TArray<uint8>& Values);
	static bool SetDataTableIntegerArrayProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, const TArray<int32>& Values);
	static bool SetDataTableIntegerProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, int32 Value);
	static bool SetDataTableObjectProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, class UObject* DataObject);
	static bool SetDataTableStructArrayProperty(class UDataTable* DataTable, class FName RowName, class FName PropertyName, const TArray<class UObject*>& StructArray);
	static void SetDefaultCustomPrimitiveDataFloat(class UPrimitiveComponent* PrimitiveComponent, int32 DataIndex, float Value);
	static void SetDefaultCustomPrimitiveDataVector4(class UPrimitiveComponent* PrimitiveComponent, int32 DataIndex, const struct FVector4& Value);
	static void SetPrimitiveNotifyRigidBodyCollision(class UPrimitiveComponent* PrimitiveComponent, bool bNotifyRigidBodyCollision);
	static void SetPrimitiveStartsAwake(class UPrimitiveComponent* PrimitiveComponent, bool bStartsAwake);
	static void SetRotationAtSplinePoint(class USplineComponent* SplineComponent, int32 PointIndex, const struct FRotator& Rotation, ESplineCoordinateSpace CoordinateSpace, bool bUpdateSpline);
	static bool SetSkeletalMeshVertexColorsUniformSingleChannel(class USkeletalMesh* SkeletalMesh, int32 LODIndex, int32 ChannelIndex, uint8 ChannelValue);
	static void SetSlateCursorRadius(float Radius);
	static bool SetStaticMeshVertexColors(class UStaticMesh* StaticMesh, int32 LODIndex, const TMap<int32, struct FLinearColor>& VertexIndexColorMap, bool bConvertToSRGB);
	static bool SetStaticMeshVerticesToOverrideColor(class UStaticMeshComponent* StaticMeshComponent, int32 LODIndex, const TSet<int32>& VertexIndices, const struct FLinearColor& FillColor, const struct FLinearColor& DefaultColor, bool bConvertToSRGB);
	static float SignedAngleBetweenNormals(const struct FVector& SourceVector, const struct FVector& TargetVector);
	static float SignedAngleBetweenOnPlane(const struct FVector& SourceVector, const struct FVector& TargetVector, const struct FVector& PlaneNormal);
	static TArray<class AActor*> SortActorsByDistanceFromWorldLocation(const TArray<class AActor*>& Actors, const struct FVector& WorldLocation);
	static void SortObjectsUsingPredicate(TArray<class UObject*>& Objects, bool bStable, const TDelegate<void(class UObject* ObjectA, class UObject* ObjectB)>& Predicate);
	static class AActor* SpawnActorInLevel(TSubclassOf<class AActor> ActorClass, const struct FTransform& ActorTransform, bool bAdjustIfPossible, class ULevel* Level, class APawn* Instigator);
	static class AActor* SpawnActorInLevelWithName(TSubclassOf<class AActor> ActorClass, class FName ActorName, const struct FTransform& ActorTransform, bool bAdjustIfPossible, class ULevel* Level, class APawn* Instigator);
	static class AActor* SpawnActorInWorld(TSubclassOf<class AActor> ActorClass, const struct FTransform& ActorTransform, bool bAdjustIfPossible, class UObject* WorldContextObject);
	static class FString TimeSecondsToStringHMS(int32 TotalSeconds);
	static class FString TimeSecondsToStringMS(int32 TotalSeconds);
	static void UnbindMontageOnBlendOutStarted(class UAnimInstance* AnimInstance, class UAnimMontage* Montage);
	static void UnbindMontageOnEnded(class UAnimInstance* AnimInstance, class UAnimMontage* Montage);
	static int32 WrapIntLowerbound(int32 Value, int32 Size);
	static int32 WrapIntOnce(int32 Value, int32 Size);
	static int32 WrapIntUpperbound(int32 Value, int32 Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreGameFunctionLibrary">();
	}
	static class UCoreGameFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreGameFunctionLibrary>();
	}
};
static_assert(alignof(UCoreGameFunctionLibrary) == 0x000008, "Wrong alignment on UCoreGameFunctionLibrary");
static_assert(sizeof(UCoreGameFunctionLibrary) == 0x000028, "Wrong size on UCoreGameFunctionLibrary");

// Class CoreGame.Electrocardiogram
// 0x0068 (0x0090 - 0x0028)
class UElectrocardiogram final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnHeartBeat;                                       // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         HeartRate;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PulseInterval;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InvertUWave;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementArtifacts;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VoltageSum;                                        // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AverageHeartRate;                                  // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStateSystole;                                     // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldUpdateAverageHeartRate;                     // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x3E];                                      // 0x0052(0x003E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHeartRate(float BeatsPerMinute);
	void SetMovementArtifacts(float Amount);
	void SetPulseInterval(float Interval);
	void SetShouldUpdateAverageHeartRate(bool bUpdate);
	void Update(float ElapsedTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Electrocardiogram">();
	}
	static class UElectrocardiogram* GetDefaultObj()
	{
		return GetDefaultObjImpl<UElectrocardiogram>();
	}
};
static_assert(alignof(UElectrocardiogram) == 0x000008, "Wrong alignment on UElectrocardiogram");
static_assert(sizeof(UElectrocardiogram) == 0x000090, "Wrong size on UElectrocardiogram");
static_assert(offsetof(UElectrocardiogram, OnHeartBeat) == 0x000028, "Member 'UElectrocardiogram::OnHeartBeat' has a wrong offset!");
static_assert(offsetof(UElectrocardiogram, HeartRate) == 0x000038, "Member 'UElectrocardiogram::HeartRate' has a wrong offset!");
static_assert(offsetof(UElectrocardiogram, PulseInterval) == 0x00003C, "Member 'UElectrocardiogram::PulseInterval' has a wrong offset!");
static_assert(offsetof(UElectrocardiogram, InvertUWave) == 0x000040, "Member 'UElectrocardiogram::InvertUWave' has a wrong offset!");
static_assert(offsetof(UElectrocardiogram, MovementArtifacts) == 0x000044, "Member 'UElectrocardiogram::MovementArtifacts' has a wrong offset!");
static_assert(offsetof(UElectrocardiogram, VoltageSum) == 0x000048, "Member 'UElectrocardiogram::VoltageSum' has a wrong offset!");
static_assert(offsetof(UElectrocardiogram, AverageHeartRate) == 0x00004C, "Member 'UElectrocardiogram::AverageHeartRate' has a wrong offset!");
static_assert(offsetof(UElectrocardiogram, bStateSystole) == 0x000050, "Member 'UElectrocardiogram::bStateSystole' has a wrong offset!");
static_assert(offsetof(UElectrocardiogram, bShouldUpdateAverageHeartRate) == 0x000051, "Member 'UElectrocardiogram::bShouldUpdateAverageHeartRate' has a wrong offset!");

// Class CoreGame.FileReader
// 0x0018 (0x0040 - 0x0028)
class UFileReader final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool LoadFile(const class FString& FilePath);
	TArray<uint8> ReadByteArray(int32 ByteCount);
	int32 ReadInteger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FileReader">();
	}
	static class UFileReader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFileReader>();
	}
};
static_assert(alignof(UFileReader) == 0x000008, "Wrong alignment on UFileReader");
static_assert(sizeof(UFileReader) == 0x000040, "Wrong size on UFileReader");

// Class CoreGame.WorldObject
// 0x0000 (0x0028 - 0x0028)
class UWorldObject : public UObject
{
public:
	void SetOuterObject(class UObject* NewOuterObject);
	void SetOuterObjectToActorLevel(class AActor* Actor);

	class UObject* GetOuterObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldObject">();
	}
	static class UWorldObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldObject>();
	}
};
static_assert(alignof(UWorldObject) == 0x000008, "Wrong alignment on UWorldObject");
static_assert(sizeof(UWorldObject) == 0x000028, "Wrong size on UWorldObject");

// Class CoreGame.GridLevelObject
// 0x0170 (0x0198 - 0x0028)
class UGridLevelObject final : public UWorldObject
{
public:
	float                                         CellSize;                                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallCollisionRadius;                               // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrokenWallCollisionLength;                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x164];                                     // 0x0034(0x0164)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddWall(const struct FIntRectangle& CellPair, int32 WallFlags);
	bool BreakWall(const struct FIntRectangle& CellPair);
	void GenerateTraversableCellSets(int32 TerrainTraverseFlags, const TArray<struct FIntPoint>& SourceCellLocations);
	void RemoveAllWalls();
	void ResetWallBlockedStates();
	void SetCellTerrainTypes(const TMap<struct FIntPoint, uint8>& CellTerrainTypeMap);
	bool SetTerrainTypeAtCellLocation(const struct FIntPoint& CellLocation, uint8 TerrainType);

	void AddPathableCellsInCardinalDirections(const struct FIntPoint& SourceCellLocation, int32 TerrainTraverseFlags, int32 MaxCellRange, TSet<struct FIntPoint>& PathableCells) const;
	struct FIntPoint AddPathableCellsInDirection(const struct FIntPoint& SourceCellLocation, const struct FIntPoint& CellDirection, int32 TerrainTraverseFlags, int32 MaxCellRange, TSet<struct FIntPoint>& PathableCells) const;
	bool CanEnterCell(const struct FIntPoint& SourceCellLocation, const struct FIntPoint& TargetCellLocation) const;
	bool CanEnterCellWithState(const struct FIntPoint& SourceCellLocation, const struct FIntPoint& TargetCellLocation, bool bCanTraverseBreakableWalls, int32 TerrainTraverseFlags) const;
	struct FIntPoint CellTraceInDirection(const struct FIntPoint& SourceCellLocation, const struct FIntPoint& CellDirection, int32 TerrainTraverseFlags, int32 MaxCellRange) const;
	bool FindShortestPath(const struct FVector2D& SourceLocation, const struct FVector2D& TargetLocation, int32 TerrainTraverseFlags, float MaxPathCost, const TMap<struct FIntPoint, float>& AddedCostMap, TArray<struct FIntPoint>* OutPathLocations) const;
	struct FIntPoint GetCellLocationFromLevelLocation(const struct FVector2D& Location) const;
	struct FVector2D GetLevelLocationFromCellLocation(const struct FIntPoint& CellLocation) const;
	TSet<struct FIntPoint> GetPathableCellSet(const TSet<struct FIntPoint>& ExcludeCells) const;
	uint8 GetTerrainTypeAtCellLocation(const struct FIntPoint& CellLocation) const;
	TSet<struct FIntPoint> GetUnpathableCellSet() const;
	bool IsCellLocationPathable(const struct FIntPoint& CellLocation) const;
	bool IsCellLocationValid(const struct FIntPoint& CellLocation) const;
	bool IsTraversableTerrain(const struct FIntPoint& CellLocation, int32 TerrainTraverseFlags) const;
	bool IsWallBlocked(const struct FIntRectangle& CellPair) const;
	bool IsWallBreakable(const struct FIntRectangle& CellPair) const;
	bool LineTraceGridWalls(const struct FVector2D& SourceLocation, const struct FVector2D& TargetLocation, float TraceRadius, const TArray<struct FIntRectangle>& IgnoreCellPairs, struct FGridTraceHitResult* OutHitResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GridLevelObject">();
	}
	static class UGridLevelObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGridLevelObject>();
	}
};
static_assert(alignof(UGridLevelObject) == 0x000008, "Wrong alignment on UGridLevelObject");
static_assert(sizeof(UGridLevelObject) == 0x000198, "Wrong size on UGridLevelObject");
static_assert(offsetof(UGridLevelObject, CellSize) == 0x000028, "Member 'UGridLevelObject::CellSize' has a wrong offset!");
static_assert(offsetof(UGridLevelObject, WallCollisionRadius) == 0x00002C, "Member 'UGridLevelObject::WallCollisionRadius' has a wrong offset!");
static_assert(offsetof(UGridLevelObject, BrokenWallCollisionLength) == 0x000030, "Member 'UGridLevelObject::BrokenWallCollisionLength' has a wrong offset!");

// Class CoreGame.Shuffler
// 0x0018 (0x0040 - 0x0028)
class UShuffler final : public UObject
{
public:
	int32                                         Current;                                           // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Count;                                             // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 State;                                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetNextIndex();
	void Reset();
	void SetCount(int32 CountToSet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Shuffler">();
	}
	static class UShuffler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShuffler>();
	}
};
static_assert(alignof(UShuffler) == 0x000008, "Wrong alignment on UShuffler");
static_assert(sizeof(UShuffler) == 0x000040, "Wrong size on UShuffler");
static_assert(offsetof(UShuffler, Current) == 0x000028, "Member 'UShuffler::Current' has a wrong offset!");
static_assert(offsetof(UShuffler, Count) == 0x00002C, "Member 'UShuffler::Count' has a wrong offset!");
static_assert(offsetof(UShuffler, State) == 0x000030, "Member 'UShuffler::State' has a wrong offset!");

// Class CoreGame.SymmetricRandomWalk
// 0x0050 (0x0078 - 0x0028)
class USymmetricRandomWalk final : public UObject
{
public:
	float                                         TimeInterval;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinStepSize;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxStepSize;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLinearInterp;                                     // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 InitialValues;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 SourceValues;                                      // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 TargetValues;                                      // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         AccumTime;                                         // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LastUpdateTimestamp;                               // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetCurrentValue(int32 SampleIndex);
	TArray<float> GetCurrentValues();
	void Restart();
	void SetWalkParameters(const TArray<float>& InitValues, float Interval, float MinStep, float MaxStep, float MinVal, float MaxVal, bool bLerp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SymmetricRandomWalk">();
	}
	static class USymmetricRandomWalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USymmetricRandomWalk>();
	}
};
static_assert(alignof(USymmetricRandomWalk) == 0x000008, "Wrong alignment on USymmetricRandomWalk");
static_assert(sizeof(USymmetricRandomWalk) == 0x000078, "Wrong size on USymmetricRandomWalk");
static_assert(offsetof(USymmetricRandomWalk, TimeInterval) == 0x000028, "Member 'USymmetricRandomWalk::TimeInterval' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, MinStepSize) == 0x00002C, "Member 'USymmetricRandomWalk::MinStepSize' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, MaxStepSize) == 0x000030, "Member 'USymmetricRandomWalk::MaxStepSize' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, MinValue) == 0x000034, "Member 'USymmetricRandomWalk::MinValue' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, MaxValue) == 0x000038, "Member 'USymmetricRandomWalk::MaxValue' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, bLinearInterp) == 0x00003C, "Member 'USymmetricRandomWalk::bLinearInterp' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, InitialValues) == 0x000040, "Member 'USymmetricRandomWalk::InitialValues' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, SourceValues) == 0x000050, "Member 'USymmetricRandomWalk::SourceValues' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, TargetValues) == 0x000060, "Member 'USymmetricRandomWalk::TargetValues' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, AccumTime) == 0x000070, "Member 'USymmetricRandomWalk::AccumTime' has a wrong offset!");
static_assert(offsetof(USymmetricRandomWalk, LastUpdateTimestamp) == 0x000074, "Member 'USymmetricRandomWalk::LastUpdateTimestamp' has a wrong offset!");

// Class CoreGame.WeightedAverageBase
// 0x0010 (0x0038 - 0x0028)
class UWeightedAverageBase : public UObject
{
public:
	EWeightedFuncType                             FunctionType;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SampleDuration;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Smoothing;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFrameDependent;                                   // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSmoothingFactor(float Smoothing_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightedAverageBase">();
	}
	static class UWeightedAverageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightedAverageBase>();
	}
};
static_assert(alignof(UWeightedAverageBase) == 0x000008, "Wrong alignment on UWeightedAverageBase");
static_assert(sizeof(UWeightedAverageBase) == 0x000038, "Wrong size on UWeightedAverageBase");
static_assert(offsetof(UWeightedAverageBase, FunctionType) == 0x000028, "Member 'UWeightedAverageBase::FunctionType' has a wrong offset!");
static_assert(offsetof(UWeightedAverageBase, SampleDuration) == 0x00002C, "Member 'UWeightedAverageBase::SampleDuration' has a wrong offset!");
static_assert(offsetof(UWeightedAverageBase, Smoothing) == 0x000030, "Member 'UWeightedAverageBase::Smoothing' has a wrong offset!");
static_assert(offsetof(UWeightedAverageBase, bFrameDependent) == 0x000034, "Member 'UWeightedAverageBase::bFrameDependent' has a wrong offset!");

// Class CoreGame.WeightedAverageFloat
// 0x0010 (0x0048 - 0x0038)
class UWeightedAverageFloat final : public UWeightedAverageBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearHistory();
	float GetSmoothedFloat(float Sample, float CurrentTime, float DeltaTime);

	float GetElapsedTimeSinceLastSample(float CurrentTime) const;
	float GetTotalElapsedSampleTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightedAverageFloat">();
	}
	static class UWeightedAverageFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightedAverageFloat>();
	}
};
static_assert(alignof(UWeightedAverageFloat) == 0x000008, "Wrong alignment on UWeightedAverageFloat");
static_assert(sizeof(UWeightedAverageFloat) == 0x000048, "Wrong size on UWeightedAverageFloat");

// Class CoreGame.WeightedAverageVec2
// 0x0010 (0x0048 - 0x0038)
class UWeightedAverageVec2 final : public UWeightedAverageBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearHistory();
	struct FVector2D GetSmoothedVec2(const struct FVector2D& Sample, float CurrentTime, float DeltaTime);

	float GetElapsedTimeSinceLastSample(float CurrentTime) const;
	float GetTotalElapsedSampleTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightedAverageVec2">();
	}
	static class UWeightedAverageVec2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightedAverageVec2>();
	}
};
static_assert(alignof(UWeightedAverageVec2) == 0x000008, "Wrong alignment on UWeightedAverageVec2");
static_assert(sizeof(UWeightedAverageVec2) == 0x000048, "Wrong size on UWeightedAverageVec2");

// Class CoreGame.WeightedAverageVec3
// 0x0010 (0x0048 - 0x0038)
class UWeightedAverageVec3 final : public UWeightedAverageBase
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearHistory();
	struct FVector GetSmoothedVec3(const struct FVector& Sample, float CurrentTime, float DeltaTime);

	float GetElapsedTimeSinceLastSample(float CurrentTime) const;
	float GetTotalElapsedSampleTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightedAverageVec3">();
	}
	static class UWeightedAverageVec3* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeightedAverageVec3>();
	}
};
static_assert(alignof(UWeightedAverageVec3) == 0x000008, "Wrong alignment on UWeightedAverageVec3");
static_assert(sizeof(UWeightedAverageVec3) == 0x000048, "Wrong size on UWeightedAverageVec3");

}

