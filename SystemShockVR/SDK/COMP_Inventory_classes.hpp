#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: COMP_Inventory

#include "Basic.hpp"

#include "STRUCT_InventoryBagParams_structs.hpp"
#include "STRUCT_SoftItemParams_structs.hpp"
#include "ENUM_ItemType_structs.hpp"
#include "Engine_classes.hpp"
#include "ENUM_UpgradeResult_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass COMP_Inventory.COMP_Inventory_C
// 0x0058 (0x0108 - 0x00B0)
class UCOMP_Inventory_C : public UActorComponent
{
public:
	TArray<struct FSTRUCT_InventoryBagParams>     DefaultBags;                                       // 0x00B0(0x0010)(Edit, BlueprintVisible)
	TArray<struct FSTRUCT_SoftItemParams>         DefaultItems;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible)
	TArray<class UInventoryBag_C*>                Bags;                                              // 0x00D0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	FMulticastInlineDelegateProperty_             OnBagChanged;                                      // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnItemUpgraded;                                    // 0x00F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          ShouldSaveInventory;                               // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)

public:
	void OnBagChanged__DelegateSignature(class UInventoryBag_C* Bag, int32 SlotIndex);
	void OnItemUpgraded__DelegateSignature(class UClass* UpgradeClass, class UClass* DowngradeClass, ENUM_UpgradeResult Result);
	void InitializeInventory(bool GrantDefaultInventory);
	void AddBag(const struct FSTRUCT_InventoryBagParams& BagParams, class UInventoryBag_C** Bag);
	void InitializeBags();
	void GrantItem(const struct FSTRUCT_HardItemParams& ItemParams, bool* Result);
	void GrantItemsFromPackage(class UClass* PackageClass, bool* Result);
	void GrantItemsFromPackages(class UClass* PackageClass, int32 PackageCount, bool* Result);
	void AddItem(class UITEM_Base_C* Item, bool* Result);
	void AddItemInternal(class UITEM_Base_C* Item, class UClass* ItemClass, int32 Count, bool Modify, bool* Result);
	void CanGrantItem(const struct FSTRUCT_HardItemParams& ItemParams, bool* Result);
	void CanAddItem(class UITEM_Base_C* Item, bool* Result);
	void GetBagByType(ENUM_ItemType ItemType, class UInventoryBag_C** Bag);
	void GetBagByRequiredType(ENUM_ItemType ItemType, class UInventoryBag_C** Bag);
	void GetBagByIndex(int32 BagIndex, class UInventoryBag_C** Bag);
	void GetItemCount(class UClass* ItemClass, int32 MaxCount, class UITEM_Base_C* IgnoreItem, int32* Result);
	void CreateItem(const struct FSTRUCT_HardItemParams& ItemParams, class UITEM_Base_C** Item);
	void GetBagByName(class FName BagName, class UInventoryBag_C** Bag);
	void GetLootSeed(int32* Seed);
	void IsInventoryEmpty(bool* Result);
	void MergeItems(class UCOMP_Inventory_C* OtherInventory, TArray<class UITEM_Base_C*>& ItemsNotMerged, bool* Success);
	void RemoveItemByClass(class UClass* ItemClass, class UITEM_Base_C** RemovedItem);
	void FindItem(class UClass* ItemClass, bool RequireUnslottable, bool AnyDerivedClass, class UITEM_Base_C** FoundItem);
	void FindItemBySoftClass(TSoftClassPtr<class UClass> ItemClass, bool RequireUnslottable, class UITEM_Base_C** FoundItem);
	void RemoveItem(class UITEM_Base_C* Item, bool* Result);
	void FindAndApplyUpgrade(class UITEM_UpgradeBase_C* UpgradeItem, class UClass* UpgradeClass, ENUM_UpgradeResult* Result);
	void FindItemToUpgrade(class UClass* UpgradeClass, class UITEM_UpgradeBase_C** Item, ENUM_UpgradeResult* Result);
	void CanGrantItems(TArray<struct FSTRUCT_SoftItemParams>& ItemParamsArray, bool* Result);
	void IsEquipmentDisabled(bool* Result);
	void ShouldCreateLinkedPickups(bool* Result);
	void SetEquipmentDisabled(bool Disable);
	void UpdateItemActivationStates();
	void HasReachedEquipCapacity(class UInventoryBag_C* Bag, class UITEM_Base_C* Item, bool* Result);
	void GetFirstEquippedItem(class UInventoryBag_C* Bag, class UITEM_Base_C** Item);
	void GetDescriptionMessage(const class FText& BaseMessage, class FText* Text);
	bool ShouldSaveComponent(struct FStreamingSaveGameComponentParams* Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"COMP_Inventory_C">();
	}
	static class UCOMP_Inventory_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCOMP_Inventory_C>();
	}
};
static_assert(alignof(UCOMP_Inventory_C) == 0x000008, "Wrong alignment on UCOMP_Inventory_C");
static_assert(sizeof(UCOMP_Inventory_C) == 0x000108, "Wrong size on UCOMP_Inventory_C");
static_assert(offsetof(UCOMP_Inventory_C, DefaultBags) == 0x0000B0, "Member 'UCOMP_Inventory_C::DefaultBags' has a wrong offset!");
static_assert(offsetof(UCOMP_Inventory_C, DefaultItems) == 0x0000C0, "Member 'UCOMP_Inventory_C::DefaultItems' has a wrong offset!");
static_assert(offsetof(UCOMP_Inventory_C, Bags) == 0x0000D0, "Member 'UCOMP_Inventory_C::Bags' has a wrong offset!");
static_assert(offsetof(UCOMP_Inventory_C, OnBagChanged) == 0x0000E0, "Member 'UCOMP_Inventory_C::OnBagChanged' has a wrong offset!");
static_assert(offsetof(UCOMP_Inventory_C, OnItemUpgraded) == 0x0000F0, "Member 'UCOMP_Inventory_C::OnItemUpgraded' has a wrong offset!");
static_assert(offsetof(UCOMP_Inventory_C, ShouldSaveInventory) == 0x000100, "Member 'UCOMP_Inventory_C::ShouldSaveInventory' has a wrong offset!");

}

