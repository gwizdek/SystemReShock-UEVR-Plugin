#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PUZZLE_Base

#include "Basic.hpp"

#include "PUZZLE_Base_classes.hpp"
#include "PUZZLE_Base_parameters.hpp"


namespace SDK
{

// Function PUZZLE_Base.PUZZLE_Base_C.ExecuteUbergraph_PUZZLE_Base
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::ExecuteUbergraph_PUZZLE_Base(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "ExecuteUbergraph_PUZZLE_Base");

	Params::PUZZLE_Base_C_ExecuteUbergraph_PUZZLE_Base Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.BndEvt__COMP_VoxelCullable_K2Node_ComponentBoundEvent_0_CullableVisibilitySignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// bool                                    bVisibleState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::BndEvt__COMP_VoxelCullable_K2Node_ComponentBoundEvent_0_CullableVisibilitySignature__DelegateSignature(bool bVisibleState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "BndEvt__COMP_VoxelCullable_K2Node_ComponentBoundEvent_0_CullableVisibilitySignature__DelegateSignature");

	Params::PUZZLE_Base_C_BndEvt__COMP_VoxelCullable_K2Node_ComponentBoundEvent_0_CullableVisibilitySignature__DelegateSignature Parms{};

	Parms.bVisibleState = bVisibleState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void APUZZLE_Base_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetTargetShape
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              CursorPrimitive                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UShapeComponent*                  ShapeComponent                                         (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetTargetShape(class UPrimitiveComponent* CursorPrimitive, class UShapeComponent** ShapeComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetTargetShape");

	Params::PUZZLE_Base_C_GetTargetShape Parms{};

	Parms.CursorPrimitive = CursorPrimitive;

	UObject::ProcessEvent(Func, &Parms);

	if (ShapeComponent != nullptr)
		*ShapeComponent = Parms.ShapeComponent;
}


// Function PUZZLE_Base.PUZZLE_Base_C.TryInteract
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           SourceActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              CursorPrimitive                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_InteractionType                    InteractionType                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_InteractResults          InteractResults                                        (Parm, OutParm, HasGetValueTypeHash)

void APUZZLE_Base_C::TryInteract(class AActor* SourceActor, class UPrimitiveComponent* CursorPrimitive, ENUM_InteractionType InteractionType, struct FSTRUCT_InteractResults* InteractResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "TryInteract");

	Params::PUZZLE_Base_C_TryInteract Parms{};

	Parms.SourceActor = SourceActor;
	Parms.CursorPrimitive = CursorPrimitive;
	Parms.InteractionType = InteractionType;

	UObject::ProcessEvent(Func, &Parms);

	if (InteractResults != nullptr)
		*InteractResults = std::move(Parms.InteractResults);
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetAnimInstance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAnimBP_JunctionBox_C*            AnimInstance                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetAnimInstance(class UAnimBP_JunctionBox_C** AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetAnimInstance");

	Params::PUZZLE_Base_C_GetAnimInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AnimInstance != nullptr)
		*AnimInstance = Parms.AnimInstance;
}


// Function PUZZLE_Base.PUZZLE_Base_C.EVENT_IsDoneOpening
// (Protected, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::EVENT_IsDoneOpening()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "EVENT_IsDoneOpening");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.EVENT_OnPuzzleBoxClosed
// (Protected, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::EVENT_OnPuzzleBoxClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "EVENT_OnPuzzleBoxClosed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.InitializePuzzle
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::InitializePuzzle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "InitializePuzzle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.InitializeAttributes
// (Protected, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::InitializeAttributes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "InitializeAttributes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.InitializeAsSolved
// (Protected, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::InitializeAsSolved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "InitializeAsSolved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.InitializeAsOpened
// (Protected, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::InitializeAsOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "InitializeAsOpened");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.InteractWithPuzzlePrimitive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              CursorPrimitive                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_InteractResultType                 Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             ResultText                                             (Parm, OutParm)

void APUZZLE_Base_C::InteractWithPuzzlePrimitive(class UPrimitiveComponent* CursorPrimitive, ENUM_InteractResultType* Result, class FText* ResultText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "InteractWithPuzzlePrimitive");

	Params::PUZZLE_Base_C_InteractWithPuzzlePrimitive Parms{};

	Parms.CursorPrimitive = CursorPrimitive;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (ResultText != nullptr)
		*ResultText = std::move(Parms.ResultText);
}


// Function PUZZLE_Base.PUZZLE_Base_C.HandleSolvedOutcomes
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SolvedByPlayer                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::HandleSolvedOutcomes(bool SolvedByPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "HandleSolvedOutcomes");

	Params::PUZZLE_Base_C_HandleSolvedOutcomes Parms{};

	Parms.SolvedByPlayer = SolvedByPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.SetPuzzleLightState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::SetPuzzleLightState(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "SetPuzzleLightState");

	Params::PUZZLE_Base_C_SetPuzzleLightState Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetPuzzleShape
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              CursorPrimitive                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UShapeComponent*                  TargetShape                                            (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetPuzzleShape(class UPrimitiveComponent* CursorPrimitive, class UShapeComponent** TargetShape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetPuzzleShape");

	Params::PUZZLE_Base_C_GetPuzzleShape Parms{};

	Parms.CursorPrimitive = CursorPrimitive;

	UObject::ProcessEvent(Func, &Parms);

	if (TargetShape != nullptr)
		*TargetShape = Parms.TargetShape;
}


// Function PUZZLE_Base.PUZZLE_Base_C.SetPuzzleSolved
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_PuzzleSolveType                    SolveType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::SetPuzzleSolved(ENUM_PuzzleSolveType SolveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "SetPuzzleSolved");

	Params::PUZZLE_Base_C_SetPuzzleSolved Parms{};

	Parms.SolveType = SolveType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.TrySolvePossiblyStalePuzzle
// (Protected, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::TrySolvePossiblyStalePuzzle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "TrySolvePossiblyStalePuzzle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.TryChangeUnlockEventBindings
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::TryChangeUnlockEventBindings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "TryChangeUnlockEventBindings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.TryCompleteOpenTutorial
// (Public, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::TryCompleteOpenTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "TryCompleteOpenTutorial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.OpenPuzzleBox
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::OpenPuzzleBox(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "OpenPuzzleBox");

	Params::PUZZLE_Base_C_OpenPuzzleBox Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.RegisterPuzzleCell
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCOMP_PuzzleCell_Base_C*          PuzzleCell                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::RegisterPuzzleCell(class UCOMP_PuzzleCell_Base_C* PuzzleCell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "RegisterPuzzleCell");

	Params::PUZZLE_Base_C_RegisterPuzzleCell Parms{};

	Parms.PuzzleCell = PuzzleCell;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.RegisterSpecialComponent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   MeshComponent                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::RegisterSpecialComponent(class UMeshComponent* MeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "RegisterSpecialComponent");

	Params::PUZZLE_Base_C_RegisterSpecialComponent Parms{};

	Parms.MeshComponent = MeshComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.UpdateMeshEmissiveStrength
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::UpdateMeshEmissiveStrength(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "UpdateMeshEmissiveStrength");

	Params::PUZZLE_Base_C_UpdateMeshEmissiveStrength Parms{};

	Parms.Scale = Scale;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.UpdatePuzzleVisibility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    VisibilityState                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::UpdatePuzzleVisibility(bool VisibilityState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "UpdatePuzzleVisibility");

	Params::PUZZLE_Base_C_UpdatePuzzleVisibility Parms{};

	Parms.VisibilityState = VisibilityState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.EVENT_OnStopComponentTicks
// (Private, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::EVENT_OnStopComponentTicks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "EVENT_OnStopComponentTicks");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.EVENT_OnSecurityLevelChanged
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewSecurityLevel                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::EVENT_OnSecurityLevelChanged(int32 NewSecurityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "EVENT_OnSecurityLevelChanged");

	Params::PUZZLE_Base_C_EVENT_OnSecurityLevelChanged Parms{};

	Parms.NewSecurityLevel = NewSecurityLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.ShowLogicProbeMesh
// (Private, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::ShowLogicProbeMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "ShowLogicProbeMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetFocusWorldTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FTransform                       Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::GetFocusWorldTransform(struct FTransform* Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetFocusWorldTransform");

	Params::PUZZLE_Base_C_GetFocusWorldTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetCellChanges
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetCellChanges(uint8 Index_0, uint8* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetCellChanges");

	Params::PUZZLE_Base_C_GetCellChanges Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.SaveCellChanges
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   Params_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::SaveCellChanges(uint8 Index_0, uint8 Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "SaveCellChanges");

	Params::PUZZLE_Base_C_SaveCellChanges Parms{};

	Parms.Index_0 = Index_0;
	Parms.Params_0 = Params_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.LoadPuzzleFromDataTable
// (Public, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::LoadPuzzleFromDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "LoadPuzzleFromDataTable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.ApplySavedCellChanges
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::ApplySavedCellChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "ApplySavedCellChanges");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.IsJunctionBoxFunctional
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::IsJunctionBoxFunctional(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "IsJunctionBoxFunctional");

	Params::PUZZLE_Base_C_IsJunctionBoxFunctional Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.IsPuzzleSolved
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::IsPuzzleSolved(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "IsPuzzleSolved");

	Params::PUZZLE_Base_C_IsPuzzleSolved Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.IsVerticalAxisReversed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::IsVerticalAxisReversed(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "IsVerticalAxisReversed");

	Params::PUZZLE_Base_C_IsVerticalAxisReversed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetGridDimensions
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetGridDimensions(int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetGridDimensions");

	Params::PUZZLE_Base_C_GetGridDimensions Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetCellAtLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FIntPoint                        Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UCOMP_PuzzleCell_Base_C*          Cell                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetCellAtLocation(const struct FIntPoint& Location, class UCOMP_PuzzleCell_Base_C** Cell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetCellAtLocation");

	Params::PUZZLE_Base_C_GetCellAtLocation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Cell != nullptr)
		*Cell = Parms.Cell;
}


// Function PUZZLE_Base.PUZZLE_Base_C.CycleFocusedPrimitiveComponent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              CursorPrimitive                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Vertical                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Previous                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::CycleFocusedPrimitiveComponent(class UPrimitiveComponent* CursorPrimitive, bool Vertical, bool Previous)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "CycleFocusedPrimitiveComponent");

	Params::PUZZLE_Base_C_CycleFocusedPrimitiveComponent Parms{};

	Parms.CursorPrimitive = CursorPrimitive;
	Parms.Vertical = Vertical;
	Parms.Previous = Previous;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetCellLocationFromIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   CellIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FIntPoint                        CellLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetCellLocationFromIndex(int32 CellIndex, struct FIntPoint* CellLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetCellLocationFromIndex");

	Params::PUZZLE_Base_C_GetCellLocationFromIndex Parms{};

	Parms.CellIndex = CellIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (CellLocation != nullptr)
		*CellLocation = std::move(Parms.CellLocation);
}


// Function PUZZLE_Base.PUZZLE_Base_C.OnFinishedFocusing
// (Protected, BlueprintCallable, BlueprintEvent)

void APUZZLE_Base_C::OnFinishedFocusing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "OnFinishedFocusing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetPuzzleRowToUse
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              PuzzleRow                                              (Parm, OutParm, NoDestructor)

void APUZZLE_Base_C::GetPuzzleRowToUse(struct FDataTableRowHandle* PuzzleRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetPuzzleRowToUse");

	Params::PUZZLE_Base_C_GetPuzzleRowToUse Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PuzzleRow != nullptr)
		*PuzzleRow = std::move(Parms.PuzzleRow);
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetCellIndexFromLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FIntPoint                        Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetCellIndexFromLocation(const struct FIntPoint& Location, int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetCellIndexFromLocation");

	Params::PUZZLE_Base_C_GetCellIndexFromLocation Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.CanManipulateUnlockTargets
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::CanManipulateUnlockTargets(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "CanManipulateUnlockTargets");

	Params::PUZZLE_Base_C_CanManipulateUnlockTargets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.EVENT_OnInteractLockStateChanged
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AINTERACT_Base_C*                 Interact                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::EVENT_OnInteractLockStateChanged(class AINTERACT_Base_C* Interact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "EVENT_OnInteractLockStateChanged");

	Params::PUZZLE_Base_C_EVENT_OnInteractLockStateChanged Parms{};

	Parms.Interact = Interact;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.EVENT_OnLockedDoorStateChanged
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AINTERACT_DoorBase_C*             Door                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_DoorState                          State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::EVENT_OnLockedDoorStateChanged(class AINTERACT_DoorBase_C* Door, ENUM_DoorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "EVENT_OnLockedDoorStateChanged");

	Params::PUZZLE_Base_C_EVENT_OnLockedDoorStateChanged Parms{};

	Parms.Door = Door;
	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.ShouldFocusOnInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::ShouldFocusOnInteract(class AController* Controller, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "ShouldFocusOnInteract");

	Params::PUZZLE_Base_C_ShouldFocusOnInteract Parms{};

	Parms.Controller = Controller;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetCellComponentFromPrimitive
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UCOMP_PuzzleCell_Base_C*          Result                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetCellComponentFromPrimitive(class UPrimitiveComponent* PrimitiveComponent, class UCOMP_PuzzleCell_Base_C** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetCellComponentFromPrimitive");

	Params::PUZZLE_Base_C_GetCellComponentFromPrimitive Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.TryReceiveItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UITEM_Base_C*                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::TryReceiveItem(class UITEM_Base_C* Item, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "TryReceiveItem");

	Params::PUZZLE_Base_C_TryReceiveItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.CanReceiveItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UITEM_Base_C*                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::CanReceiveItem(class UITEM_Base_C* Item, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "CanReceiveItem");

	Params::PUZZLE_Base_C_CanReceiveItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.GetCellInDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FIntPoint                        SourcePosition                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_CardinalDirection                  Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FIntPoint                        TargetPosition                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::GetCellInDirection(const struct FIntPoint& SourcePosition, ENUM_CardinalDirection Direction, struct FIntPoint* TargetPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "GetCellInDirection");

	Params::PUZZLE_Base_C_GetCellInDirection Parms{};

	Parms.SourcePosition = std::move(SourcePosition);
	Parms.Direction = Direction;

	UObject::ProcessEvent(Func, &Parms);

	if (TargetPosition != nullptr)
		*TargetPosition = std::move(Parms.TargetPosition);
}


// Function PUZZLE_Base.PUZZLE_Base_C.EVENT_OnDisableAttribChanged
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CurrValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LastValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::EVENT_OnDisableAttribChanged(float CurrValue, float LastValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "EVENT_OnDisableAttribChanged");

	Params::PUZZLE_Base_C_EVENT_OnDisableAttribChanged Parms{};

	Parms.CurrValue = CurrValue;
	Parms.LastValue = LastValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PUZZLE_Base.PUZZLE_Base_C.SetInteractPowered
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::SetInteractPowered(bool State, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "SetInteractPowered");

	Params::PUZZLE_Base_C_SetInteractPowered Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.CanModifyInteractPower
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APUZZLE_Base_C::CanModifyInteractPower(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "CanModifyInteractPower");

	Params::PUZZLE_Base_C_CanModifyInteractPower Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PUZZLE_Base.PUZZLE_Base_C.ResumeChannelingInteraction
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Hacker_Simple_C*            HackerPawn                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APUZZLE_Base_C::ResumeChannelingInteraction(class APAWN_Hacker_Simple_C* HackerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PUZZLE_Base_C", "ResumeChannelingInteraction");

	Params::PUZZLE_Base_C_ResumeChannelingInteraction Parms{};

	Parms.HackerPawn = HackerPawn;

	UObject::ProcessEvent(Func, &Parms);
}

}

