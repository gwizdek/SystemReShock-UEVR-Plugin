#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreGame

#include "Basic.hpp"

#include "CoreGame_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function CoreGame.CoreGameFunctionLibrary.AddDataTableRow
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_AddDataTableRow final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_AddDataTableRow) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_AddDataTableRow");
static_assert(sizeof(CoreGameFunctionLibrary_AddDataTableRow) == 0x000018, "Wrong size on CoreGameFunctionLibrary_AddDataTableRow");
static_assert(offsetof(CoreGameFunctionLibrary_AddDataTableRow, DataTable) == 0x000000, "Member 'CoreGameFunctionLibrary_AddDataTableRow::DataTable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddDataTableRow, RowName) == 0x000008, "Member 'CoreGameFunctionLibrary_AddDataTableRow::RowName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddDataTableRow, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_AddDataTableRow::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.AddStaticMeshComponent
// 0x0060 (0x0060 - 0x0000)
struct CoreGameFunctionLibrary_AddStaticMeshComponent final
{
public:
	class USceneComponent*                        AttachToComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0020(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0050(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_AddStaticMeshComponent) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_AddStaticMeshComponent");
static_assert(sizeof(CoreGameFunctionLibrary_AddStaticMeshComponent) == 0x000060, "Wrong size on CoreGameFunctionLibrary_AddStaticMeshComponent");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponent, AttachToComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponent::AttachToComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponent, StaticMesh) == 0x000008, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponent::StaticMesh' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponent, SocketName) == 0x000010, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponent::SocketName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponent, RelativeTransform) == 0x000020, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponent::RelativeTransform' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponent, ReturnValue) == 0x000050, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponent::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.AddStaticMeshComponentInEditor
// 0x0050 (0x0050 - 0x0000)
struct CoreGameFunctionLibrary_AddStaticMeshComponentInEditor final
{
public:
	class AActor*                                 Owner;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RelativeTransform;                                 // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0040(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_AddStaticMeshComponentInEditor) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_AddStaticMeshComponentInEditor");
static_assert(sizeof(CoreGameFunctionLibrary_AddStaticMeshComponentInEditor) == 0x000050, "Wrong size on CoreGameFunctionLibrary_AddStaticMeshComponentInEditor");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponentInEditor, Owner) == 0x000000, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponentInEditor::Owner' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponentInEditor, StaticMesh) == 0x000008, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponentInEditor::StaticMesh' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponentInEditor, RelativeTransform) == 0x000010, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponentInEditor::RelativeTransform' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AddStaticMeshComponentInEditor, ReturnValue) == 0x000040, "Member 'CoreGameFunctionLibrary_AddStaticMeshComponentInEditor::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.AngleBetweenNormals
// 0x001C (0x001C - 0x0000)
struct CoreGameFunctionLibrary_AngleBetweenNormals final
{
public:
	struct FVector                                SourceVector;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_AngleBetweenNormals) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_AngleBetweenNormals");
static_assert(sizeof(CoreGameFunctionLibrary_AngleBetweenNormals) == 0x00001C, "Wrong size on CoreGameFunctionLibrary_AngleBetweenNormals");
static_assert(offsetof(CoreGameFunctionLibrary_AngleBetweenNormals, SourceVector) == 0x000000, "Member 'CoreGameFunctionLibrary_AngleBetweenNormals::SourceVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AngleBetweenNormals, TargetVector) == 0x00000C, "Member 'CoreGameFunctionLibrary_AngleBetweenNormals::TargetVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AngleBetweenNormals, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_AngleBetweenNormals::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.AngleBetweenVectors
// 0x001C (0x001C - 0x0000)
struct CoreGameFunctionLibrary_AngleBetweenVectors final
{
public:
	struct FVector                                SourceVector;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_AngleBetweenVectors) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_AngleBetweenVectors");
static_assert(sizeof(CoreGameFunctionLibrary_AngleBetweenVectors) == 0x00001C, "Wrong size on CoreGameFunctionLibrary_AngleBetweenVectors");
static_assert(offsetof(CoreGameFunctionLibrary_AngleBetweenVectors, SourceVector) == 0x000000, "Member 'CoreGameFunctionLibrary_AngleBetweenVectors::SourceVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AngleBetweenVectors, TargetVector) == 0x00000C, "Member 'CoreGameFunctionLibrary_AngleBetweenVectors::TargetVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AngleBetweenVectors, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_AngleBetweenVectors::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ApplySkeletalMeshBodyTransforms
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     BodyTransforms;                                    // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms");
static_assert(sizeof(CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms) == 0x000018, "Wrong size on CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms");
static_assert(offsetof(CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms, SkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms, BodyTransforms) == 0x000008, "Member 'CoreGameFunctionLibrary_ApplySkeletalMeshBodyTransforms::BodyTransforms' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.AttachAndModifyComponentOwnership
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_AttachAndModifyComponentOwnership final
{
public:
	class USceneComponent*                        TransferComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_AttachAndModifyComponentOwnership) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_AttachAndModifyComponentOwnership");
static_assert(sizeof(CoreGameFunctionLibrary_AttachAndModifyComponentOwnership) == 0x000018, "Wrong size on CoreGameFunctionLibrary_AttachAndModifyComponentOwnership");
static_assert(offsetof(CoreGameFunctionLibrary_AttachAndModifyComponentOwnership, TransferComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_AttachAndModifyComponentOwnership::TransferComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AttachAndModifyComponentOwnership, AttachToComponent) == 0x000008, "Member 'CoreGameFunctionLibrary_AttachAndModifyComponentOwnership::AttachToComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AttachAndModifyComponentOwnership, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_AttachAndModifyComponentOwnership::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.AttachDistanceFieldMeshesToSkeletalMeshComponent
// 0x0058 (0x0058 - 0x0000)
struct CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    StaticMeshes;                                      // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollisionProfileName;                              // 0x001C(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PrefixKey;                                         // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Delimiter;                                         // 0x0038(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RelativeRotation;                                  // 0x0048(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent");
static_assert(sizeof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent) == 0x000058, "Wrong size on CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent");
static_assert(offsetof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent, SkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent, StaticMeshes) == 0x000008, "Member 'CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent::StaticMeshes' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent, bVisible) == 0x000018, "Member 'CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent::bVisible' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent, CollisionProfileName) == 0x00001C, "Member 'CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent, PrefixKey) == 0x000028, "Member 'CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent::PrefixKey' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent, Delimiter) == 0x000038, "Member 'CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent::Delimiter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent, RelativeRotation) == 0x000048, "Member 'CoreGameFunctionLibrary_AttachDistanceFieldMeshesToSkeletalMeshComponent::RelativeRotation' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.BatchSetCustomPrimitiveData
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_BatchSetCustomPrimitiveData final
{
public:
	TArray<class UPrimitiveComponent*>            PrimitiveComponents;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         DataIndex;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Values;                                            // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_BatchSetCustomPrimitiveData) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_BatchSetCustomPrimitiveData");
static_assert(sizeof(CoreGameFunctionLibrary_BatchSetCustomPrimitiveData) == 0x000028, "Wrong size on CoreGameFunctionLibrary_BatchSetCustomPrimitiveData");
static_assert(offsetof(CoreGameFunctionLibrary_BatchSetCustomPrimitiveData, PrimitiveComponents) == 0x000000, "Member 'CoreGameFunctionLibrary_BatchSetCustomPrimitiveData::PrimitiveComponents' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BatchSetCustomPrimitiveData, DataIndex) == 0x000010, "Member 'CoreGameFunctionLibrary_BatchSetCustomPrimitiveData::DataIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BatchSetCustomPrimitiveData, Values) == 0x000018, "Member 'CoreGameFunctionLibrary_BatchSetCustomPrimitiveData::Values' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.BindMontageOnBlendOutStarted
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_BindMontageOnBlendOutStarted final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UAnimMontage* Montage, bool bInterrupted)> Event;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_BindMontageOnBlendOutStarted) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_BindMontageOnBlendOutStarted");
static_assert(sizeof(CoreGameFunctionLibrary_BindMontageOnBlendOutStarted) == 0x000020, "Wrong size on CoreGameFunctionLibrary_BindMontageOnBlendOutStarted");
static_assert(offsetof(CoreGameFunctionLibrary_BindMontageOnBlendOutStarted, AnimInstance) == 0x000000, "Member 'CoreGameFunctionLibrary_BindMontageOnBlendOutStarted::AnimInstance' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BindMontageOnBlendOutStarted, Montage) == 0x000008, "Member 'CoreGameFunctionLibrary_BindMontageOnBlendOutStarted::Montage' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BindMontageOnBlendOutStarted, Event) == 0x000010, "Member 'CoreGameFunctionLibrary_BindMontageOnBlendOutStarted::Event' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.BindMontageOnEnded
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_BindMontageOnEnded final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UAnimMontage* Montage, bool bInterrupted)> Event;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_BindMontageOnEnded) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_BindMontageOnEnded");
static_assert(sizeof(CoreGameFunctionLibrary_BindMontageOnEnded) == 0x000020, "Wrong size on CoreGameFunctionLibrary_BindMontageOnEnded");
static_assert(offsetof(CoreGameFunctionLibrary_BindMontageOnEnded, AnimInstance) == 0x000000, "Member 'CoreGameFunctionLibrary_BindMontageOnEnded::AnimInstance' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BindMontageOnEnded, Montage) == 0x000008, "Member 'CoreGameFunctionLibrary_BindMontageOnEnded::Montage' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BindMontageOnEnded, Event) == 0x000010, "Member 'CoreGameFunctionLibrary_BindMontageOnEnded::Event' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.BitShiftLeft
// 0x000C (0x000C - 0x0000)
struct CoreGameFunctionLibrary_BitShiftLeft final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShiftBy;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_BitShiftLeft) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_BitShiftLeft");
static_assert(sizeof(CoreGameFunctionLibrary_BitShiftLeft) == 0x00000C, "Wrong size on CoreGameFunctionLibrary_BitShiftLeft");
static_assert(offsetof(CoreGameFunctionLibrary_BitShiftLeft, Value) == 0x000000, "Member 'CoreGameFunctionLibrary_BitShiftLeft::Value' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BitShiftLeft, ShiftBy) == 0x000004, "Member 'CoreGameFunctionLibrary_BitShiftLeft::ShiftBy' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BitShiftLeft, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_BitShiftLeft::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.BitShiftRight
// 0x000C (0x000C - 0x0000)
struct CoreGameFunctionLibrary_BitShiftRight final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShiftBy;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_BitShiftRight) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_BitShiftRight");
static_assert(sizeof(CoreGameFunctionLibrary_BitShiftRight) == 0x00000C, "Wrong size on CoreGameFunctionLibrary_BitShiftRight");
static_assert(offsetof(CoreGameFunctionLibrary_BitShiftRight, Value) == 0x000000, "Member 'CoreGameFunctionLibrary_BitShiftRight::Value' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BitShiftRight, ShiftBy) == 0x000004, "Member 'CoreGameFunctionLibrary_BitShiftRight::ShiftBy' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BitShiftRight, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_BitShiftRight::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.BoneIsChildOf
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_BoneIsChildOf final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentBoneName;                                    // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_BoneIsChildOf) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_BoneIsChildOf");
static_assert(sizeof(CoreGameFunctionLibrary_BoneIsChildOf) == 0x000020, "Wrong size on CoreGameFunctionLibrary_BoneIsChildOf");
static_assert(offsetof(CoreGameFunctionLibrary_BoneIsChildOf, SkeletalMesh) == 0x000000, "Member 'CoreGameFunctionLibrary_BoneIsChildOf::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BoneIsChildOf, BoneName) == 0x000008, "Member 'CoreGameFunctionLibrary_BoneIsChildOf::BoneName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BoneIsChildOf, ParentBoneName) == 0x000010, "Member 'CoreGameFunctionLibrary_BoneIsChildOf::ParentBoneName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BoneIsChildOf, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_BoneIsChildOf::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.BreakEnumHandleToNames
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_BreakEnumHandleToNames final
{
public:
	struct FEnumHandle                            EnumHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   EnumHandleName;                                    // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnumeratorName;                                    // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_BreakEnumHandleToNames) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_BreakEnumHandleToNames");
static_assert(sizeof(CoreGameFunctionLibrary_BreakEnumHandleToNames) == 0x000020, "Wrong size on CoreGameFunctionLibrary_BreakEnumHandleToNames");
static_assert(offsetof(CoreGameFunctionLibrary_BreakEnumHandleToNames, EnumHandle) == 0x000000, "Member 'CoreGameFunctionLibrary_BreakEnumHandleToNames::EnumHandle' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BreakEnumHandleToNames, EnumHandleName) == 0x000010, "Member 'CoreGameFunctionLibrary_BreakEnumHandleToNames::EnumHandleName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BreakEnumHandleToNames, EnumeratorName) == 0x000018, "Member 'CoreGameFunctionLibrary_BreakEnumHandleToNames::EnumeratorName' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.BreakEnumHandleToStrings
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_BreakEnumHandleToStrings final
{
public:
	struct FEnumHandle                            EnumHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 EnumHandleString;                                  // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnumeratorString;                                  // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_BreakEnumHandleToStrings) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_BreakEnumHandleToStrings");
static_assert(sizeof(CoreGameFunctionLibrary_BreakEnumHandleToStrings) == 0x000030, "Wrong size on CoreGameFunctionLibrary_BreakEnumHandleToStrings");
static_assert(offsetof(CoreGameFunctionLibrary_BreakEnumHandleToStrings, EnumHandle) == 0x000000, "Member 'CoreGameFunctionLibrary_BreakEnumHandleToStrings::EnumHandle' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BreakEnumHandleToStrings, EnumHandleString) == 0x000010, "Member 'CoreGameFunctionLibrary_BreakEnumHandleToStrings::EnumHandleString' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_BreakEnumHandleToStrings, EnumeratorString) == 0x000020, "Member 'CoreGameFunctionLibrary_BreakEnumHandleToStrings::EnumeratorString' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CallEventByHandle
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_CallEventByHandle final
{
public:
	struct FLatentEventHandle                     EventHandle;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_CallEventByHandle) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CallEventByHandle");
static_assert(sizeof(CoreGameFunctionLibrary_CallEventByHandle) == 0x000018, "Wrong size on CoreGameFunctionLibrary_CallEventByHandle");
static_assert(offsetof(CoreGameFunctionLibrary_CallEventByHandle, EventHandle) == 0x000000, "Member 'CoreGameFunctionLibrary_CallEventByHandle::EventHandle' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CallEventByHandle, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_CallEventByHandle::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CallObjectEventByHandle
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_CallObjectEventByHandle final
{
public:
	struct FLatentObjectEventHandle               EventHandle;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_CallObjectEventByHandle) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CallObjectEventByHandle");
static_assert(sizeof(CoreGameFunctionLibrary_CallObjectEventByHandle) == 0x000020, "Wrong size on CoreGameFunctionLibrary_CallObjectEventByHandle");
static_assert(offsetof(CoreGameFunctionLibrary_CallObjectEventByHandle, EventHandle) == 0x000000, "Member 'CoreGameFunctionLibrary_CallObjectEventByHandle::EventHandle' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CallObjectEventByHandle, Object) == 0x000010, "Member 'CoreGameFunctionLibrary_CallObjectEventByHandle::Object' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CallObjectEventByHandle, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_CallObjectEventByHandle::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CapsuleOverlapComponents
// 0x0060 (0x0060 - 0x0000)
struct CoreGameFunctionLibrary_CapsuleOverlapComponents final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsuleLocation;                                   // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsuleAxis;                                       // 0x0014(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UActorComponent>            ClassFilter;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OutComponents;                                     // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_CapsuleOverlapComponents) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CapsuleOverlapComponents");
static_assert(sizeof(CoreGameFunctionLibrary_CapsuleOverlapComponents) == 0x000060, "Wrong size on CoreGameFunctionLibrary_CapsuleOverlapComponents");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, WorldContextObject) == 0x000000, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, CapsuleLocation) == 0x000008, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::CapsuleLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, CapsuleAxis) == 0x000014, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::CapsuleAxis' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, Radius) == 0x000020, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::Radius' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, HalfHeight) == 0x000024, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::HalfHeight' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, TraceChannel) == 0x000028, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::TraceChannel' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, ClassFilter) == 0x000030, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, ActorsToIgnore) == 0x000038, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, OutComponents) == 0x000048, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::OutComponents' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CapsuleOverlapComponents, ReturnValue) == 0x000058, "Member 'CoreGameFunctionLibrary_CapsuleOverlapComponents::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ClampAxes2D
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_ClampAxes2D final
{
public:
	struct FVector2D                              Vector;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MinAxisValues;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MaxAxisValues;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ClampAxes2D) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_ClampAxes2D");
static_assert(sizeof(CoreGameFunctionLibrary_ClampAxes2D) == 0x000020, "Wrong size on CoreGameFunctionLibrary_ClampAxes2D");
static_assert(offsetof(CoreGameFunctionLibrary_ClampAxes2D, Vector) == 0x000000, "Member 'CoreGameFunctionLibrary_ClampAxes2D::Vector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClampAxes2D, MinAxisValues) == 0x000008, "Member 'CoreGameFunctionLibrary_ClampAxes2D::MinAxisValues' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClampAxes2D, MaxAxisValues) == 0x000010, "Member 'CoreGameFunctionLibrary_ClampAxes2D::MaxAxisValues' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClampAxes2D, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_ClampAxes2D::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ClampPointToLozenge2D
// 0x0024 (0x0024 - 0x0000)
struct CoreGameFunctionLibrary_ClampPointToLozenge2D final
{
public:
	struct FVector2D                              Point;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LozengeCenter;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LozengeHalfExtents;                                // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LozengeRadius;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x001C(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ClampPointToLozenge2D) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_ClampPointToLozenge2D");
static_assert(sizeof(CoreGameFunctionLibrary_ClampPointToLozenge2D) == 0x000024, "Wrong size on CoreGameFunctionLibrary_ClampPointToLozenge2D");
static_assert(offsetof(CoreGameFunctionLibrary_ClampPointToLozenge2D, Point) == 0x000000, "Member 'CoreGameFunctionLibrary_ClampPointToLozenge2D::Point' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClampPointToLozenge2D, LozengeCenter) == 0x000008, "Member 'CoreGameFunctionLibrary_ClampPointToLozenge2D::LozengeCenter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClampPointToLozenge2D, LozengeHalfExtents) == 0x000010, "Member 'CoreGameFunctionLibrary_ClampPointToLozenge2D::LozengeHalfExtents' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClampPointToLozenge2D, LozengeRadius) == 0x000018, "Member 'CoreGameFunctionLibrary_ClampPointToLozenge2D::LozengeRadius' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClampPointToLozenge2D, ReturnValue) == 0x00001C, "Member 'CoreGameFunctionLibrary_ClampPointToLozenge2D::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ClearStaticMeshOverrideColorsForVertices
// 0x0068 (0x0068 - 0x0000)
struct CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   VertexIndices;                                     // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices");
static_assert(sizeof(CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices) == 0x000068, "Wrong size on CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices");
static_assert(offsetof(CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices, StaticMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices, LODIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices::LODIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices, VertexIndices) == 0x000010, "Member 'CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices::VertexIndices' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices, ReturnValue) == 0x000060, "Member 'CoreGameFunctionLibrary_ClearStaticMeshOverrideColorsForVertices::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ClosestPointOnBox
// 0x0034 (0x0034 - 0x0000)
struct CoreGameFunctionLibrary_ClosestPointOnBox final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x001C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0028(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ClosestPointOnBox) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_ClosestPointOnBox");
static_assert(sizeof(CoreGameFunctionLibrary_ClosestPointOnBox) == 0x000034, "Wrong size on CoreGameFunctionLibrary_ClosestPointOnBox");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointOnBox, Box) == 0x000000, "Member 'CoreGameFunctionLibrary_ClosestPointOnBox::Box' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointOnBox, Point) == 0x00001C, "Member 'CoreGameFunctionLibrary_ClosestPointOnBox::Point' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointOnBox, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_ClosestPointOnBox::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ClosestPointsOnSegments
// 0x0048 (0x0048 - 0x0000)
struct CoreGameFunctionLibrary_ClosestPointsOnSegments final
{
public:
	struct FVector                                SegmentAStart;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentAEnd;                                       // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentBStart;                                     // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentBEnd;                                       // 0x0024(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClosestOnA;                                        // 0x0030(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClosestOnB;                                        // 0x003C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ClosestPointsOnSegments) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_ClosestPointsOnSegments");
static_assert(sizeof(CoreGameFunctionLibrary_ClosestPointsOnSegments) == 0x000048, "Wrong size on CoreGameFunctionLibrary_ClosestPointsOnSegments");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointsOnSegments, SegmentAStart) == 0x000000, "Member 'CoreGameFunctionLibrary_ClosestPointsOnSegments::SegmentAStart' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointsOnSegments, SegmentAEnd) == 0x00000C, "Member 'CoreGameFunctionLibrary_ClosestPointsOnSegments::SegmentAEnd' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointsOnSegments, SegmentBStart) == 0x000018, "Member 'CoreGameFunctionLibrary_ClosestPointsOnSegments::SegmentBStart' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointsOnSegments, SegmentBEnd) == 0x000024, "Member 'CoreGameFunctionLibrary_ClosestPointsOnSegments::SegmentBEnd' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointsOnSegments, ClosestOnA) == 0x000030, "Member 'CoreGameFunctionLibrary_ClosestPointsOnSegments::ClosestOnA' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ClosestPointsOnSegments, ClosestOnB) == 0x00003C, "Member 'CoreGameFunctionLibrary_ClosestPointsOnSegments::ClosestOnB' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ComponentOverlapActors
// 0x0038 (0x0038 - 0x0000)
struct CoreGameFunctionLibrary_ComponentOverlapActors final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_ComponentOverlapActors) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_ComponentOverlapActors");
static_assert(sizeof(CoreGameFunctionLibrary_ComponentOverlapActors) == 0x000038, "Wrong size on CoreGameFunctionLibrary_ComponentOverlapActors");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapActors, Component) == 0x000000, "Member 'CoreGameFunctionLibrary_ComponentOverlapActors::Component' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapActors, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_ComponentOverlapActors::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapActors, ActorsToIgnore) == 0x000010, "Member 'CoreGameFunctionLibrary_ComponentOverlapActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapActors, OutActors) == 0x000020, "Member 'CoreGameFunctionLibrary_ComponentOverlapActors::OutActors' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapActors, ReturnValue) == 0x000030, "Member 'CoreGameFunctionLibrary_ComponentOverlapActors::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ComponentOverlapComponents
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_ComponentOverlapComponents final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OutComponents;                                     // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_ComponentOverlapComponents) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_ComponentOverlapComponents");
static_assert(sizeof(CoreGameFunctionLibrary_ComponentOverlapComponents) == 0x000030, "Wrong size on CoreGameFunctionLibrary_ComponentOverlapComponents");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapComponents, Component) == 0x000000, "Member 'CoreGameFunctionLibrary_ComponentOverlapComponents::Component' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapComponents, ActorsToIgnore) == 0x000008, "Member 'CoreGameFunctionLibrary_ComponentOverlapComponents::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapComponents, OutComponents) == 0x000018, "Member 'CoreGameFunctionLibrary_ComponentOverlapComponents::OutComponents' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComponentOverlapComponents, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_ComponentOverlapComponents::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ComputeHorizontalFOV
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_ComputeHorizontalFOV final
{
public:
	float                                         VerticalFOV;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ViewportSize;                                      // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ComputeHorizontalFOV) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_ComputeHorizontalFOV");
static_assert(sizeof(CoreGameFunctionLibrary_ComputeHorizontalFOV) == 0x000010, "Wrong size on CoreGameFunctionLibrary_ComputeHorizontalFOV");
static_assert(offsetof(CoreGameFunctionLibrary_ComputeHorizontalFOV, VerticalFOV) == 0x000000, "Member 'CoreGameFunctionLibrary_ComputeHorizontalFOV::VerticalFOV' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComputeHorizontalFOV, ViewportSize) == 0x000004, "Member 'CoreGameFunctionLibrary_ComputeHorizontalFOV::ViewportSize' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComputeHorizontalFOV, ReturnValue) == 0x00000C, "Member 'CoreGameFunctionLibrary_ComputeHorizontalFOV::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ComputeVerticalFOV
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_ComputeVerticalFOV final
{
public:
	float                                         HorizontalFOV;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ViewportSize;                                      // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ComputeVerticalFOV) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_ComputeVerticalFOV");
static_assert(sizeof(CoreGameFunctionLibrary_ComputeVerticalFOV) == 0x000010, "Wrong size on CoreGameFunctionLibrary_ComputeVerticalFOV");
static_assert(offsetof(CoreGameFunctionLibrary_ComputeVerticalFOV, HorizontalFOV) == 0x000000, "Member 'CoreGameFunctionLibrary_ComputeVerticalFOV::HorizontalFOV' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComputeVerticalFOV, ViewportSize) == 0x000004, "Member 'CoreGameFunctionLibrary_ComputeVerticalFOV::ViewportSize' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ComputeVerticalFOV, ReturnValue) == 0x00000C, "Member 'CoreGameFunctionLibrary_ComputeVerticalFOV::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ConditionalDestroyObject
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_ConditionalDestroyObject final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_ConditionalDestroyObject) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_ConditionalDestroyObject");
static_assert(sizeof(CoreGameFunctionLibrary_ConditionalDestroyObject) == 0x000010, "Wrong size on CoreGameFunctionLibrary_ConditionalDestroyObject");
static_assert(offsetof(CoreGameFunctionLibrary_ConditionalDestroyObject, Object) == 0x000000, "Member 'CoreGameFunctionLibrary_ConditionalDestroyObject::Object' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ConditionalDestroyObject, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_ConditionalDestroyObject::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CopyCustomPrimitiveData
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_CopyCustomPrimitiveData final
{
public:
	class UPrimitiveComponent*                    SourcePrimitiveComponent;                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    TargetPrimitiveComponent;                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetDefaults;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_CopyCustomPrimitiveData) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CopyCustomPrimitiveData");
static_assert(sizeof(CoreGameFunctionLibrary_CopyCustomPrimitiveData) == 0x000018, "Wrong size on CoreGameFunctionLibrary_CopyCustomPrimitiveData");
static_assert(offsetof(CoreGameFunctionLibrary_CopyCustomPrimitiveData, SourcePrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_CopyCustomPrimitiveData::SourcePrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CopyCustomPrimitiveData, TargetPrimitiveComponent) == 0x000008, "Member 'CoreGameFunctionLibrary_CopyCustomPrimitiveData::TargetPrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CopyCustomPrimitiveData, bSetDefaults) == 0x000010, "Member 'CoreGameFunctionLibrary_CopyCustomPrimitiveData::bSetDefaults' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CountBits
// 0x0008 (0x0008 - 0x0000)
struct CoreGameFunctionLibrary_CountBits final
{
public:
	int32                                         Bits;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CountBits) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_CountBits");
static_assert(sizeof(CoreGameFunctionLibrary_CountBits) == 0x000008, "Wrong size on CoreGameFunctionLibrary_CountBits");
static_assert(offsetof(CoreGameFunctionLibrary_CountBits, Bits) == 0x000000, "Member 'CoreGameFunctionLibrary_CountBits::Bits' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CountBits, ReturnValue) == 0x000004, "Member 'CoreGameFunctionLibrary_CountBits::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateAudioComponentAttached
// 0x0040 (0x0040 - 0x0000)
struct CoreGameFunctionLibrary_CreateAudioComponentAttached final
{
public:
	class USoundBase*                             Sound;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0038(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateAudioComponentAttached) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CreateAudioComponentAttached");
static_assert(sizeof(CoreGameFunctionLibrary_CreateAudioComponentAttached) == 0x000040, "Wrong size on CoreGameFunctionLibrary_CreateAudioComponentAttached");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, Sound) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::Sound' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, AttachToComponent) == 0x000008, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, AttachPointName) == 0x000010, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, Location) == 0x000018, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::Location' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, Rotation) == 0x000024, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::Rotation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, LocationType) == 0x000030, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::LocationType' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, bStopWhenAttachedToDestroyed) == 0x000031, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, bAutoDestroy) == 0x000032, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateAudioComponentAttached, ReturnValue) == 0x000038, "Member 'CoreGameFunctionLibrary_CreateAudioComponentAttached::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateCompositeSkeletalMesh
// 0x0038 (0x0038 - 0x0000)
struct CoreGameFunctionLibrary_CreateCompositeSkeletalMesh final
{
public:
	class FString                                 PackagePath;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MeshName;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  SkeletalMeshes;                                    // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateCompositeSkeletalMesh) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CreateCompositeSkeletalMesh");
static_assert(sizeof(CoreGameFunctionLibrary_CreateCompositeSkeletalMesh) == 0x000038, "Wrong size on CoreGameFunctionLibrary_CreateCompositeSkeletalMesh");
static_assert(offsetof(CoreGameFunctionLibrary_CreateCompositeSkeletalMesh, PackagePath) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateCompositeSkeletalMesh::PackagePath' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateCompositeSkeletalMesh, MeshName) == 0x000010, "Member 'CoreGameFunctionLibrary_CreateCompositeSkeletalMesh::MeshName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateCompositeSkeletalMesh, SkeletalMeshes) == 0x000020, "Member 'CoreGameFunctionLibrary_CreateCompositeSkeletalMesh::SkeletalMeshes' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateCompositeSkeletalMesh, ReturnValue) == 0x000030, "Member 'CoreGameFunctionLibrary_CreateCompositeSkeletalMesh::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateEventHandle
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_CreateEventHandle final
{
public:
	TDelegate<void()>                             Event;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLatentEventHandle                     ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateEventHandle) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CreateEventHandle");
static_assert(sizeof(CoreGameFunctionLibrary_CreateEventHandle) == 0x000020, "Wrong size on CoreGameFunctionLibrary_CreateEventHandle");
static_assert(offsetof(CoreGameFunctionLibrary_CreateEventHandle, Event) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateEventHandle::Event' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateEventHandle, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_CreateEventHandle::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateIntRectangle
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_CreateIntRectangle final
{
public:
	struct FIntPoint                              DesiredMin;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              DesiredMax;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntRectangle                          ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateIntRectangle) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_CreateIntRectangle");
static_assert(sizeof(CoreGameFunctionLibrary_CreateIntRectangle) == 0x000020, "Wrong size on CoreGameFunctionLibrary_CreateIntRectangle");
static_assert(offsetof(CoreGameFunctionLibrary_CreateIntRectangle, DesiredMin) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateIntRectangle::DesiredMin' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateIntRectangle, DesiredMax) == 0x000008, "Member 'CoreGameFunctionLibrary_CreateIntRectangle::DesiredMax' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateIntRectangle, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_CreateIntRectangle::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateObjectEventHandle
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_CreateObjectEventHandle final
{
public:
	TDelegate<void(class UObject* Object)>        Event;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FLatentObjectEventHandle               ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateObjectEventHandle) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CreateObjectEventHandle");
static_assert(sizeof(CoreGameFunctionLibrary_CreateObjectEventHandle) == 0x000020, "Wrong size on CoreGameFunctionLibrary_CreateObjectEventHandle");
static_assert(offsetof(CoreGameFunctionLibrary_CreateObjectEventHandle, Event) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateObjectEventHandle::Event' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateObjectEventHandle, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_CreateObjectEventHandle::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateResizedTextureFromRenderTarget
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredWidth;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DesiredHeight;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget");
static_assert(sizeof(CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget) == 0x000018, "Wrong size on CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget");
static_assert(offsetof(CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget, RenderTarget) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget::RenderTarget' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget, DesiredWidth) == 0x000008, "Member 'CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget::DesiredWidth' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget, DesiredHeight) == 0x00000C, "Member 'CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget::DesiredHeight' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_CreateResizedTextureFromRenderTarget::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateSceneCaptureWorld
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_CreateSceneCaptureWorld final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WorldName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsTick;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateSceneCaptureWorld) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CreateSceneCaptureWorld");
static_assert(sizeof(CoreGameFunctionLibrary_CreateSceneCaptureWorld) == 0x000028, "Wrong size on CoreGameFunctionLibrary_CreateSceneCaptureWorld");
static_assert(offsetof(CoreGameFunctionLibrary_CreateSceneCaptureWorld, WorldContextObject) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateSceneCaptureWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateSceneCaptureWorld, WorldName) == 0x000008, "Member 'CoreGameFunctionLibrary_CreateSceneCaptureWorld::WorldName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateSceneCaptureWorld, bWantsTick) == 0x000010, "Member 'CoreGameFunctionLibrary_CreateSceneCaptureWorld::bWantsTick' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateSceneCaptureWorld, RenderTarget) == 0x000018, "Member 'CoreGameFunctionLibrary_CreateSceneCaptureWorld::RenderTarget' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateSceneCaptureWorld, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_CreateSceneCaptureWorld::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateStaticMeshesFromPhysicsAssetHulls
// 0x0058 (0x0058 - 0x0000)
struct CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls final
{
public:
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergeMirroredMeshes;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExcludeBones;                                      // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubDirectory;                                      // 0x0038(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    ReturnValue;                                       // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls");
static_assert(sizeof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls) == 0x000058, "Wrong size on CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls");
static_assert(offsetof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls, PhysicsAsset) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls, Material) == 0x000008, "Member 'CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls::Material' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls, bMergeMirroredMeshes) == 0x000010, "Member 'CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls::bMergeMirroredMeshes' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls, ExcludeBones) == 0x000018, "Member 'CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls::ExcludeBones' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls, Prefix) == 0x000028, "Member 'CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls::Prefix' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls, SubDirectory) == 0x000038, "Member 'CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls::SubDirectory' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls, ReturnValue) == 0x000048, "Member 'CoreGameFunctionLibrary_CreateStaticMeshesFromPhysicsAssetHulls::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.CreateTextureFromRenderTarget
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_CreateTextureFromRenderTarget final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_CreateTextureFromRenderTarget) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_CreateTextureFromRenderTarget");
static_assert(sizeof(CoreGameFunctionLibrary_CreateTextureFromRenderTarget) == 0x000010, "Wrong size on CoreGameFunctionLibrary_CreateTextureFromRenderTarget");
static_assert(offsetof(CoreGameFunctionLibrary_CreateTextureFromRenderTarget, RenderTarget) == 0x000000, "Member 'CoreGameFunctionLibrary_CreateTextureFromRenderTarget::RenderTarget' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_CreateTextureFromRenderTarget, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_CreateTextureFromRenderTarget::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.DestroySceneCaptureWorld
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_DestroySceneCaptureWorld final
{
public:
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_DestroySceneCaptureWorld) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_DestroySceneCaptureWorld");
static_assert(sizeof(CoreGameFunctionLibrary_DestroySceneCaptureWorld) == 0x000010, "Wrong size on CoreGameFunctionLibrary_DestroySceneCaptureWorld");
static_assert(offsetof(CoreGameFunctionLibrary_DestroySceneCaptureWorld, SceneCaptureComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_DestroySceneCaptureWorld::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_DestroySceneCaptureWorld, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_DestroySceneCaptureWorld::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.DisableBodyCollision
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_DisableBodyCollision final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecreatePhysics;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_DisableBodyCollision) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_DisableBodyCollision");
static_assert(sizeof(CoreGameFunctionLibrary_DisableBodyCollision) == 0x000018, "Wrong size on CoreGameFunctionLibrary_DisableBodyCollision");
static_assert(offsetof(CoreGameFunctionLibrary_DisableBodyCollision, SkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_DisableBodyCollision::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_DisableBodyCollision, BoneName) == 0x000008, "Member 'CoreGameFunctionLibrary_DisableBodyCollision::BoneName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_DisableBodyCollision, bRecreatePhysics) == 0x000010, "Member 'CoreGameFunctionLibrary_DisableBodyCollision::bRecreatePhysics' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_DisableBodyCollision, ReturnValue) == 0x000011, "Member 'CoreGameFunctionLibrary_DisableBodyCollision::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.DuplicateObject
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_DuplicateObject final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SourceObject;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_DuplicateObject) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_DuplicateObject");
static_assert(sizeof(CoreGameFunctionLibrary_DuplicateObject) == 0x000018, "Wrong size on CoreGameFunctionLibrary_DuplicateObject");
static_assert(offsetof(CoreGameFunctionLibrary_DuplicateObject, WorldContextObject) == 0x000000, "Member 'CoreGameFunctionLibrary_DuplicateObject::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_DuplicateObject, SourceObject) == 0x000008, "Member 'CoreGameFunctionLibrary_DuplicateObject::SourceObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_DuplicateObject, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_DuplicateObject::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.FillCylinderMeshBuffersFromSplineComponent
// 0x0060 (0x0060 - 0x0000)
struct CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent final
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SegmentLength;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TextureArea;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RingVertexCount;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTrimFromStart;                                    // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Vertices;                                          // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 Triangles;                                         // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Normals;                                           // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FVector2D>                      TexCoords;                                         // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent");
static_assert(sizeof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent) == 0x000060, "Wrong size on CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, SplineComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::SplineComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, Radius) == 0x000008, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::Radius' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, SegmentLength) == 0x00000C, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::SegmentLength' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, TextureArea) == 0x000010, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::TextureArea' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, RingVertexCount) == 0x000018, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::RingVertexCount' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, bTrimFromStart) == 0x00001C, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::bTrimFromStart' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, Vertices) == 0x000020, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::Vertices' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, Triangles) == 0x000030, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::Triangles' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, Normals) == 0x000040, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::Normals' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent, TexCoords) == 0x000050, "Member 'CoreGameFunctionLibrary_FillCylinderMeshBuffersFromSplineComponent::TexCoords' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.FindBestAxisVectors
// 0x0024 (0x0024 - 0x0000)
struct CoreGameFunctionLibrary_FindBestAxisVectors final
{
public:
	struct FVector                                Vector;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutAxis1;                                          // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutAxis2;                                          // 0x0018(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_FindBestAxisVectors) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_FindBestAxisVectors");
static_assert(sizeof(CoreGameFunctionLibrary_FindBestAxisVectors) == 0x000024, "Wrong size on CoreGameFunctionLibrary_FindBestAxisVectors");
static_assert(offsetof(CoreGameFunctionLibrary_FindBestAxisVectors, Vector) == 0x000000, "Member 'CoreGameFunctionLibrary_FindBestAxisVectors::Vector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FindBestAxisVectors, OutAxis1) == 0x00000C, "Member 'CoreGameFunctionLibrary_FindBestAxisVectors::OutAxis1' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_FindBestAxisVectors, OutAxis2) == 0x000018, "Member 'CoreGameFunctionLibrary_FindBestAxisVectors::OutAxis2' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ForceRecreatePhysicsState
// 0x0008 (0x0008 - 0x0000)
struct CoreGameFunctionLibrary_ForceRecreatePhysicsState final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ForceRecreatePhysicsState) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_ForceRecreatePhysicsState");
static_assert(sizeof(CoreGameFunctionLibrary_ForceRecreatePhysicsState) == 0x000008, "Wrong size on CoreGameFunctionLibrary_ForceRecreatePhysicsState");
static_assert(offsetof(CoreGameFunctionLibrary_ForceRecreatePhysicsState, SkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_ForceRecreatePhysicsState::SkeletalMeshComponent' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ForceUpdateBounds
// 0x0008 (0x0008 - 0x0000)
struct CoreGameFunctionLibrary_ForceUpdateBounds final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_ForceUpdateBounds) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_ForceUpdateBounds");
static_assert(sizeof(CoreGameFunctionLibrary_ForceUpdateBounds) == 0x000008, "Wrong size on CoreGameFunctionLibrary_ForceUpdateBounds");
static_assert(offsetof(CoreGameFunctionLibrary_ForceUpdateBounds, SkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_ForceUpdateBounds::SkeletalMeshComponent' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetActorByNameInSubLevel
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetActorByNameInSubLevel final
{
public:
	class ULevel*                                 SubLevel;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetActorByNameInSubLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetActorByNameInSubLevel");
static_assert(sizeof(CoreGameFunctionLibrary_GetActorByNameInSubLevel) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetActorByNameInSubLevel");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorByNameInSubLevel, SubLevel) == 0x000000, "Member 'CoreGameFunctionLibrary_GetActorByNameInSubLevel::SubLevel' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorByNameInSubLevel, ActorName) == 0x000008, "Member 'CoreGameFunctionLibrary_GetActorByNameInSubLevel::ActorName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorByNameInSubLevel, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetActorByNameInSubLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetActorComponentByName
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetActorComponentByName final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComponentName;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetActorComponentByName) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetActorComponentByName");
static_assert(sizeof(CoreGameFunctionLibrary_GetActorComponentByName) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetActorComponentByName");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorComponentByName, Actor) == 0x000000, "Member 'CoreGameFunctionLibrary_GetActorComponentByName::Actor' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorComponentByName, ComponentName) == 0x000008, "Member 'CoreGameFunctionLibrary_GetActorComponentByName::ComponentName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorComponentByName, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetActorComponentByName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetActorLevel
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_GetActorLevel final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetActorLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetActorLevel");
static_assert(sizeof(CoreGameFunctionLibrary_GetActorLevel) == 0x000010, "Wrong size on CoreGameFunctionLibrary_GetActorLevel");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorLevel, Actor) == 0x000000, "Member 'CoreGameFunctionLibrary_GetActorLevel::Actor' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorLevel, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetActorLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetActorOfClassInSubLevel
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetActorOfClassInSubLevel final
{
public:
	class ULevel*                                 SubLevel;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetActorOfClassInSubLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetActorOfClassInSubLevel");
static_assert(sizeof(CoreGameFunctionLibrary_GetActorOfClassInSubLevel) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetActorOfClassInSubLevel");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassInSubLevel, SubLevel) == 0x000000, "Member 'CoreGameFunctionLibrary_GetActorOfClassInSubLevel::SubLevel' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassInSubLevel, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_GetActorOfClassInSubLevel::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassInSubLevel, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetActorOfClassInSubLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetActorOfClassInSubLevelByName
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubLevelName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName");
static_assert(sizeof(CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName, WorldContextObject) == 0x000000, "Member 'CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName, SubLevelName) == 0x000008, "Member 'CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName::SubLevelName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName, ClassFilter) == 0x000010, "Member 'CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_GetActorOfClassInSubLevelByName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetActorOfClassWithTagInSubLevel
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel final
{
public:
	class ULevel*                                 SubLevel;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorTag;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel");
static_assert(sizeof(CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel, SubLevel) == 0x000000, "Member 'CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel::SubLevel' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel, ActorTag) == 0x000010, "Member 'CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel::ActorTag' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_GetActorOfClassWithTagInSubLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetAllActorsOfClassInSubLevel
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel final
{
public:
	class ULevel*                                 SubLevel;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel");
static_assert(sizeof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel");
static_assert(offsetof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel, SubLevel) == 0x000000, "Member 'CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel::SubLevel' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetAllActorsOfClassInSubLevelByName
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubLevelName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName");
static_assert(sizeof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName) == 0x000028, "Wrong size on CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName");
static_assert(offsetof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName, WorldContextObject) == 0x000000, "Member 'CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName, SubLevelName) == 0x000008, "Member 'CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName::SubLevelName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName, ClassFilter) == 0x000010, "Member 'CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_GetAllActorsOfClassInSubLevelByName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetAngleAroundAxis
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_GetAngleAroundAxis final
{
public:
	struct FVector                                SourceVector;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetAngleAroundAxis) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetAngleAroundAxis");
static_assert(sizeof(CoreGameFunctionLibrary_GetAngleAroundAxis) == 0x000028, "Wrong size on CoreGameFunctionLibrary_GetAngleAroundAxis");
static_assert(offsetof(CoreGameFunctionLibrary_GetAngleAroundAxis, SourceVector) == 0x000000, "Member 'CoreGameFunctionLibrary_GetAngleAroundAxis::SourceVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetAngleAroundAxis, TargetVector) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetAngleAroundAxis::TargetVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetAngleAroundAxis, Axis) == 0x000018, "Member 'CoreGameFunctionLibrary_GetAngleAroundAxis::Axis' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetAngleAroundAxis, ReturnValue) == 0x000024, "Member 'CoreGameFunctionLibrary_GetAngleAroundAxis::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetBlueprintClasses
// 0x0038 (0x0038 - 0x0000)
struct CoreGameFunctionLibrary_GetBlueprintClasses final
{
public:
	class UClass*                                 BaseClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Folder;                                            // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetBlueprintClasses) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetBlueprintClasses");
static_assert(sizeof(CoreGameFunctionLibrary_GetBlueprintClasses) == 0x000038, "Wrong size on CoreGameFunctionLibrary_GetBlueprintClasses");
static_assert(offsetof(CoreGameFunctionLibrary_GetBlueprintClasses, BaseClass) == 0x000000, "Member 'CoreGameFunctionLibrary_GetBlueprintClasses::BaseClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBlueprintClasses, Name_0) == 0x000008, "Member 'CoreGameFunctionLibrary_GetBlueprintClasses::Name_0' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBlueprintClasses, Folder) == 0x000018, "Member 'CoreGameFunctionLibrary_GetBlueprintClasses::Folder' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBlueprintClasses, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_GetBlueprintClasses::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetBodyBoneNamesFromPhysicsAsset
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset final
{
public:
	class UPhysicsAsset*                          PhysicsAsset;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset");
static_assert(sizeof(CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset");
static_assert(offsetof(CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset, PhysicsAsset) == 0x000000, "Member 'CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset::PhysicsAsset' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetBodyBoneNamesFromPhysicsAsset::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetBoxContainmentOffset
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_GetBoxContainmentOffset final
{
public:
	struct FVector                                ContentOffset;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ContentHalfExtent;                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ContainerHalfExtent;                               // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetBoxContainmentOffset) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetBoxContainmentOffset");
static_assert(sizeof(CoreGameFunctionLibrary_GetBoxContainmentOffset) == 0x000030, "Wrong size on CoreGameFunctionLibrary_GetBoxContainmentOffset");
static_assert(offsetof(CoreGameFunctionLibrary_GetBoxContainmentOffset, ContentOffset) == 0x000000, "Member 'CoreGameFunctionLibrary_GetBoxContainmentOffset::ContentOffset' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBoxContainmentOffset, ContentHalfExtent) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetBoxContainmentOffset::ContentHalfExtent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBoxContainmentOffset, ContainerHalfExtent) == 0x000018, "Member 'CoreGameFunctionLibrary_GetBoxContainmentOffset::ContainerHalfExtent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBoxContainmentOffset, ReturnValue) == 0x000024, "Member 'CoreGameFunctionLibrary_GetBoxContainmentOffset::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetBytesFromInt
// 0x0008 (0x0008 - 0x0000)
struct CoreGameFunctionLibrary_GetBytesFromInt final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutByteA;                                          // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutByteB;                                          // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutByteC;                                          // 0x0006(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutByteD;                                          // 0x0007(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetBytesFromInt) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetBytesFromInt");
static_assert(sizeof(CoreGameFunctionLibrary_GetBytesFromInt) == 0x000008, "Wrong size on CoreGameFunctionLibrary_GetBytesFromInt");
static_assert(offsetof(CoreGameFunctionLibrary_GetBytesFromInt, Value) == 0x000000, "Member 'CoreGameFunctionLibrary_GetBytesFromInt::Value' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBytesFromInt, OutByteA) == 0x000004, "Member 'CoreGameFunctionLibrary_GetBytesFromInt::OutByteA' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBytesFromInt, OutByteB) == 0x000005, "Member 'CoreGameFunctionLibrary_GetBytesFromInt::OutByteB' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBytesFromInt, OutByteC) == 0x000006, "Member 'CoreGameFunctionLibrary_GetBytesFromInt::OutByteC' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetBytesFromInt, OutByteD) == 0x000007, "Member 'CoreGameFunctionLibrary_GetBytesFromInt::OutByteD' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetChildComponentByClassAndSuffix
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix final
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Suffix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0020(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix");
static_assert(sizeof(CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix) == 0x000028, "Wrong size on CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix, SceneComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix::SceneComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix, Suffix) == 0x000010, "Member 'CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix::Suffix' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_GetChildComponentByClassAndSuffix::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetChildComponentByTag
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetChildComponentByTag final
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetChildComponentByTag) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetChildComponentByTag");
static_assert(sizeof(CoreGameFunctionLibrary_GetChildComponentByTag) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetChildComponentByTag");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentByTag, SceneComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetChildComponentByTag::SceneComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentByTag, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_GetChildComponentByTag::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentByTag, Tag) == 0x000010, "Member 'CoreGameFunctionLibrary_GetChildComponentByTag::Tag' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentByTag, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_GetChildComponentByTag::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetChildComponentsByClass
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_GetChildComponentsByClass final
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeDescendants;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                ReturnValue;                                       // 0x0018(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetChildComponentsByClass) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetChildComponentsByClass");
static_assert(sizeof(CoreGameFunctionLibrary_GetChildComponentsByClass) == 0x000028, "Wrong size on CoreGameFunctionLibrary_GetChildComponentsByClass");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentsByClass, SceneComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetChildComponentsByClass::SceneComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentsByClass, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_GetChildComponentsByClass::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentsByClass, bIncludeDescendants) == 0x000010, "Member 'CoreGameFunctionLibrary_GetChildComponentsByClass::bIncludeDescendants' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentsByClass, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_GetChildComponentsByClass::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetChildComponentsByClassFromArray
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_GetChildComponentsByClassFromArray final
{
public:
	TArray<class USceneComponent*>                SceneComponents;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ClassFilter;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeDescendants;                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                ReturnValue;                                       // 0x0020(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetChildComponentsByClassFromArray) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetChildComponentsByClassFromArray");
static_assert(sizeof(CoreGameFunctionLibrary_GetChildComponentsByClassFromArray) == 0x000030, "Wrong size on CoreGameFunctionLibrary_GetChildComponentsByClassFromArray");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentsByClassFromArray, SceneComponents) == 0x000000, "Member 'CoreGameFunctionLibrary_GetChildComponentsByClassFromArray::SceneComponents' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentsByClassFromArray, ClassFilter) == 0x000010, "Member 'CoreGameFunctionLibrary_GetChildComponentsByClassFromArray::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentsByClassFromArray, bIncludeDescendants) == 0x000018, "Member 'CoreGameFunctionLibrary_GetChildComponentsByClassFromArray::bIncludeDescendants' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetChildComponentsByClassFromArray, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_GetChildComponentsByClassFromArray::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetClassComponentTemplate
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetClassComponentTemplate final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ComponentClass;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0010(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetClassComponentTemplate) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetClassComponentTemplate");
static_assert(sizeof(CoreGameFunctionLibrary_GetClassComponentTemplate) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetClassComponentTemplate");
static_assert(offsetof(CoreGameFunctionLibrary_GetClassComponentTemplate, ActorClass) == 0x000000, "Member 'CoreGameFunctionLibrary_GetClassComponentTemplate::ActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetClassComponentTemplate, ComponentClass) == 0x000008, "Member 'CoreGameFunctionLibrary_GetClassComponentTemplate::ComponentClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetClassComponentTemplate, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetClassComponentTemplate::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetClassComponentTemplateByName
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetClassComponentTemplateByName final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ComponentName;                                     // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetClassComponentTemplateByName) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetClassComponentTemplateByName");
static_assert(sizeof(CoreGameFunctionLibrary_GetClassComponentTemplateByName) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetClassComponentTemplateByName");
static_assert(offsetof(CoreGameFunctionLibrary_GetClassComponentTemplateByName, ActorClass) == 0x000000, "Member 'CoreGameFunctionLibrary_GetClassComponentTemplateByName::ActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetClassComponentTemplateByName, ComponentName) == 0x000008, "Member 'CoreGameFunctionLibrary_GetClassComponentTemplateByName::ComponentName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetClassComponentTemplateByName, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_GetClassComponentTemplateByName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetClassDefaultObject
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_GetClassDefaultObject final
{
public:
	class UClass*                                 Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetClassDefaultObject) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetClassDefaultObject");
static_assert(sizeof(CoreGameFunctionLibrary_GetClassDefaultObject) == 0x000010, "Wrong size on CoreGameFunctionLibrary_GetClassDefaultObject");
static_assert(offsetof(CoreGameFunctionLibrary_GetClassDefaultObject, Class_0) == 0x000000, "Member 'CoreGameFunctionLibrary_GetClassDefaultObject::Class_0' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetClassDefaultObject, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetClassDefaultObject::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetCurveValueSumOverTimeInterval
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval final
{
public:
	const class UCurveFloat*                      CurveFloat;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SampleCount;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleInterval;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval");
static_assert(sizeof(CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval");
static_assert(offsetof(CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval, CurveFloat) == 0x000000, "Member 'CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval::CurveFloat' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval, SampleCount) == 0x000008, "Member 'CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval::SampleCount' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval, SampleInterval) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval::SampleInterval' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetCurveValueSumOverTimeInterval::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetCustomPrimitiveDataFloat
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat");
static_assert(sizeof(CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat) == 0x000010, "Wrong size on CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat");
static_assert(offsetof(CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat, PrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat, DataIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat::DataIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat, ReturnValue) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetCustomPrimitiveDataFloat::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetCustomPrimitiveDataVector4
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4 final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4");
static_assert(sizeof(CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4");
static_assert(offsetof(CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4, PrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4, DataIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4::DataIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetCustomPrimitiveDataVector4::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetDataTableRowCount
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_GetDataTableRowCount final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetDataTableRowCount) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetDataTableRowCount");
static_assert(sizeof(CoreGameFunctionLibrary_GetDataTableRowCount) == 0x000010, "Wrong size on CoreGameFunctionLibrary_GetDataTableRowCount");
static_assert(offsetof(CoreGameFunctionLibrary_GetDataTableRowCount, DataTable) == 0x000000, "Member 'CoreGameFunctionLibrary_GetDataTableRowCount::DataTable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetDataTableRowCount, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetDataTableRowCount::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetDistanceAlongPathAtElapsedTime
// 0x0014 (0x0014 - 0x0000)
struct CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime final
{
public:
	float                                         TotalPathLength;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTime;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime");
static_assert(sizeof(CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime) == 0x000014, "Wrong size on CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime, TotalPathLength) == 0x000000, "Member 'CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime::TotalPathLength' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime, MaxSpeed) == 0x000004, "Member 'CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime::MaxSpeed' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime, AccelerationTime) == 0x000008, "Member 'CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime::AccelerationTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime, ElapsedTime) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime::ElapsedTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetDistanceAlongPathAtElapsedTime::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetDistanceBetweenShapeAndSegment
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment final
{
public:
	class UShapeComponent*                        ShapeComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentStart;                                      // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentEnd;                                        // 0x0014(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment");
static_assert(sizeof(CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment) == 0x000028, "Wrong size on CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment, ShapeComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment::ShapeComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment, SegmentStart) == 0x000008, "Member 'CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment::SegmentStart' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment, SegmentEnd) == 0x000014, "Member 'CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment::SegmentEnd' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_GetDistanceBetweenShapeAndSegment::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetEnumeratorTextFromHandle
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_GetEnumeratorTextFromHandle final
{
public:
	struct FEnumHandle                            EnumHandle;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetEnumeratorTextFromHandle) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetEnumeratorTextFromHandle");
static_assert(sizeof(CoreGameFunctionLibrary_GetEnumeratorTextFromHandle) == 0x000028, "Wrong size on CoreGameFunctionLibrary_GetEnumeratorTextFromHandle");
static_assert(offsetof(CoreGameFunctionLibrary_GetEnumeratorTextFromHandle, EnumHandle) == 0x000000, "Member 'CoreGameFunctionLibrary_GetEnumeratorTextFromHandle::EnumHandle' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetEnumeratorTextFromHandle, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetEnumeratorTextFromHandle::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetEnumValueByName
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetEnumValueByName final
{
public:
	class UEnum*                                  Enum;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetEnumValueByName) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetEnumValueByName");
static_assert(sizeof(CoreGameFunctionLibrary_GetEnumValueByName) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetEnumValueByName");
static_assert(offsetof(CoreGameFunctionLibrary_GetEnumValueByName, Enum) == 0x000000, "Member 'CoreGameFunctionLibrary_GetEnumValueByName::Enum' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetEnumValueByName, Name_0) == 0x000008, "Member 'CoreGameFunctionLibrary_GetEnumValueByName::Name_0' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetEnumValueByName, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetEnumValueByName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetExactStaticMeshBoundsWithTransform
// 0x0060 (0x0060 - 0x0000)
struct CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   ReturnValue;                                       // 0x0040(0x001C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform");
static_assert(sizeof(CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform) == 0x000060, "Wrong size on CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform, StaticMesh) == 0x000000, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform::StaticMesh' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform, Transform) == 0x000010, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform::Transform' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform, ReturnValue) == 0x000040, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshBoundsWithTransform::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetExactStaticMeshCollisionBoundsForComponent
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeChildren;                                  // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   ReturnValue;                                       // 0x000C(0x001C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent");
static_assert(sizeof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent) == 0x000028, "Wrong size on CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent, StaticMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent, bIncludeChildren) == 0x000008, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent::bIncludeChildren' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent, ReturnValue) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsForComponent::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetExactStaticMeshCollisionBoundsWithTransform
// 0x0060 (0x0060 - 0x0000)
struct CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   ReturnValue;                                       // 0x0040(0x001C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform");
static_assert(sizeof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform) == 0x000060, "Wrong size on CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform, StaticMesh) == 0x000000, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform::StaticMesh' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform, Transform) == 0x000010, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform::Transform' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform, ReturnValue) == 0x000040, "Member 'CoreGameFunctionLibrary_GetExactStaticMeshCollisionBoundsWithTransform::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetFilteredActorsInSubLevel
// 0x0038 (0x0038 - 0x0000)
struct CoreGameFunctionLibrary_GetFilteredActorsInSubLevel final
{
public:
	class ULevel*                                 SubLevel;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     RequireActorClass;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     IgnoreActorClass;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            RequireComponentClass;                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmobile;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMobile;                                           // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetFilteredActorsInSubLevel");
static_assert(sizeof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel) == 0x000038, "Wrong size on CoreGameFunctionLibrary_GetFilteredActorsInSubLevel");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel, SubLevel) == 0x000000, "Member 'CoreGameFunctionLibrary_GetFilteredActorsInSubLevel::SubLevel' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel, RequireActorClass) == 0x000008, "Member 'CoreGameFunctionLibrary_GetFilteredActorsInSubLevel::RequireActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel, IgnoreActorClass) == 0x000010, "Member 'CoreGameFunctionLibrary_GetFilteredActorsInSubLevel::IgnoreActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel, RequireComponentClass) == 0x000018, "Member 'CoreGameFunctionLibrary_GetFilteredActorsInSubLevel::RequireComponentClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel, bImmobile) == 0x000020, "Member 'CoreGameFunctionLibrary_GetFilteredActorsInSubLevel::bImmobile' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel, bMobile) == 0x000021, "Member 'CoreGameFunctionLibrary_GetFilteredActorsInSubLevel::bMobile' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredActorsInSubLevel, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_GetFilteredActorsInSubLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetFilteredComponentsInSubLevel
// 0x0038 (0x0038 - 0x0000)
struct CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel final
{
public:
	class ULevel*                                 SubLevel;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     RequireActorClass;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     IgnoreActorClass;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            RequireComponentClass;                             // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmobile;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMobile;                                           // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorComponent*>                ReturnValue;                                       // 0x0028(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel");
static_assert(sizeof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel) == 0x000038, "Wrong size on CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel, SubLevel) == 0x000000, "Member 'CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel::SubLevel' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel, RequireActorClass) == 0x000008, "Member 'CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel::RequireActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel, IgnoreActorClass) == 0x000010, "Member 'CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel::IgnoreActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel, RequireComponentClass) == 0x000018, "Member 'CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel::RequireComponentClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel, bImmobile) == 0x000020, "Member 'CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel::bImmobile' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel, bMobile) == 0x000021, "Member 'CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel::bMobile' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_GetFilteredComponentsInSubLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetFirstParentBoneLocationInCapsule
// 0x0040 (0x0040 - 0x0000)
struct CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutBoneLocation;                                   // 0x0018(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OutExteriorBoneNames;                              // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule");
static_assert(sizeof(CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule) == 0x000040, "Wrong size on CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule");
static_assert(offsetof(CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule, SkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule, CapsuleComponent) == 0x000008, "Member 'CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule, SocketName) == 0x000010, "Member 'CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule::SocketName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule, OutBoneLocation) == 0x000018, "Member 'CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule::OutBoneLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule, OutExteriorBoneNames) == 0x000028, "Member 'CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule::OutExteriorBoneNames' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule, ReturnValue) == 0x000038, "Member 'CoreGameFunctionLibrary_GetFirstParentBoneLocationInCapsule::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetLagrangeInterp
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetLagrangeInterp final
{
public:
	TArray<struct FVector2D>                      Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetLagrangeInterp) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetLagrangeInterp");
static_assert(sizeof(CoreGameFunctionLibrary_GetLagrangeInterp) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetLagrangeInterp");
static_assert(offsetof(CoreGameFunctionLibrary_GetLagrangeInterp, Points) == 0x000000, "Member 'CoreGameFunctionLibrary_GetLagrangeInterp::Points' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLagrangeInterp, X) == 0x000010, "Member 'CoreGameFunctionLibrary_GetLagrangeInterp::X' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLagrangeInterp, ReturnValue) == 0x000014, "Member 'CoreGameFunctionLibrary_GetLagrangeInterp::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetLastRenderTime
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_GetLastRenderTime final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetLastRenderTime) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetLastRenderTime");
static_assert(sizeof(CoreGameFunctionLibrary_GetLastRenderTime) == 0x000010, "Wrong size on CoreGameFunctionLibrary_GetLastRenderTime");
static_assert(offsetof(CoreGameFunctionLibrary_GetLastRenderTime, PrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetLastRenderTime::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLastRenderTime, CurrentTime) == 0x000008, "Member 'CoreGameFunctionLibrary_GetLastRenderTime::CurrentTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLastRenderTime, ReturnValue) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetLastRenderTime::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetLocationAlongPathAtElapsedTime
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTime;                                  // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime");
static_assert(sizeof(CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime) == 0x000030, "Wrong size on CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime");
static_assert(offsetof(CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime, SourceLocation) == 0x000000, "Member 'CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime::SourceLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime, TargetLocation) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime::TargetLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime, MaxSpeed) == 0x000018, "Member 'CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime::MaxSpeed' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime, AccelerationTime) == 0x00001C, "Member 'CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime::AccelerationTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime, ElapsedTime) == 0x000020, "Member 'CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime::ElapsedTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime, ReturnValue) == 0x000024, "Member 'CoreGameFunctionLibrary_GetLocationAlongPathAtElapsedTime::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetMontageRateScale
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_GetMontageRateScale final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetMontageRateScale) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetMontageRateScale");
static_assert(sizeof(CoreGameFunctionLibrary_GetMontageRateScale) == 0x000010, "Wrong size on CoreGameFunctionLibrary_GetMontageRateScale");
static_assert(offsetof(CoreGameFunctionLibrary_GetMontageRateScale, Montage) == 0x000000, "Member 'CoreGameFunctionLibrary_GetMontageRateScale::Montage' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetMontageRateScale, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetMontageRateScale::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetPitchRotationTowards
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_GetPitchRotationTowards final
{
public:
	struct FVector                                SourceDirection;                                   // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceRightDirection;                              // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetPitchRotationTowards) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetPitchRotationTowards");
static_assert(sizeof(CoreGameFunctionLibrary_GetPitchRotationTowards) == 0x000028, "Wrong size on CoreGameFunctionLibrary_GetPitchRotationTowards");
static_assert(offsetof(CoreGameFunctionLibrary_GetPitchRotationTowards, SourceDirection) == 0x000000, "Member 'CoreGameFunctionLibrary_GetPitchRotationTowards::SourceDirection' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetPitchRotationTowards, SourceRightDirection) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetPitchRotationTowards::SourceRightDirection' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetPitchRotationTowards, TargetVector) == 0x000018, "Member 'CoreGameFunctionLibrary_GetPitchRotationTowards::TargetVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetPitchRotationTowards, ReturnValue) == 0x000024, "Member 'CoreGameFunctionLibrary_GetPitchRotationTowards::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetPlaneNormal
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetPlaneNormal final
{
public:
	struct FPlane                                 Plane;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetPlaneNormal) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_GetPlaneNormal");
static_assert(sizeof(CoreGameFunctionLibrary_GetPlaneNormal) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetPlaneNormal");
static_assert(offsetof(CoreGameFunctionLibrary_GetPlaneNormal, Plane) == 0x000000, "Member 'CoreGameFunctionLibrary_GetPlaneNormal::Plane' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetPlaneNormal, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetPlaneNormal::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetPlaneOrigin
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetPlaneOrigin final
{
public:
	struct FPlane                                 Plane;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetPlaneOrigin) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_GetPlaneOrigin");
static_assert(sizeof(CoreGameFunctionLibrary_GetPlaneOrigin) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetPlaneOrigin");
static_assert(offsetof(CoreGameFunctionLibrary_GetPlaneOrigin, Plane) == 0x000000, "Member 'CoreGameFunctionLibrary_GetPlaneOrigin::Plane' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetPlaneOrigin, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetPlaneOrigin::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetProjectedShapeBoundsInWidget
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShapeComponent*                        ShapeComponent;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBoxAsLozenge;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox2D                                 OutScreenBounds;                                   // 0x0014(0x0014)(Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget");
static_assert(sizeof(CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget) == 0x000030, "Wrong size on CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget, PlayerController) == 0x000000, "Member 'CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget::PlayerController' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget, ShapeComponent) == 0x000008, "Member 'CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget::ShapeComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget, bBoxAsLozenge) == 0x000010, "Member 'CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget::bBoxAsLozenge' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget, OutScreenBounds) == 0x000014, "Member 'CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget::OutScreenBounds' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_GetProjectedShapeBoundsInWidget::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetProjectedSphereBoundsInWidget
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 OutScreenBounds;                                   // 0x0018(0x0014)(Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget");
static_assert(sizeof(CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget) == 0x000030, "Wrong size on CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget, PlayerController) == 0x000000, "Member 'CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget::PlayerController' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget, Center) == 0x000008, "Member 'CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget::Center' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget, Radius) == 0x000014, "Member 'CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget::Radius' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget, OutScreenBounds) == 0x000018, "Member 'CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget::OutScreenBounds' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget, ReturnValue) == 0x00002C, "Member 'CoreGameFunctionLibrary_GetProjectedSphereBoundsInWidget::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetRotationTowards
// 0x0034 (0x0034 - 0x0000)
struct CoreGameFunctionLibrary_GetRotationTowards final
{
public:
	struct FVector                                SourceVector;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SourceUpVector;                                    // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutRotationAxis;                                   // 0x0024(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetRotationTowards) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetRotationTowards");
static_assert(sizeof(CoreGameFunctionLibrary_GetRotationTowards) == 0x000034, "Wrong size on CoreGameFunctionLibrary_GetRotationTowards");
static_assert(offsetof(CoreGameFunctionLibrary_GetRotationTowards, SourceVector) == 0x000000, "Member 'CoreGameFunctionLibrary_GetRotationTowards::SourceVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetRotationTowards, SourceUpVector) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetRotationTowards::SourceUpVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetRotationTowards, TargetVector) == 0x000018, "Member 'CoreGameFunctionLibrary_GetRotationTowards::TargetVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetRotationTowards, OutRotationAxis) == 0x000024, "Member 'CoreGameFunctionLibrary_GetRotationTowards::OutRotationAxis' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetRotationTowards, ReturnValue) == 0x000030, "Member 'CoreGameFunctionLibrary_GetRotationTowards::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetRotationTowardsXY
// 0x001C (0x001C - 0x0000)
struct CoreGameFunctionLibrary_GetRotationTowardsXY final
{
public:
	struct FVector                                SourceVector;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetRotationTowardsXY) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetRotationTowardsXY");
static_assert(sizeof(CoreGameFunctionLibrary_GetRotationTowardsXY) == 0x00001C, "Wrong size on CoreGameFunctionLibrary_GetRotationTowardsXY");
static_assert(offsetof(CoreGameFunctionLibrary_GetRotationTowardsXY, SourceVector) == 0x000000, "Member 'CoreGameFunctionLibrary_GetRotationTowardsXY::SourceVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetRotationTowardsXY, TargetVector) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetRotationTowardsXY::TargetVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetRotationTowardsXY, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_GetRotationTowardsXY::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSetBitIndices
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetSetBitIndices final
{
public:
	int32                                         Bits;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetSetBitIndices) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetSetBitIndices");
static_assert(sizeof(CoreGameFunctionLibrary_GetSetBitIndices) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetSetBitIndices");
static_assert(offsetof(CoreGameFunctionLibrary_GetSetBitIndices, Bits) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSetBitIndices::Bits' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSetBitIndices, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetSetBitIndices::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSimulatingPhysicsComponents
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetSimulatingPhysicsComponents final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetSimulatingPhysicsComponents) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetSimulatingPhysicsComponents");
static_assert(sizeof(CoreGameFunctionLibrary_GetSimulatingPhysicsComponents) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetSimulatingPhysicsComponents");
static_assert(offsetof(CoreGameFunctionLibrary_GetSimulatingPhysicsComponents, Actor) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSimulatingPhysicsComponents::Actor' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSimulatingPhysicsComponents, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetSimulatingPhysicsComponents::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSkeletalMeshBodyTransforms
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms");
static_assert(sizeof(CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms");
static_assert(offsetof(CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms, SkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetSkeletalMeshBodyTransforms::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSmoothApproxBoundsWithTransform
// 0x0070 (0x0070 - 0x0000)
struct CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform final
{
public:
	struct FBox                                   LocalBounds;                                       // 0x0000(0x001C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0020(0x0030)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   ReturnValue;                                       // 0x0050(0x001C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform");
static_assert(sizeof(CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform) == 0x000070, "Wrong size on CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform, LocalBounds) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform::LocalBounds' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform, Transform) == 0x000020, "Member 'CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform::Transform' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform, ReturnValue) == 0x000050, "Member 'CoreGameFunctionLibrary_GetSmoothApproxBoundsWithTransform::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSmoothMovementParameters
// 0x0024 (0x0024 - 0x0000)
struct CoreGameFunctionLibrary_GetSmoothMovementParameters final
{
public:
	float                                         TotalPathLength;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationTime;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutAcceleration;                                   // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutConstantSpeedDuration;                          // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutConstantSpeedDistance;                          // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutActualAccelerationTime;                         // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutActualAccelerationDistance;                     // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetSmoothMovementParameters) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetSmoothMovementParameters");
static_assert(sizeof(CoreGameFunctionLibrary_GetSmoothMovementParameters) == 0x000024, "Wrong size on CoreGameFunctionLibrary_GetSmoothMovementParameters");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, TotalPathLength) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::TotalPathLength' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, MaxSpeed) == 0x000004, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::MaxSpeed' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, AccelerationTime) == 0x000008, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::AccelerationTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, OutAcceleration) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::OutAcceleration' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, OutConstantSpeedDuration) == 0x000010, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::OutConstantSpeedDuration' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, OutConstantSpeedDistance) == 0x000014, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::OutConstantSpeedDistance' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, OutActualAccelerationTime) == 0x000018, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::OutActualAccelerationTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, OutActualAccelerationDistance) == 0x00001C, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::OutActualAccelerationDistance' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSmoothMovementParameters, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_GetSmoothMovementParameters::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSortedChildComponentsByClassAndPrefix
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix final
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                ReturnValue;                                       // 0x0020(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix");
static_assert(sizeof(CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix) == 0x000030, "Wrong size on CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix");
static_assert(offsetof(CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix, SceneComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix::SceneComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix, Prefix) == 0x000010, "Member 'CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix::Prefix' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_GetSortedChildComponentsByClassAndPrefix::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSortedComponentsByClassAndPrefix
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UActorComponent>            ClassFilter;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                ReturnValue;                                       // 0x0020(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix");
static_assert(sizeof(CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix) == 0x000030, "Wrong size on CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix");
static_assert(offsetof(CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix, Actor) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix::Actor' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix, ClassFilter) == 0x000008, "Member 'CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix::ClassFilter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix, Prefix) == 0x000010, "Member 'CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix::Prefix' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_GetSortedComponentsByClassAndPrefix::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetStaticMeshVertexIndicesOfTrianglesInBox
// 0x0078 (0x0078 - 0x0000)
struct CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   LocalBox;                                          // 0x000C(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSet<int32>                                   ReturnValue;                                       // 0x0028(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox");
static_assert(sizeof(CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox) == 0x000078, "Wrong size on CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox");
static_assert(offsetof(CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox, StaticMesh) == 0x000000, "Member 'CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox::StaticMesh' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox, LODIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox::LODIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox, LocalBox) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox::LocalBox' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_GetStaticMeshVertexIndicesOfTrianglesInBox::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSubLevelByName
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetSubLevelByName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubLevelName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetSubLevelByName) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetSubLevelByName");
static_assert(sizeof(CoreGameFunctionLibrary_GetSubLevelByName) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetSubLevelByName");
static_assert(offsetof(CoreGameFunctionLibrary_GetSubLevelByName, WorldContextObject) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSubLevelByName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSubLevelByName, SubLevelName) == 0x000008, "Member 'CoreGameFunctionLibrary_GetSubLevelByName::SubLevelName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSubLevelByName, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetSubLevelByName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetSuperClass
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_GetSuperClass final
{
public:
	class UClass*                                 Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetSuperClass) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetSuperClass");
static_assert(sizeof(CoreGameFunctionLibrary_GetSuperClass) == 0x000010, "Wrong size on CoreGameFunctionLibrary_GetSuperClass");
static_assert(offsetof(CoreGameFunctionLibrary_GetSuperClass, Class_0) == 0x000000, "Member 'CoreGameFunctionLibrary_GetSuperClass::Class_0' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetSuperClass, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetSuperClass::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetUClassName
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetUClassName final
{
public:
	class UClass*                                 InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetUClassName) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetUClassName");
static_assert(sizeof(CoreGameFunctionLibrary_GetUClassName) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetUClassName");
static_assert(offsetof(CoreGameFunctionLibrary_GetUClassName, InClass) == 0x000000, "Member 'CoreGameFunctionLibrary_GetUClassName::InClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetUClassName, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_GetUClassName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetVectorNormalAndLength
// 0x001C (0x001C - 0x0000)
struct CoreGameFunctionLibrary_GetVectorNormalAndLength final
{
public:
	struct FVector                                Vector;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutLength;                                         // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetVectorNormalAndLength) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetVectorNormalAndLength");
static_assert(sizeof(CoreGameFunctionLibrary_GetVectorNormalAndLength) == 0x00001C, "Wrong size on CoreGameFunctionLibrary_GetVectorNormalAndLength");
static_assert(offsetof(CoreGameFunctionLibrary_GetVectorNormalAndLength, Vector) == 0x000000, "Member 'CoreGameFunctionLibrary_GetVectorNormalAndLength::Vector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetVectorNormalAndLength, OutLength) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetVectorNormalAndLength::OutLength' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetVectorNormalAndLength, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetVectorNormalAndLength::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetVoxelCoordsFromVoxelIndex
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex final
{
public:
	int32                                         VoxelIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              LevelSize2D;                                       // 0x0004(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex");
static_assert(sizeof(CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex");
static_assert(offsetof(CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex, VoxelIndex) == 0x000000, "Member 'CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex::VoxelIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex, LevelSize2D) == 0x000004, "Member 'CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex::LevelSize2D' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex, ReturnValue) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetVoxelCoordsFromVoxelIndex::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetVoxelIndexFromVoxelCoords
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords final
{
public:
	struct FIntVector                             VoxelCoords;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              LevelSize2D;                                       // 0x000C(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords");
static_assert(sizeof(CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords");
static_assert(offsetof(CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords, VoxelCoords) == 0x000000, "Member 'CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords::VoxelCoords' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords, LevelSize2D) == 0x00000C, "Member 'CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords::LevelSize2D' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords, ReturnValue) == 0x000014, "Member 'CoreGameFunctionLibrary_GetVoxelIndexFromVoxelCoords::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetWeightedDistancesBetweenPointAndBodyInstances
// 0x00C0 (0x00C0 - 0x0000)
struct CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances final
{
public:
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleByMass;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FName>                BoneRemapping;                                     // 0x0020(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      ReturnValue;                                       // 0x0070(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances");
static_assert(sizeof(CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances) == 0x0000C0, "Wrong size on CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances, SkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances, WorldLocation) == 0x000008, "Member 'CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances::WorldLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances, MaxDistance) == 0x000014, "Member 'CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances::MaxDistance' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances, bScaleByMass) == 0x000018, "Member 'CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances::bScaleByMass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances, BoneRemapping) == 0x000020, "Member 'CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances::BoneRemapping' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances, ReturnValue) == 0x000070, "Member 'CoreGameFunctionLibrary_GetWeightedDistancesBetweenPointAndBodyInstances::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetWeightedRandomIndexFromFloatArray
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray final
{
public:
	TArray<float>                                 Weights;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray");
static_assert(sizeof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray, Weights) == 0x000000, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray::Weights' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromFloatArray::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetWeightedRandomIndexFromStructArray
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray final
{
public:
	TArray<class UObject*>                        WeightedStructs;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ExcludeIndex;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray");
static_assert(sizeof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray) == 0x000018, "Wrong size on CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray, WeightedStructs) == 0x000000, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray::WeightedStructs' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray, ExcludeIndex) == 0x000010, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray::ExcludeIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray, ReturnValue) == 0x000014, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArray::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.GetWeightedRandomIndexFromStructArrayWithStream
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream final
{
public:
	TArray<class UObject*>                        WeightedStructs;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ExcludeIndex;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream");
static_assert(sizeof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream) == 0x000020, "Wrong size on CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream, WeightedStructs) == 0x000000, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream::WeightedStructs' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream, RandomStream) == 0x000010, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream::RandomStream' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream, ExcludeIndex) == 0x000018, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream::ExcludeIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream, ReturnValue) == 0x00001C, "Member 'CoreGameFunctionLibrary_GetWeightedRandomIndexFromStructArrayWithStream::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.HashCombineInt32
// 0x000C (0x000C - 0x0000)
struct CoreGameFunctionLibrary_HashCombineInt32 final
{
public:
	int32                                         ValueA;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValueB;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_HashCombineInt32) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_HashCombineInt32");
static_assert(sizeof(CoreGameFunctionLibrary_HashCombineInt32) == 0x00000C, "Wrong size on CoreGameFunctionLibrary_HashCombineInt32");
static_assert(offsetof(CoreGameFunctionLibrary_HashCombineInt32, ValueA) == 0x000000, "Member 'CoreGameFunctionLibrary_HashCombineInt32::ValueA' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_HashCombineInt32, ValueB) == 0x000004, "Member 'CoreGameFunctionLibrary_HashCombineInt32::ValueB' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_HashCombineInt32, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_HashCombineInt32::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.HashInt64
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_HashInt64 final
{
public:
	int64                                         Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_HashInt64) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_HashInt64");
static_assert(sizeof(CoreGameFunctionLibrary_HashInt64) == 0x000010, "Wrong size on CoreGameFunctionLibrary_HashInt64");
static_assert(offsetof(CoreGameFunctionLibrary_HashInt64, Value) == 0x000000, "Member 'CoreGameFunctionLibrary_HashInt64::Value' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_HashInt64, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_HashInt64::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.HashString
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_HashString final
{
public:
	class FString                                 String;                                            // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_HashString) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_HashString");
static_assert(sizeof(CoreGameFunctionLibrary_HashString) == 0x000018, "Wrong size on CoreGameFunctionLibrary_HashString");
static_assert(offsetof(CoreGameFunctionLibrary_HashString, String) == 0x000000, "Member 'CoreGameFunctionLibrary_HashString::String' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_HashString, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_HashString::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.HasLoadedAllTextureMipsForForMaterial
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial");
static_assert(sizeof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial) == 0x000010, "Wrong size on CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial");
static_assert(offsetof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial, Material) == 0x000000, "Member 'CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial::Material' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_HasLoadedAllTextureMipsForForMaterial::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.HasLoadedAllTextureMipsForStaticMeshComponent
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeChildMeshComponents;                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent");
static_assert(sizeof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent) == 0x000010, "Wrong size on CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent");
static_assert(offsetof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent, StaticMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent, bIncludeChildMeshComponents) == 0x000008, "Member 'CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent::bIncludeChildMeshComponents' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent, ReturnValue) == 0x000009, "Member 'CoreGameFunctionLibrary_HasLoadedAllTextureMipsForStaticMeshComponent::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.HideActorFromPlayer
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_HideActorFromPlayer final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      PlayerController;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_HideActorFromPlayer) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_HideActorFromPlayer");
static_assert(sizeof(CoreGameFunctionLibrary_HideActorFromPlayer) == 0x000010, "Wrong size on CoreGameFunctionLibrary_HideActorFromPlayer");
static_assert(offsetof(CoreGameFunctionLibrary_HideActorFromPlayer, Actor) == 0x000000, "Member 'CoreGameFunctionLibrary_HideActorFromPlayer::Actor' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_HideActorFromPlayer, PlayerController) == 0x000008, "Member 'CoreGameFunctionLibrary_HideActorFromPlayer::PlayerController' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IntersectBoxClipHull
// 0x0038 (0x0038 - 0x0000)
struct CoreGameFunctionLibrary_IntersectBoxClipHull final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlane>                         HullClipPlanes;                                    // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IntersectBoxClipHull) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_IntersectBoxClipHull");
static_assert(sizeof(CoreGameFunctionLibrary_IntersectBoxClipHull) == 0x000038, "Wrong size on CoreGameFunctionLibrary_IntersectBoxClipHull");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxClipHull, Box) == 0x000000, "Member 'CoreGameFunctionLibrary_IntersectBoxClipHull::Box' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxClipHull, HullClipPlanes) == 0x000020, "Member 'CoreGameFunctionLibrary_IntersectBoxClipHull::HullClipPlanes' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxClipHull, ReturnValue) == 0x000030, "Member 'CoreGameFunctionLibrary_IntersectBoxClipHull::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IntersectBoxes
// 0x003C (0x003C - 0x0000)
struct CoreGameFunctionLibrary_IntersectBoxes final
{
public:
	struct FBox                                   BoxA;                                              // 0x0000(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox                                   BoxB;                                              // 0x001C(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IntersectBoxes) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IntersectBoxes");
static_assert(sizeof(CoreGameFunctionLibrary_IntersectBoxes) == 0x00003C, "Wrong size on CoreGameFunctionLibrary_IntersectBoxes");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxes, BoxA) == 0x000000, "Member 'CoreGameFunctionLibrary_IntersectBoxes::BoxA' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxes, BoxB) == 0x00001C, "Member 'CoreGameFunctionLibrary_IntersectBoxes::BoxB' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxes, ReturnValue) == 0x000038, "Member 'CoreGameFunctionLibrary_IntersectBoxes::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IntersectBoxes2D
// 0x002C (0x002C - 0x0000)
struct CoreGameFunctionLibrary_IntersectBoxes2D final
{
public:
	struct FBox2D                                 BoxA;                                              // 0x0000(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FBox2D                                 BoxB;                                              // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IntersectBoxes2D) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IntersectBoxes2D");
static_assert(sizeof(CoreGameFunctionLibrary_IntersectBoxes2D) == 0x00002C, "Wrong size on CoreGameFunctionLibrary_IntersectBoxes2D");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxes2D, BoxA) == 0x000000, "Member 'CoreGameFunctionLibrary_IntersectBoxes2D::BoxA' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxes2D, BoxB) == 0x000014, "Member 'CoreGameFunctionLibrary_IntersectBoxes2D::BoxB' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectBoxes2D, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_IntersectBoxes2D::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IntersectRayBox
// 0x0040 (0x0040 - 0x0000)
struct CoreGameFunctionLibrary_IntersectRayBox final
{
public:
	struct FVector                                RayLocation;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayDirection;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0018(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              OutTMinMax;                                        // 0x0034(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IntersectRayBox) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IntersectRayBox");
static_assert(sizeof(CoreGameFunctionLibrary_IntersectRayBox) == 0x000040, "Wrong size on CoreGameFunctionLibrary_IntersectRayBox");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRayBox, RayLocation) == 0x000000, "Member 'CoreGameFunctionLibrary_IntersectRayBox::RayLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRayBox, RayDirection) == 0x00000C, "Member 'CoreGameFunctionLibrary_IntersectRayBox::RayDirection' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRayBox, Box) == 0x000018, "Member 'CoreGameFunctionLibrary_IntersectRayBox::Box' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRayBox, OutTMinMax) == 0x000034, "Member 'CoreGameFunctionLibrary_IntersectRayBox::OutTMinMax' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRayBox, ReturnValue) == 0x00003C, "Member 'CoreGameFunctionLibrary_IntersectRayBox::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IntersectRaySphere
// 0x0034 (0x0034 - 0x0000)
struct CoreGameFunctionLibrary_IntersectRaySphere final
{
public:
	struct FVector                                RayLocation;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayDirection;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SphereCenter;                                      // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutTMinMax;                                        // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IntersectRaySphere) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IntersectRaySphere");
static_assert(sizeof(CoreGameFunctionLibrary_IntersectRaySphere) == 0x000034, "Wrong size on CoreGameFunctionLibrary_IntersectRaySphere");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRaySphere, RayLocation) == 0x000000, "Member 'CoreGameFunctionLibrary_IntersectRaySphere::RayLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRaySphere, RayDirection) == 0x00000C, "Member 'CoreGameFunctionLibrary_IntersectRaySphere::RayDirection' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRaySphere, SphereCenter) == 0x000018, "Member 'CoreGameFunctionLibrary_IntersectRaySphere::SphereCenter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRaySphere, SphereRadius) == 0x000024, "Member 'CoreGameFunctionLibrary_IntersectRaySphere::SphereRadius' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRaySphere, OutTMinMax) == 0x000028, "Member 'CoreGameFunctionLibrary_IntersectRaySphere::OutTMinMax' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectRaySphere, ReturnValue) == 0x000030, "Member 'CoreGameFunctionLibrary_IntersectRaySphere::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IntersectSegmentBox
// 0x0044 (0x0044 - 0x0000)
struct CoreGameFunctionLibrary_IntersectSegmentBox final
{
public:
	struct FVector                                SourceLocation;                                    // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0018(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OutIntersectPoint;                                 // 0x0034(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IntersectSegmentBox) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IntersectSegmentBox");
static_assert(sizeof(CoreGameFunctionLibrary_IntersectSegmentBox) == 0x000044, "Wrong size on CoreGameFunctionLibrary_IntersectSegmentBox");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegmentBox, SourceLocation) == 0x000000, "Member 'CoreGameFunctionLibrary_IntersectSegmentBox::SourceLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegmentBox, TargetLocation) == 0x00000C, "Member 'CoreGameFunctionLibrary_IntersectSegmentBox::TargetLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegmentBox, Box) == 0x000018, "Member 'CoreGameFunctionLibrary_IntersectSegmentBox::Box' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegmentBox, OutIntersectPoint) == 0x000034, "Member 'CoreGameFunctionLibrary_IntersectSegmentBox::OutIntersectPoint' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegmentBox, ReturnValue) == 0x000040, "Member 'CoreGameFunctionLibrary_IntersectSegmentBox::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IntersectSegments2D
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_IntersectSegments2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              C;                                                 // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              D;                                                 // 0x0018(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutTime;                                           // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IntersectSegments2D) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IntersectSegments2D");
static_assert(sizeof(CoreGameFunctionLibrary_IntersectSegments2D) == 0x000028, "Wrong size on CoreGameFunctionLibrary_IntersectSegments2D");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegments2D, A) == 0x000000, "Member 'CoreGameFunctionLibrary_IntersectSegments2D::A' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegments2D, B) == 0x000008, "Member 'CoreGameFunctionLibrary_IntersectSegments2D::B' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegments2D, C) == 0x000010, "Member 'CoreGameFunctionLibrary_IntersectSegments2D::C' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegments2D, D) == 0x000018, "Member 'CoreGameFunctionLibrary_IntersectSegments2D::D' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegments2D, OutTime) == 0x000020, "Member 'CoreGameFunctionLibrary_IntersectSegments2D::OutTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSegments2D, ReturnValue) == 0x000024, "Member 'CoreGameFunctionLibrary_IntersectSegments2D::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IntersectSweptSphereCapsule
// 0x004C (0x004C - 0x0000)
struct CoreGameFunctionLibrary_IntersectSweptSphereCapsule final
{
public:
	struct FVector                                SphereSource;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SphereTarget;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsuleCenter;                                     // 0x001C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsuleAxis;                                       // 0x0028(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfLength;                                 // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutHitPoint;                                       // 0x003C(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IntersectSweptSphereCapsule");
static_assert(sizeof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule) == 0x00004C, "Wrong size on CoreGameFunctionLibrary_IntersectSweptSphereCapsule");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, SphereSource) == 0x000000, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::SphereSource' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, SphereTarget) == 0x00000C, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::SphereTarget' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, SphereRadius) == 0x000018, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::SphereRadius' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, CapsuleCenter) == 0x00001C, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::CapsuleCenter' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, CapsuleAxis) == 0x000028, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::CapsuleAxis' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, CapsuleHalfLength) == 0x000034, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::CapsuleHalfLength' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, CapsuleRadius) == 0x000038, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, OutHitPoint) == 0x00003C, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::OutHitPoint' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IntersectSweptSphereCapsule, ReturnValue) == 0x000048, "Member 'CoreGameFunctionLibrary_IntersectSweptSphereCapsule::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsBoxValid
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_IsBoxValid final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x001C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IsBoxValid) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IsBoxValid");
static_assert(sizeof(CoreGameFunctionLibrary_IsBoxValid) == 0x000020, "Wrong size on CoreGameFunctionLibrary_IsBoxValid");
static_assert(offsetof(CoreGameFunctionLibrary_IsBoxValid, Box) == 0x000000, "Member 'CoreGameFunctionLibrary_IsBoxValid::Box' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsBoxValid, ReturnValue) == 0x00001C, "Member 'CoreGameFunctionLibrary_IsBoxValid::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsCompatibleMontageForAnimInstance
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          AnimInstance;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance");
static_assert(sizeof(CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance) == 0x000018, "Wrong size on CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance");
static_assert(offsetof(CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance, Montage) == 0x000000, "Member 'CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance::Montage' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance, AnimInstance) == 0x000008, "Member 'CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance::AnimInstance' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_IsCompatibleMontageForAnimInstance::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsGame
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_IsGame final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IsGame) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_IsGame");
static_assert(sizeof(CoreGameFunctionLibrary_IsGame) == 0x000010, "Wrong size on CoreGameFunctionLibrary_IsGame");
static_assert(offsetof(CoreGameFunctionLibrary_IsGame, WorldContextObject) == 0x000000, "Member 'CoreGameFunctionLibrary_IsGame::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsGame, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_IsGame::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsMontageUsingSlotName
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_IsMontageUsingSlotName final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IsMontageUsingSlotName) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_IsMontageUsingSlotName");
static_assert(sizeof(CoreGameFunctionLibrary_IsMontageUsingSlotName) == 0x000018, "Wrong size on CoreGameFunctionLibrary_IsMontageUsingSlotName");
static_assert(offsetof(CoreGameFunctionLibrary_IsMontageUsingSlotName, Montage) == 0x000000, "Member 'CoreGameFunctionLibrary_IsMontageUsingSlotName::Montage' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsMontageUsingSlotName, SlotName) == 0x000008, "Member 'CoreGameFunctionLibrary_IsMontageUsingSlotName::SlotName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsMontageUsingSlotName, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_IsMontageUsingSlotName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsOrthogonalRotation
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_IsOrthogonalRotation final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IsOrthogonalRotation) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IsOrthogonalRotation");
static_assert(sizeof(CoreGameFunctionLibrary_IsOrthogonalRotation) == 0x000010, "Wrong size on CoreGameFunctionLibrary_IsOrthogonalRotation");
static_assert(offsetof(CoreGameFunctionLibrary_IsOrthogonalRotation, Rotation) == 0x000000, "Member 'CoreGameFunctionLibrary_IsOrthogonalRotation::Rotation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsOrthogonalRotation, ReturnValue) == 0x00000C, "Member 'CoreGameFunctionLibrary_IsOrthogonalRotation::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsPointInBox2D
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_IsPointInBox2D final
{
public:
	struct FVector2D                              Point;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 Box;                                               // 0x0008(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IsPointInBox2D) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_IsPointInBox2D");
static_assert(sizeof(CoreGameFunctionLibrary_IsPointInBox2D) == 0x000020, "Wrong size on CoreGameFunctionLibrary_IsPointInBox2D");
static_assert(offsetof(CoreGameFunctionLibrary_IsPointInBox2D, Point) == 0x000000, "Member 'CoreGameFunctionLibrary_IsPointInBox2D::Point' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsPointInBox2D, Box) == 0x000008, "Member 'CoreGameFunctionLibrary_IsPointInBox2D::Box' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsPointInBox2D, ReturnValue) == 0x00001C, "Member 'CoreGameFunctionLibrary_IsPointInBox2D::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsPointInCapsule
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_IsPointInCapsule final
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IsPointInCapsule) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_IsPointInCapsule");
static_assert(sizeof(CoreGameFunctionLibrary_IsPointInCapsule) == 0x000018, "Wrong size on CoreGameFunctionLibrary_IsPointInCapsule");
static_assert(offsetof(CoreGameFunctionLibrary_IsPointInCapsule, CapsuleComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_IsPointInCapsule::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsPointInCapsule, WorldLocation) == 0x000008, "Member 'CoreGameFunctionLibrary_IsPointInCapsule::WorldLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsPointInCapsule, ReturnValue) == 0x000014, "Member 'CoreGameFunctionLibrary_IsPointInCapsule::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsSimulatingInEditor
// 0x0001 (0x0001 - 0x0000)
struct CoreGameFunctionLibrary_IsSimulatingInEditor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_IsSimulatingInEditor) == 0x000001, "Wrong alignment on CoreGameFunctionLibrary_IsSimulatingInEditor");
static_assert(sizeof(CoreGameFunctionLibrary_IsSimulatingInEditor) == 0x000001, "Wrong size on CoreGameFunctionLibrary_IsSimulatingInEditor");
static_assert(offsetof(CoreGameFunctionLibrary_IsSimulatingInEditor, ReturnValue) == 0x000000, "Member 'CoreGameFunctionLibrary_IsSimulatingInEditor::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.IsViewportInForeground
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_IsViewportInForeground final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_IsViewportInForeground) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_IsViewportInForeground");
static_assert(sizeof(CoreGameFunctionLibrary_IsViewportInForeground) == 0x000010, "Wrong size on CoreGameFunctionLibrary_IsViewportInForeground");
static_assert(offsetof(CoreGameFunctionLibrary_IsViewportInForeground, PlayerController) == 0x000000, "Member 'CoreGameFunctionLibrary_IsViewportInForeground::PlayerController' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_IsViewportInForeground, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_IsViewportInForeground::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.MakeBoxFromPoints
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_MakeBoxFromPoints final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FBox                                   ReturnValue;                                       // 0x0010(0x001C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_MakeBoxFromPoints) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_MakeBoxFromPoints");
static_assert(sizeof(CoreGameFunctionLibrary_MakeBoxFromPoints) == 0x000030, "Wrong size on CoreGameFunctionLibrary_MakeBoxFromPoints");
static_assert(offsetof(CoreGameFunctionLibrary_MakeBoxFromPoints, Points) == 0x000000, "Member 'CoreGameFunctionLibrary_MakeBoxFromPoints::Points' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MakeBoxFromPoints, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_MakeBoxFromPoints::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.MakeIntFromByteArray
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_MakeIntFromByteArray final
{
public:
	TArray<uint8>                                 Bytes;                                             // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_MakeIntFromByteArray) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_MakeIntFromByteArray");
static_assert(sizeof(CoreGameFunctionLibrary_MakeIntFromByteArray) == 0x000018, "Wrong size on CoreGameFunctionLibrary_MakeIntFromByteArray");
static_assert(offsetof(CoreGameFunctionLibrary_MakeIntFromByteArray, Bytes) == 0x000000, "Member 'CoreGameFunctionLibrary_MakeIntFromByteArray::Bytes' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MakeIntFromByteArray, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_MakeIntFromByteArray::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.MakeIntFromBytes
// 0x0008 (0x0008 - 0x0000)
struct CoreGameFunctionLibrary_MakeIntFromBytes final
{
public:
	uint8                                         OutByteA;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutByteB;                                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutByteC;                                          // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutByteD;                                          // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_MakeIntFromBytes) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_MakeIntFromBytes");
static_assert(sizeof(CoreGameFunctionLibrary_MakeIntFromBytes) == 0x000008, "Wrong size on CoreGameFunctionLibrary_MakeIntFromBytes");
static_assert(offsetof(CoreGameFunctionLibrary_MakeIntFromBytes, OutByteA) == 0x000000, "Member 'CoreGameFunctionLibrary_MakeIntFromBytes::OutByteA' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MakeIntFromBytes, OutByteB) == 0x000001, "Member 'CoreGameFunctionLibrary_MakeIntFromBytes::OutByteB' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MakeIntFromBytes, OutByteC) == 0x000002, "Member 'CoreGameFunctionLibrary_MakeIntFromBytes::OutByteC' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MakeIntFromBytes, OutByteD) == 0x000003, "Member 'CoreGameFunctionLibrary_MakeIntFromBytes::OutByteD' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MakeIntFromBytes, ReturnValue) == 0x000004, "Member 'CoreGameFunctionLibrary_MakeIntFromBytes::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.MoveActorsToLevel
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_MoveActorsToLevel final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class ULevel*                                 Level;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_MoveActorsToLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_MoveActorsToLevel");
static_assert(sizeof(CoreGameFunctionLibrary_MoveActorsToLevel) == 0x000018, "Wrong size on CoreGameFunctionLibrary_MoveActorsToLevel");
static_assert(offsetof(CoreGameFunctionLibrary_MoveActorsToLevel, Actors) == 0x000000, "Member 'CoreGameFunctionLibrary_MoveActorsToLevel::Actors' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MoveActorsToLevel, Level) == 0x000010, "Member 'CoreGameFunctionLibrary_MoveActorsToLevel::Level' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.MoveActorToLevel
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_MoveActorToLevel final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevel*                                 Level;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_MoveActorToLevel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_MoveActorToLevel");
static_assert(sizeof(CoreGameFunctionLibrary_MoveActorToLevel) == 0x000018, "Wrong size on CoreGameFunctionLibrary_MoveActorToLevel");
static_assert(offsetof(CoreGameFunctionLibrary_MoveActorToLevel, Actor) == 0x000000, "Member 'CoreGameFunctionLibrary_MoveActorToLevel::Actor' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MoveActorToLevel, Level) == 0x000008, "Member 'CoreGameFunctionLibrary_MoveActorToLevel::Level' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_MoveActorToLevel, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_MoveActorToLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.ObjectClassCollection_Identical
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_ObjectClassCollection_Identical final
{
public:
	struct FObjectClassCollection                 CollectionA;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FObjectClassCollection                 CollectionB;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_ObjectClassCollection_Identical) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_ObjectClassCollection_Identical");
static_assert(sizeof(CoreGameFunctionLibrary_ObjectClassCollection_Identical) == 0x000028, "Wrong size on CoreGameFunctionLibrary_ObjectClassCollection_Identical");
static_assert(offsetof(CoreGameFunctionLibrary_ObjectClassCollection_Identical, CollectionA) == 0x000000, "Member 'CoreGameFunctionLibrary_ObjectClassCollection_Identical::CollectionA' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ObjectClassCollection_Identical, CollectionB) == 0x000010, "Member 'CoreGameFunctionLibrary_ObjectClassCollection_Identical::CollectionB' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_ObjectClassCollection_Identical, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_ObjectClassCollection_Identical::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.OutwardSpiralLoop
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_OutwardSpiralLoop final
{
public:
	int32                                         GridSize;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FIntPoint& OffsetPoint, bool* bExitLoop)> Event;                                             // 0x0004(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_OutwardSpiralLoop) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_OutwardSpiralLoop");
static_assert(sizeof(CoreGameFunctionLibrary_OutwardSpiralLoop) == 0x000018, "Wrong size on CoreGameFunctionLibrary_OutwardSpiralLoop");
static_assert(offsetof(CoreGameFunctionLibrary_OutwardSpiralLoop, GridSize) == 0x000000, "Member 'CoreGameFunctionLibrary_OutwardSpiralLoop::GridSize' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_OutwardSpiralLoop, Event) == 0x000004, "Member 'CoreGameFunctionLibrary_OutwardSpiralLoop::Event' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_OutwardSpiralLoop, ReturnValue) == 0x000014, "Member 'CoreGameFunctionLibrary_OutwardSpiralLoop::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.PointBox2DSeparation
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_PointBox2DSeparation final
{
public:
	struct FVector2D                              Point;                                             // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 Box;                                               // 0x0008(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_PointBox2DSeparation) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_PointBox2DSeparation");
static_assert(sizeof(CoreGameFunctionLibrary_PointBox2DSeparation) == 0x000020, "Wrong size on CoreGameFunctionLibrary_PointBox2DSeparation");
static_assert(offsetof(CoreGameFunctionLibrary_PointBox2DSeparation, Point) == 0x000000, "Member 'CoreGameFunctionLibrary_PointBox2DSeparation::Point' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_PointBox2DSeparation, Box) == 0x000008, "Member 'CoreGameFunctionLibrary_PointBox2DSeparation::Box' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_PointBox2DSeparation, ReturnValue) == 0x00001C, "Member 'CoreGameFunctionLibrary_PointBox2DSeparation::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.PoseSkeletalMeshPhysics
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_PoseSkeletalMeshPhysics final
{
public:
	class USkeletalMeshComponent*                 FromSkeletalMeshComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 ToSkeletalMeshComponent;                           // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_PoseSkeletalMeshPhysics) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_PoseSkeletalMeshPhysics");
static_assert(sizeof(CoreGameFunctionLibrary_PoseSkeletalMeshPhysics) == 0x000010, "Wrong size on CoreGameFunctionLibrary_PoseSkeletalMeshPhysics");
static_assert(offsetof(CoreGameFunctionLibrary_PoseSkeletalMeshPhysics, FromSkeletalMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_PoseSkeletalMeshPhysics::FromSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_PoseSkeletalMeshPhysics, ToSkeletalMeshComponent) == 0x000008, "Member 'CoreGameFunctionLibrary_PoseSkeletalMeshPhysics::ToSkeletalMeshComponent' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.RandomIntegerInRangeExclusiveFromStream
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExcludeValue;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          Stream;                                            // 0x000C(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream");
static_assert(sizeof(CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream) == 0x000018, "Wrong size on CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream");
static_assert(offsetof(CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream, Min) == 0x000000, "Member 'CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream::Min' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream, Max) == 0x000004, "Member 'CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream::Max' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream, ExcludeValue) == 0x000008, "Member 'CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream::ExcludeValue' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream, Stream) == 0x00000C, "Member 'CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream::Stream' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream, ReturnValue) == 0x000014, "Member 'CoreGameFunctionLibrary_RandomIntegerInRangeExclusiveFromStream::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.RandomizeBits
// 0x0014 (0x0014 - 0x0000)
struct CoreGameFunctionLibrary_RandomizeBits final
{
public:
	int32                                         RandMinBitCount;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RandMaxBitCount;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalBitCount;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredBitPosition;                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_RandomizeBits) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_RandomizeBits");
static_assert(sizeof(CoreGameFunctionLibrary_RandomizeBits) == 0x000014, "Wrong size on CoreGameFunctionLibrary_RandomizeBits");
static_assert(offsetof(CoreGameFunctionLibrary_RandomizeBits, RandMinBitCount) == 0x000000, "Member 'CoreGameFunctionLibrary_RandomizeBits::RandMinBitCount' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RandomizeBits, RandMaxBitCount) == 0x000004, "Member 'CoreGameFunctionLibrary_RandomizeBits::RandMaxBitCount' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RandomizeBits, TotalBitCount) == 0x000008, "Member 'CoreGameFunctionLibrary_RandomizeBits::TotalBitCount' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RandomizeBits, RequiredBitPosition) == 0x00000C, "Member 'CoreGameFunctionLibrary_RandomizeBits::RequiredBitPosition' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RandomizeBits, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_RandomizeBits::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.RemoveDataTableRow
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_RemoveDataTableRow final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_RemoveDataTableRow) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_RemoveDataTableRow");
static_assert(sizeof(CoreGameFunctionLibrary_RemoveDataTableRow) == 0x000018, "Wrong size on CoreGameFunctionLibrary_RemoveDataTableRow");
static_assert(offsetof(CoreGameFunctionLibrary_RemoveDataTableRow, DataTable) == 0x000000, "Member 'CoreGameFunctionLibrary_RemoveDataTableRow::DataTable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RemoveDataTableRow, RowName) == 0x000008, "Member 'CoreGameFunctionLibrary_RemoveDataTableRow::RowName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RemoveDataTableRow, ReturnValue) == 0x000010, "Member 'CoreGameFunctionLibrary_RemoveDataTableRow::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.RotateDirectionTowards
// 0x0040 (0x0040 - 0x0000)
struct CoreGameFunctionLibrary_RotateDirectionTowards final
{
public:
	struct FVector                                CurrentDirection;                                  // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetDirection;                                   // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationAxis;                                      // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreesPerSecond;                                  // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutFinished;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0034(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_RotateDirectionTowards) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_RotateDirectionTowards");
static_assert(sizeof(CoreGameFunctionLibrary_RotateDirectionTowards) == 0x000040, "Wrong size on CoreGameFunctionLibrary_RotateDirectionTowards");
static_assert(offsetof(CoreGameFunctionLibrary_RotateDirectionTowards, CurrentDirection) == 0x000000, "Member 'CoreGameFunctionLibrary_RotateDirectionTowards::CurrentDirection' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RotateDirectionTowards, TargetDirection) == 0x00000C, "Member 'CoreGameFunctionLibrary_RotateDirectionTowards::TargetDirection' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RotateDirectionTowards, RotationAxis) == 0x000018, "Member 'CoreGameFunctionLibrary_RotateDirectionTowards::RotationAxis' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RotateDirectionTowards, DegreesPerSecond) == 0x000024, "Member 'CoreGameFunctionLibrary_RotateDirectionTowards::DegreesPerSecond' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RotateDirectionTowards, DeltaTime) == 0x000028, "Member 'CoreGameFunctionLibrary_RotateDirectionTowards::DeltaTime' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RotateDirectionTowards, Damping) == 0x00002C, "Member 'CoreGameFunctionLibrary_RotateDirectionTowards::Damping' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RotateDirectionTowards, OutFinished) == 0x000030, "Member 'CoreGameFunctionLibrary_RotateDirectionTowards::OutFinished' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_RotateDirectionTowards, ReturnValue) == 0x000034, "Member 'CoreGameFunctionLibrary_RotateDirectionTowards::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SafeFloatDivide
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_SafeFloatDivide final
{
public:
	float                                         N;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         D;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fallback;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SafeFloatDivide) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_SafeFloatDivide");
static_assert(sizeof(CoreGameFunctionLibrary_SafeFloatDivide) == 0x000010, "Wrong size on CoreGameFunctionLibrary_SafeFloatDivide");
static_assert(offsetof(CoreGameFunctionLibrary_SafeFloatDivide, N) == 0x000000, "Member 'CoreGameFunctionLibrary_SafeFloatDivide::N' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SafeFloatDivide, D) == 0x000004, "Member 'CoreGameFunctionLibrary_SafeFloatDivide::D' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SafeFloatDivide, Fallback) == 0x000008, "Member 'CoreGameFunctionLibrary_SafeFloatDivide::Fallback' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SafeFloatDivide, ReturnValue) == 0x00000C, "Member 'CoreGameFunctionLibrary_SafeFloatDivide::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetAutoDestroyAudioComponent
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_SetAutoDestroyAudioComponent final
{
public:
	class UAudioComponent*                        AudioComponent;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetAutoDestroyAudioComponent) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetAutoDestroyAudioComponent");
static_assert(sizeof(CoreGameFunctionLibrary_SetAutoDestroyAudioComponent) == 0x000010, "Wrong size on CoreGameFunctionLibrary_SetAutoDestroyAudioComponent");
static_assert(offsetof(CoreGameFunctionLibrary_SetAutoDestroyAudioComponent, AudioComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_SetAutoDestroyAudioComponent::AudioComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetAutoDestroyAudioComponent, bAutoDestroy) == 0x000008, "Member 'CoreGameFunctionLibrary_SetAutoDestroyAudioComponent::bAutoDestroy' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetCharacterUsesFastAttachedMove
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove final
{
public:
	class ACharacter*                             Character;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove");
static_assert(sizeof(CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove) == 0x000010, "Wrong size on CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove");
static_assert(offsetof(CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove, Character) == 0x000000, "Member 'CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove::Character' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove, bEnable) == 0x000008, "Member 'CoreGameFunctionLibrary_SetCharacterUsesFastAttachedMove::bEnable' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetCustomPrimitiveDataArray
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_SetCustomPrimitiveDataArray final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Values;                                            // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SetCustomPrimitiveDataArray) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetCustomPrimitiveDataArray");
static_assert(sizeof(CoreGameFunctionLibrary_SetCustomPrimitiveDataArray) == 0x000018, "Wrong size on CoreGameFunctionLibrary_SetCustomPrimitiveDataArray");
static_assert(offsetof(CoreGameFunctionLibrary_SetCustomPrimitiveDataArray, PrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_SetCustomPrimitiveDataArray::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetCustomPrimitiveDataArray, Values) == 0x000008, "Member 'CoreGameFunctionLibrary_SetCustomPrimitiveDataArray::Values' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetDataTableByteArrayProperty
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_SetDataTableByteArrayProperty final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 Values;                                            // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetDataTableByteArrayProperty) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetDataTableByteArrayProperty");
static_assert(sizeof(CoreGameFunctionLibrary_SetDataTableByteArrayProperty) == 0x000030, "Wrong size on CoreGameFunctionLibrary_SetDataTableByteArrayProperty");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableByteArrayProperty, DataTable) == 0x000000, "Member 'CoreGameFunctionLibrary_SetDataTableByteArrayProperty::DataTable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableByteArrayProperty, RowName) == 0x000008, "Member 'CoreGameFunctionLibrary_SetDataTableByteArrayProperty::RowName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableByteArrayProperty, PropertyName) == 0x000010, "Member 'CoreGameFunctionLibrary_SetDataTableByteArrayProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableByteArrayProperty, Values) == 0x000018, "Member 'CoreGameFunctionLibrary_SetDataTableByteArrayProperty::Values' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableByteArrayProperty, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_SetDataTableByteArrayProperty::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetDataTableIntegerArrayProperty
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Values;                                            // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty");
static_assert(sizeof(CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty) == 0x000030, "Wrong size on CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty, DataTable) == 0x000000, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty::DataTable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty, RowName) == 0x000008, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty::RowName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty, PropertyName) == 0x000010, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty, Values) == 0x000018, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty::Values' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerArrayProperty::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetDataTableIntegerProperty
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_SetDataTableIntegerProperty final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetDataTableIntegerProperty) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetDataTableIntegerProperty");
static_assert(sizeof(CoreGameFunctionLibrary_SetDataTableIntegerProperty) == 0x000020, "Wrong size on CoreGameFunctionLibrary_SetDataTableIntegerProperty");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerProperty, DataTable) == 0x000000, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerProperty::DataTable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerProperty, RowName) == 0x000008, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerProperty::RowName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerProperty, PropertyName) == 0x000010, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerProperty, Value) == 0x000018, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerProperty::Value' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableIntegerProperty, ReturnValue) == 0x00001C, "Member 'CoreGameFunctionLibrary_SetDataTableIntegerProperty::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetDataTableObjectProperty
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_SetDataTableObjectProperty final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                DataObject;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetDataTableObjectProperty) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetDataTableObjectProperty");
static_assert(sizeof(CoreGameFunctionLibrary_SetDataTableObjectProperty) == 0x000028, "Wrong size on CoreGameFunctionLibrary_SetDataTableObjectProperty");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableObjectProperty, DataTable) == 0x000000, "Member 'CoreGameFunctionLibrary_SetDataTableObjectProperty::DataTable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableObjectProperty, RowName) == 0x000008, "Member 'CoreGameFunctionLibrary_SetDataTableObjectProperty::RowName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableObjectProperty, PropertyName) == 0x000010, "Member 'CoreGameFunctionLibrary_SetDataTableObjectProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableObjectProperty, DataObject) == 0x000018, "Member 'CoreGameFunctionLibrary_SetDataTableObjectProperty::DataObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableObjectProperty, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_SetDataTableObjectProperty::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetDataTableStructArrayProperty
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_SetDataTableStructArrayProperty final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        StructArray;                                       // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetDataTableStructArrayProperty) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetDataTableStructArrayProperty");
static_assert(sizeof(CoreGameFunctionLibrary_SetDataTableStructArrayProperty) == 0x000030, "Wrong size on CoreGameFunctionLibrary_SetDataTableStructArrayProperty");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableStructArrayProperty, DataTable) == 0x000000, "Member 'CoreGameFunctionLibrary_SetDataTableStructArrayProperty::DataTable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableStructArrayProperty, RowName) == 0x000008, "Member 'CoreGameFunctionLibrary_SetDataTableStructArrayProperty::RowName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableStructArrayProperty, PropertyName) == 0x000010, "Member 'CoreGameFunctionLibrary_SetDataTableStructArrayProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableStructArrayProperty, StructArray) == 0x000018, "Member 'CoreGameFunctionLibrary_SetDataTableStructArrayProperty::StructArray' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDataTableStructArrayProperty, ReturnValue) == 0x000028, "Member 'CoreGameFunctionLibrary_SetDataTableStructArrayProperty::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetDefaultCustomPrimitiveDataFloat
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat");
static_assert(sizeof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat) == 0x000010, "Wrong size on CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat");
static_assert(offsetof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat, PrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat, DataIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat::DataIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat, Value) == 0x00000C, "Member 'CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataFloat::Value' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetDefaultCustomPrimitiveDataVector4
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4 final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataIndex;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               Value;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4");
static_assert(sizeof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4) == 0x000020, "Wrong size on CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4");
static_assert(offsetof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4, PrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4, DataIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4::DataIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4, Value) == 0x000010, "Member 'CoreGameFunctionLibrary_SetDefaultCustomPrimitiveDataVector4::Value' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetPrimitiveNotifyRigidBodyCollision
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotifyRigidBodyCollision;                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision");
static_assert(sizeof(CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision) == 0x000010, "Wrong size on CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision");
static_assert(offsetof(CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision, PrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision, bNotifyRigidBodyCollision) == 0x000008, "Member 'CoreGameFunctionLibrary_SetPrimitiveNotifyRigidBodyCollision::bNotifyRigidBodyCollision' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetPrimitiveStartsAwake
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_SetPrimitiveStartsAwake final
{
public:
	class UPrimitiveComponent*                    PrimitiveComponent;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartsAwake;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetPrimitiveStartsAwake) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetPrimitiveStartsAwake");
static_assert(sizeof(CoreGameFunctionLibrary_SetPrimitiveStartsAwake) == 0x000010, "Wrong size on CoreGameFunctionLibrary_SetPrimitiveStartsAwake");
static_assert(offsetof(CoreGameFunctionLibrary_SetPrimitiveStartsAwake, PrimitiveComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_SetPrimitiveStartsAwake::PrimitiveComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetPrimitiveStartsAwake, bStartsAwake) == 0x000008, "Member 'CoreGameFunctionLibrary_SetPrimitiveStartsAwake::bStartsAwake' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetRotationAtSplinePoint
// 0x0020 (0x0020 - 0x0000)
struct CoreGameFunctionLibrary_SetRotationAtSplinePoint final
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointIndex;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetRotationAtSplinePoint) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetRotationAtSplinePoint");
static_assert(sizeof(CoreGameFunctionLibrary_SetRotationAtSplinePoint) == 0x000020, "Wrong size on CoreGameFunctionLibrary_SetRotationAtSplinePoint");
static_assert(offsetof(CoreGameFunctionLibrary_SetRotationAtSplinePoint, SplineComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_SetRotationAtSplinePoint::SplineComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetRotationAtSplinePoint, PointIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_SetRotationAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetRotationAtSplinePoint, Rotation) == 0x00000C, "Member 'CoreGameFunctionLibrary_SetRotationAtSplinePoint::Rotation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetRotationAtSplinePoint, CoordinateSpace) == 0x000018, "Member 'CoreGameFunctionLibrary_SetRotationAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetRotationAtSplinePoint, bUpdateSpline) == 0x000019, "Member 'CoreGameFunctionLibrary_SetRotationAtSplinePoint::bUpdateSpline' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetSkeletalMeshVertexColorsUniformSingleChannel
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChannelIndex;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ChannelValue;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel");
static_assert(sizeof(CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel) == 0x000018, "Wrong size on CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel");
static_assert(offsetof(CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel, SkeletalMesh) == 0x000000, "Member 'CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel, LODIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel::LODIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel, ChannelIndex) == 0x00000C, "Member 'CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel::ChannelIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel, ChannelValue) == 0x000010, "Member 'CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel::ChannelValue' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel, ReturnValue) == 0x000011, "Member 'CoreGameFunctionLibrary_SetSkeletalMeshVertexColorsUniformSingleChannel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetSlateCursorRadius
// 0x0004 (0x0004 - 0x0000)
struct CoreGameFunctionLibrary_SetSlateCursorRadius final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SetSlateCursorRadius) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_SetSlateCursorRadius");
static_assert(sizeof(CoreGameFunctionLibrary_SetSlateCursorRadius) == 0x000004, "Wrong size on CoreGameFunctionLibrary_SetSlateCursorRadius");
static_assert(offsetof(CoreGameFunctionLibrary_SetSlateCursorRadius, Radius) == 0x000000, "Member 'CoreGameFunctionLibrary_SetSlateCursorRadius::Radius' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetStaticMeshVertexColors
// 0x0068 (0x0068 - 0x0000)
struct CoreGameFunctionLibrary_SetStaticMeshVertexColors final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FLinearColor>              VertexIndexColorMap;                               // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bConvertToSRGB;                                    // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0061(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetStaticMeshVertexColors) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetStaticMeshVertexColors");
static_assert(sizeof(CoreGameFunctionLibrary_SetStaticMeshVertexColors) == 0x000068, "Wrong size on CoreGameFunctionLibrary_SetStaticMeshVertexColors");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVertexColors, StaticMesh) == 0x000000, "Member 'CoreGameFunctionLibrary_SetStaticMeshVertexColors::StaticMesh' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVertexColors, LODIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_SetStaticMeshVertexColors::LODIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVertexColors, VertexIndexColorMap) == 0x000010, "Member 'CoreGameFunctionLibrary_SetStaticMeshVertexColors::VertexIndexColorMap' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVertexColors, bConvertToSRGB) == 0x000060, "Member 'CoreGameFunctionLibrary_SetStaticMeshVertexColors::bConvertToSRGB' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVertexColors, ReturnValue) == 0x000061, "Member 'CoreGameFunctionLibrary_SetStaticMeshVertexColors::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SetStaticMeshVerticesToOverrideColor
// 0x0088 (0x0088 - 0x0000)
struct CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODIndex;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   VertexIndices;                                     // 0x0010(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColor;                                         // 0x0060(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColor;                                      // 0x0070(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConvertToSRGB;                                    // 0x0080(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0081(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor");
static_assert(sizeof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor) == 0x000088, "Wrong size on CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor, StaticMeshComponent) == 0x000000, "Member 'CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor, LODIndex) == 0x000008, "Member 'CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor::LODIndex' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor, VertexIndices) == 0x000010, "Member 'CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor::VertexIndices' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor, FillColor) == 0x000060, "Member 'CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor::FillColor' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor, DefaultColor) == 0x000070, "Member 'CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor::DefaultColor' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor, bConvertToSRGB) == 0x000080, "Member 'CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor::bConvertToSRGB' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor, ReturnValue) == 0x000081, "Member 'CoreGameFunctionLibrary_SetStaticMeshVerticesToOverrideColor::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SignedAngleBetweenNormals
// 0x001C (0x001C - 0x0000)
struct CoreGameFunctionLibrary_SignedAngleBetweenNormals final
{
public:
	struct FVector                                SourceVector;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SignedAngleBetweenNormals) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_SignedAngleBetweenNormals");
static_assert(sizeof(CoreGameFunctionLibrary_SignedAngleBetweenNormals) == 0x00001C, "Wrong size on CoreGameFunctionLibrary_SignedAngleBetweenNormals");
static_assert(offsetof(CoreGameFunctionLibrary_SignedAngleBetweenNormals, SourceVector) == 0x000000, "Member 'CoreGameFunctionLibrary_SignedAngleBetweenNormals::SourceVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SignedAngleBetweenNormals, TargetVector) == 0x00000C, "Member 'CoreGameFunctionLibrary_SignedAngleBetweenNormals::TargetVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SignedAngleBetweenNormals, ReturnValue) == 0x000018, "Member 'CoreGameFunctionLibrary_SignedAngleBetweenNormals::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SignedAngleBetweenOnPlane
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_SignedAngleBetweenOnPlane final
{
public:
	struct FVector                                SourceVector;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetVector;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x0018(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SignedAngleBetweenOnPlane) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_SignedAngleBetweenOnPlane");
static_assert(sizeof(CoreGameFunctionLibrary_SignedAngleBetweenOnPlane) == 0x000028, "Wrong size on CoreGameFunctionLibrary_SignedAngleBetweenOnPlane");
static_assert(offsetof(CoreGameFunctionLibrary_SignedAngleBetweenOnPlane, SourceVector) == 0x000000, "Member 'CoreGameFunctionLibrary_SignedAngleBetweenOnPlane::SourceVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SignedAngleBetweenOnPlane, TargetVector) == 0x00000C, "Member 'CoreGameFunctionLibrary_SignedAngleBetweenOnPlane::TargetVector' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SignedAngleBetweenOnPlane, PlaneNormal) == 0x000018, "Member 'CoreGameFunctionLibrary_SignedAngleBetweenOnPlane::PlaneNormal' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SignedAngleBetweenOnPlane, ReturnValue) == 0x000024, "Member 'CoreGameFunctionLibrary_SignedAngleBetweenOnPlane::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SortActorsByDistanceFromWorldLocation
// 0x0030 (0x0030 - 0x0000)
struct CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation");
static_assert(sizeof(CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation) == 0x000030, "Wrong size on CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation");
static_assert(offsetof(CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation, Actors) == 0x000000, "Member 'CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation::Actors' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation, WorldLocation) == 0x000010, "Member 'CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation, ReturnValue) == 0x000020, "Member 'CoreGameFunctionLibrary_SortActorsByDistanceFromWorldLocation::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SortObjectsUsingPredicate
// 0x0028 (0x0028 - 0x0000)
struct CoreGameFunctionLibrary_SortObjectsUsingPredicate final
{
public:
	TArray<class UObject*>                        Objects;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bStable;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UObject* ObjectA, class UObject* ObjectB)> Predicate;                                         // 0x0014(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SortObjectsUsingPredicate) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_SortObjectsUsingPredicate");
static_assert(sizeof(CoreGameFunctionLibrary_SortObjectsUsingPredicate) == 0x000028, "Wrong size on CoreGameFunctionLibrary_SortObjectsUsingPredicate");
static_assert(offsetof(CoreGameFunctionLibrary_SortObjectsUsingPredicate, Objects) == 0x000000, "Member 'CoreGameFunctionLibrary_SortObjectsUsingPredicate::Objects' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SortObjectsUsingPredicate, bStable) == 0x000010, "Member 'CoreGameFunctionLibrary_SortObjectsUsingPredicate::bStable' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SortObjectsUsingPredicate, Predicate) == 0x000014, "Member 'CoreGameFunctionLibrary_SortObjectsUsingPredicate::Predicate' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SpawnActorInLevel
// 0x0060 (0x0060 - 0x0000)
struct CoreGameFunctionLibrary_SpawnActorInLevel final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ActorTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAdjustIfPossible;                                 // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevel*                                 Level;                                             // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SpawnActorInLevel) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_SpawnActorInLevel");
static_assert(sizeof(CoreGameFunctionLibrary_SpawnActorInLevel) == 0x000060, "Wrong size on CoreGameFunctionLibrary_SpawnActorInLevel");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevel, ActorClass) == 0x000000, "Member 'CoreGameFunctionLibrary_SpawnActorInLevel::ActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevel, ActorTransform) == 0x000010, "Member 'CoreGameFunctionLibrary_SpawnActorInLevel::ActorTransform' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevel, bAdjustIfPossible) == 0x000040, "Member 'CoreGameFunctionLibrary_SpawnActorInLevel::bAdjustIfPossible' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevel, Level) == 0x000048, "Member 'CoreGameFunctionLibrary_SpawnActorInLevel::Level' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevel, Instigator) == 0x000050, "Member 'CoreGameFunctionLibrary_SpawnActorInLevel::Instigator' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevel, ReturnValue) == 0x000058, "Member 'CoreGameFunctionLibrary_SpawnActorInLevel::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SpawnActorInLevelWithName
// 0x0060 (0x0060 - 0x0000)
struct CoreGameFunctionLibrary_SpawnActorInLevelWithName final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ActorTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAdjustIfPossible;                                 // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevel*                                 Level;                                             // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  Instigator;                                        // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0058(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_SpawnActorInLevelWithName) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_SpawnActorInLevelWithName");
static_assert(sizeof(CoreGameFunctionLibrary_SpawnActorInLevelWithName) == 0x000060, "Wrong size on CoreGameFunctionLibrary_SpawnActorInLevelWithName");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevelWithName, ActorClass) == 0x000000, "Member 'CoreGameFunctionLibrary_SpawnActorInLevelWithName::ActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevelWithName, ActorName) == 0x000008, "Member 'CoreGameFunctionLibrary_SpawnActorInLevelWithName::ActorName' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevelWithName, ActorTransform) == 0x000010, "Member 'CoreGameFunctionLibrary_SpawnActorInLevelWithName::ActorTransform' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevelWithName, bAdjustIfPossible) == 0x000040, "Member 'CoreGameFunctionLibrary_SpawnActorInLevelWithName::bAdjustIfPossible' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevelWithName, Level) == 0x000048, "Member 'CoreGameFunctionLibrary_SpawnActorInLevelWithName::Level' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevelWithName, Instigator) == 0x000050, "Member 'CoreGameFunctionLibrary_SpawnActorInLevelWithName::Instigator' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInLevelWithName, ReturnValue) == 0x000058, "Member 'CoreGameFunctionLibrary_SpawnActorInLevelWithName::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.SpawnActorInWorld
// 0x0060 (0x0060 - 0x0000)
struct CoreGameFunctionLibrary_SpawnActorInWorld final
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ActorTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bAdjustIfPossible;                                 // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                WorldContextObject;                                // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CoreGameFunctionLibrary_SpawnActorInWorld) == 0x000010, "Wrong alignment on CoreGameFunctionLibrary_SpawnActorInWorld");
static_assert(sizeof(CoreGameFunctionLibrary_SpawnActorInWorld) == 0x000060, "Wrong size on CoreGameFunctionLibrary_SpawnActorInWorld");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInWorld, ActorClass) == 0x000000, "Member 'CoreGameFunctionLibrary_SpawnActorInWorld::ActorClass' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInWorld, ActorTransform) == 0x000010, "Member 'CoreGameFunctionLibrary_SpawnActorInWorld::ActorTransform' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInWorld, bAdjustIfPossible) == 0x000040, "Member 'CoreGameFunctionLibrary_SpawnActorInWorld::bAdjustIfPossible' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInWorld, WorldContextObject) == 0x000048, "Member 'CoreGameFunctionLibrary_SpawnActorInWorld::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_SpawnActorInWorld, ReturnValue) == 0x000050, "Member 'CoreGameFunctionLibrary_SpawnActorInWorld::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.TimeSecondsToStringHMS
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_TimeSecondsToStringHMS final
{
public:
	int32                                         TotalSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_TimeSecondsToStringHMS) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_TimeSecondsToStringHMS");
static_assert(sizeof(CoreGameFunctionLibrary_TimeSecondsToStringHMS) == 0x000018, "Wrong size on CoreGameFunctionLibrary_TimeSecondsToStringHMS");
static_assert(offsetof(CoreGameFunctionLibrary_TimeSecondsToStringHMS, TotalSeconds) == 0x000000, "Member 'CoreGameFunctionLibrary_TimeSecondsToStringHMS::TotalSeconds' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_TimeSecondsToStringHMS, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_TimeSecondsToStringHMS::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.TimeSecondsToStringMS
// 0x0018 (0x0018 - 0x0000)
struct CoreGameFunctionLibrary_TimeSecondsToStringMS final
{
public:
	int32                                         TotalSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_TimeSecondsToStringMS) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_TimeSecondsToStringMS");
static_assert(sizeof(CoreGameFunctionLibrary_TimeSecondsToStringMS) == 0x000018, "Wrong size on CoreGameFunctionLibrary_TimeSecondsToStringMS");
static_assert(offsetof(CoreGameFunctionLibrary_TimeSecondsToStringMS, TotalSeconds) == 0x000000, "Member 'CoreGameFunctionLibrary_TimeSecondsToStringMS::TotalSeconds' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_TimeSecondsToStringMS, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_TimeSecondsToStringMS::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.UnbindMontageOnBlendOutStarted
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted");
static_assert(sizeof(CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted) == 0x000010, "Wrong size on CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted");
static_assert(offsetof(CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted, AnimInstance) == 0x000000, "Member 'CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted::AnimInstance' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted, Montage) == 0x000008, "Member 'CoreGameFunctionLibrary_UnbindMontageOnBlendOutStarted::Montage' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.UnbindMontageOnEnded
// 0x0010 (0x0010 - 0x0000)
struct CoreGameFunctionLibrary_UnbindMontageOnEnded final
{
public:
	class UAnimInstance*                          AnimInstance;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_UnbindMontageOnEnded) == 0x000008, "Wrong alignment on CoreGameFunctionLibrary_UnbindMontageOnEnded");
static_assert(sizeof(CoreGameFunctionLibrary_UnbindMontageOnEnded) == 0x000010, "Wrong size on CoreGameFunctionLibrary_UnbindMontageOnEnded");
static_assert(offsetof(CoreGameFunctionLibrary_UnbindMontageOnEnded, AnimInstance) == 0x000000, "Member 'CoreGameFunctionLibrary_UnbindMontageOnEnded::AnimInstance' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_UnbindMontageOnEnded, Montage) == 0x000008, "Member 'CoreGameFunctionLibrary_UnbindMontageOnEnded::Montage' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.WrapIntLowerbound
// 0x000C (0x000C - 0x0000)
struct CoreGameFunctionLibrary_WrapIntLowerbound final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_WrapIntLowerbound) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_WrapIntLowerbound");
static_assert(sizeof(CoreGameFunctionLibrary_WrapIntLowerbound) == 0x00000C, "Wrong size on CoreGameFunctionLibrary_WrapIntLowerbound");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntLowerbound, Value) == 0x000000, "Member 'CoreGameFunctionLibrary_WrapIntLowerbound::Value' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntLowerbound, Size) == 0x000004, "Member 'CoreGameFunctionLibrary_WrapIntLowerbound::Size' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntLowerbound, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_WrapIntLowerbound::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.WrapIntOnce
// 0x000C (0x000C - 0x0000)
struct CoreGameFunctionLibrary_WrapIntOnce final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_WrapIntOnce) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_WrapIntOnce");
static_assert(sizeof(CoreGameFunctionLibrary_WrapIntOnce) == 0x00000C, "Wrong size on CoreGameFunctionLibrary_WrapIntOnce");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntOnce, Value) == 0x000000, "Member 'CoreGameFunctionLibrary_WrapIntOnce::Value' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntOnce, Size) == 0x000004, "Member 'CoreGameFunctionLibrary_WrapIntOnce::Size' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntOnce, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_WrapIntOnce::ReturnValue' has a wrong offset!");

// Function CoreGame.CoreGameFunctionLibrary.WrapIntUpperbound
// 0x000C (0x000C - 0x0000)
struct CoreGameFunctionLibrary_WrapIntUpperbound final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CoreGameFunctionLibrary_WrapIntUpperbound) == 0x000004, "Wrong alignment on CoreGameFunctionLibrary_WrapIntUpperbound");
static_assert(sizeof(CoreGameFunctionLibrary_WrapIntUpperbound) == 0x00000C, "Wrong size on CoreGameFunctionLibrary_WrapIntUpperbound");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntUpperbound, Value) == 0x000000, "Member 'CoreGameFunctionLibrary_WrapIntUpperbound::Value' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntUpperbound, Size) == 0x000004, "Member 'CoreGameFunctionLibrary_WrapIntUpperbound::Size' has a wrong offset!");
static_assert(offsetof(CoreGameFunctionLibrary_WrapIntUpperbound, ReturnValue) == 0x000008, "Member 'CoreGameFunctionLibrary_WrapIntUpperbound::ReturnValue' has a wrong offset!");

// Function CoreGame.Electrocardiogram.SetHeartRate
// 0x0004 (0x0004 - 0x0000)
struct Electrocardiogram_SetHeartRate final
{
public:
	float                                         BeatsPerMinute;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Electrocardiogram_SetHeartRate) == 0x000004, "Wrong alignment on Electrocardiogram_SetHeartRate");
static_assert(sizeof(Electrocardiogram_SetHeartRate) == 0x000004, "Wrong size on Electrocardiogram_SetHeartRate");
static_assert(offsetof(Electrocardiogram_SetHeartRate, BeatsPerMinute) == 0x000000, "Member 'Electrocardiogram_SetHeartRate::BeatsPerMinute' has a wrong offset!");

// Function CoreGame.Electrocardiogram.SetMovementArtifacts
// 0x0004 (0x0004 - 0x0000)
struct Electrocardiogram_SetMovementArtifacts final
{
public:
	float                                         Amount;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Electrocardiogram_SetMovementArtifacts) == 0x000004, "Wrong alignment on Electrocardiogram_SetMovementArtifacts");
static_assert(sizeof(Electrocardiogram_SetMovementArtifacts) == 0x000004, "Wrong size on Electrocardiogram_SetMovementArtifacts");
static_assert(offsetof(Electrocardiogram_SetMovementArtifacts, Amount) == 0x000000, "Member 'Electrocardiogram_SetMovementArtifacts::Amount' has a wrong offset!");

// Function CoreGame.Electrocardiogram.SetPulseInterval
// 0x0004 (0x0004 - 0x0000)
struct Electrocardiogram_SetPulseInterval final
{
public:
	float                                         Interval;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Electrocardiogram_SetPulseInterval) == 0x000004, "Wrong alignment on Electrocardiogram_SetPulseInterval");
static_assert(sizeof(Electrocardiogram_SetPulseInterval) == 0x000004, "Wrong size on Electrocardiogram_SetPulseInterval");
static_assert(offsetof(Electrocardiogram_SetPulseInterval, Interval) == 0x000000, "Member 'Electrocardiogram_SetPulseInterval::Interval' has a wrong offset!");

// Function CoreGame.Electrocardiogram.SetShouldUpdateAverageHeartRate
// 0x0001 (0x0001 - 0x0000)
struct Electrocardiogram_SetShouldUpdateAverageHeartRate final
{
public:
	bool                                          bUpdate;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Electrocardiogram_SetShouldUpdateAverageHeartRate) == 0x000001, "Wrong alignment on Electrocardiogram_SetShouldUpdateAverageHeartRate");
static_assert(sizeof(Electrocardiogram_SetShouldUpdateAverageHeartRate) == 0x000001, "Wrong size on Electrocardiogram_SetShouldUpdateAverageHeartRate");
static_assert(offsetof(Electrocardiogram_SetShouldUpdateAverageHeartRate, bUpdate) == 0x000000, "Member 'Electrocardiogram_SetShouldUpdateAverageHeartRate::bUpdate' has a wrong offset!");

// Function CoreGame.Electrocardiogram.Update
// 0x0004 (0x0004 - 0x0000)
struct Electrocardiogram_Update final
{
public:
	float                                         ElapsedTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Electrocardiogram_Update) == 0x000004, "Wrong alignment on Electrocardiogram_Update");
static_assert(sizeof(Electrocardiogram_Update) == 0x000004, "Wrong size on Electrocardiogram_Update");
static_assert(offsetof(Electrocardiogram_Update, ElapsedTime) == 0x000000, "Member 'Electrocardiogram_Update::ElapsedTime' has a wrong offset!");

// Function CoreGame.FileReader.LoadFile
// 0x0018 (0x0018 - 0x0000)
struct FileReader_LoadFile final
{
public:
	class FString                                 FilePath;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FileReader_LoadFile) == 0x000008, "Wrong alignment on FileReader_LoadFile");
static_assert(sizeof(FileReader_LoadFile) == 0x000018, "Wrong size on FileReader_LoadFile");
static_assert(offsetof(FileReader_LoadFile, FilePath) == 0x000000, "Member 'FileReader_LoadFile::FilePath' has a wrong offset!");
static_assert(offsetof(FileReader_LoadFile, ReturnValue) == 0x000010, "Member 'FileReader_LoadFile::ReturnValue' has a wrong offset!");

// Function CoreGame.FileReader.ReadByteArray
// 0x0018 (0x0018 - 0x0000)
struct FileReader_ReadByteArray final
{
public:
	int32                                         ByteCount;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FileReader_ReadByteArray) == 0x000008, "Wrong alignment on FileReader_ReadByteArray");
static_assert(sizeof(FileReader_ReadByteArray) == 0x000018, "Wrong size on FileReader_ReadByteArray");
static_assert(offsetof(FileReader_ReadByteArray, ByteCount) == 0x000000, "Member 'FileReader_ReadByteArray::ByteCount' has a wrong offset!");
static_assert(offsetof(FileReader_ReadByteArray, ReturnValue) == 0x000008, "Member 'FileReader_ReadByteArray::ReturnValue' has a wrong offset!");

// Function CoreGame.FileReader.ReadInteger
// 0x0004 (0x0004 - 0x0000)
struct FileReader_ReadInteger final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FileReader_ReadInteger) == 0x000004, "Wrong alignment on FileReader_ReadInteger");
static_assert(sizeof(FileReader_ReadInteger) == 0x000004, "Wrong size on FileReader_ReadInteger");
static_assert(offsetof(FileReader_ReadInteger, ReturnValue) == 0x000000, "Member 'FileReader_ReadInteger::ReturnValue' has a wrong offset!");

// Function CoreGame.WorldObject.SetOuterObject
// 0x0008 (0x0008 - 0x0000)
struct WorldObject_SetOuterObject final
{
public:
	class UObject*                                NewOuterObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldObject_SetOuterObject) == 0x000008, "Wrong alignment on WorldObject_SetOuterObject");
static_assert(sizeof(WorldObject_SetOuterObject) == 0x000008, "Wrong size on WorldObject_SetOuterObject");
static_assert(offsetof(WorldObject_SetOuterObject, NewOuterObject) == 0x000000, "Member 'WorldObject_SetOuterObject::NewOuterObject' has a wrong offset!");

// Function CoreGame.WorldObject.SetOuterObjectToActorLevel
// 0x0008 (0x0008 - 0x0000)
struct WorldObject_SetOuterObjectToActorLevel final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldObject_SetOuterObjectToActorLevel) == 0x000008, "Wrong alignment on WorldObject_SetOuterObjectToActorLevel");
static_assert(sizeof(WorldObject_SetOuterObjectToActorLevel) == 0x000008, "Wrong size on WorldObject_SetOuterObjectToActorLevel");
static_assert(offsetof(WorldObject_SetOuterObjectToActorLevel, Actor) == 0x000000, "Member 'WorldObject_SetOuterObjectToActorLevel::Actor' has a wrong offset!");

// Function CoreGame.WorldObject.GetOuterObject
// 0x0008 (0x0008 - 0x0000)
struct WorldObject_GetOuterObject final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WorldObject_GetOuterObject) == 0x000008, "Wrong alignment on WorldObject_GetOuterObject");
static_assert(sizeof(WorldObject_GetOuterObject) == 0x000008, "Wrong size on WorldObject_GetOuterObject");
static_assert(offsetof(WorldObject_GetOuterObject, ReturnValue) == 0x000000, "Member 'WorldObject_GetOuterObject::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.AddWall
// 0x0014 (0x0014 - 0x0000)
struct GridLevelObject_AddWall final
{
public:
	struct FIntRectangle                          CellPair;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WallFlags;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_AddWall) == 0x000004, "Wrong alignment on GridLevelObject_AddWall");
static_assert(sizeof(GridLevelObject_AddWall) == 0x000014, "Wrong size on GridLevelObject_AddWall");
static_assert(offsetof(GridLevelObject_AddWall, CellPair) == 0x000000, "Member 'GridLevelObject_AddWall::CellPair' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddWall, WallFlags) == 0x000010, "Member 'GridLevelObject_AddWall::WallFlags' has a wrong offset!");

// Function CoreGame.GridLevelObject.BreakWall
// 0x0014 (0x0014 - 0x0000)
struct GridLevelObject_BreakWall final
{
public:
	struct FIntRectangle                          CellPair;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_BreakWall) == 0x000004, "Wrong alignment on GridLevelObject_BreakWall");
static_assert(sizeof(GridLevelObject_BreakWall) == 0x000014, "Wrong size on GridLevelObject_BreakWall");
static_assert(offsetof(GridLevelObject_BreakWall, CellPair) == 0x000000, "Member 'GridLevelObject_BreakWall::CellPair' has a wrong offset!");
static_assert(offsetof(GridLevelObject_BreakWall, ReturnValue) == 0x000010, "Member 'GridLevelObject_BreakWall::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.GenerateTraversableCellSets
// 0x0018 (0x0018 - 0x0000)
struct GridLevelObject_GenerateTraversableCellSets final
{
public:
	int32                                         TerrainTraverseFlags;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIntPoint>                      SourceCellLocations;                               // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_GenerateTraversableCellSets) == 0x000008, "Wrong alignment on GridLevelObject_GenerateTraversableCellSets");
static_assert(sizeof(GridLevelObject_GenerateTraversableCellSets) == 0x000018, "Wrong size on GridLevelObject_GenerateTraversableCellSets");
static_assert(offsetof(GridLevelObject_GenerateTraversableCellSets, TerrainTraverseFlags) == 0x000000, "Member 'GridLevelObject_GenerateTraversableCellSets::TerrainTraverseFlags' has a wrong offset!");
static_assert(offsetof(GridLevelObject_GenerateTraversableCellSets, SourceCellLocations) == 0x000008, "Member 'GridLevelObject_GenerateTraversableCellSets::SourceCellLocations' has a wrong offset!");

// Function CoreGame.GridLevelObject.SetCellTerrainTypes
// 0x0050 (0x0050 - 0x0000)
struct GridLevelObject_SetCellTerrainTypes final
{
public:
	TMap<struct FIntPoint, uint8>                 CellTerrainTypeMap;                                // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_SetCellTerrainTypes) == 0x000008, "Wrong alignment on GridLevelObject_SetCellTerrainTypes");
static_assert(sizeof(GridLevelObject_SetCellTerrainTypes) == 0x000050, "Wrong size on GridLevelObject_SetCellTerrainTypes");
static_assert(offsetof(GridLevelObject_SetCellTerrainTypes, CellTerrainTypeMap) == 0x000000, "Member 'GridLevelObject_SetCellTerrainTypes::CellTerrainTypeMap' has a wrong offset!");

// Function CoreGame.GridLevelObject.SetTerrainTypeAtCellLocation
// 0x000C (0x000C - 0x0000)
struct GridLevelObject_SetTerrainTypeAtCellLocation final
{
public:
	struct FIntPoint                              CellLocation;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TerrainType;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_SetTerrainTypeAtCellLocation) == 0x000004, "Wrong alignment on GridLevelObject_SetTerrainTypeAtCellLocation");
static_assert(sizeof(GridLevelObject_SetTerrainTypeAtCellLocation) == 0x00000C, "Wrong size on GridLevelObject_SetTerrainTypeAtCellLocation");
static_assert(offsetof(GridLevelObject_SetTerrainTypeAtCellLocation, CellLocation) == 0x000000, "Member 'GridLevelObject_SetTerrainTypeAtCellLocation::CellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_SetTerrainTypeAtCellLocation, TerrainType) == 0x000008, "Member 'GridLevelObject_SetTerrainTypeAtCellLocation::TerrainType' has a wrong offset!");
static_assert(offsetof(GridLevelObject_SetTerrainTypeAtCellLocation, ReturnValue) == 0x000009, "Member 'GridLevelObject_SetTerrainTypeAtCellLocation::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.AddPathableCellsInCardinalDirections
// 0x0060 (0x0060 - 0x0000)
struct GridLevelObject_AddPathableCellsInCardinalDirections final
{
public:
	struct FIntPoint                              SourceCellLocation;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TerrainTraverseFlags;                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCellRange;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<struct FIntPoint>                        PathableCells;                                     // 0x0010(0x0050)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_AddPathableCellsInCardinalDirections) == 0x000008, "Wrong alignment on GridLevelObject_AddPathableCellsInCardinalDirections");
static_assert(sizeof(GridLevelObject_AddPathableCellsInCardinalDirections) == 0x000060, "Wrong size on GridLevelObject_AddPathableCellsInCardinalDirections");
static_assert(offsetof(GridLevelObject_AddPathableCellsInCardinalDirections, SourceCellLocation) == 0x000000, "Member 'GridLevelObject_AddPathableCellsInCardinalDirections::SourceCellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddPathableCellsInCardinalDirections, TerrainTraverseFlags) == 0x000008, "Member 'GridLevelObject_AddPathableCellsInCardinalDirections::TerrainTraverseFlags' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddPathableCellsInCardinalDirections, MaxCellRange) == 0x00000C, "Member 'GridLevelObject_AddPathableCellsInCardinalDirections::MaxCellRange' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddPathableCellsInCardinalDirections, PathableCells) == 0x000010, "Member 'GridLevelObject_AddPathableCellsInCardinalDirections::PathableCells' has a wrong offset!");

// Function CoreGame.GridLevelObject.AddPathableCellsInDirection
// 0x0070 (0x0070 - 0x0000)
struct GridLevelObject_AddPathableCellsInDirection final
{
public:
	struct FIntPoint                              SourceCellLocation;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              CellDirection;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TerrainTraverseFlags;                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCellRange;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<struct FIntPoint>                        PathableCells;                                     // 0x0018(0x0050)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FIntPoint                              ReturnValue;                                       // 0x0068(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_AddPathableCellsInDirection) == 0x000008, "Wrong alignment on GridLevelObject_AddPathableCellsInDirection");
static_assert(sizeof(GridLevelObject_AddPathableCellsInDirection) == 0x000070, "Wrong size on GridLevelObject_AddPathableCellsInDirection");
static_assert(offsetof(GridLevelObject_AddPathableCellsInDirection, SourceCellLocation) == 0x000000, "Member 'GridLevelObject_AddPathableCellsInDirection::SourceCellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddPathableCellsInDirection, CellDirection) == 0x000008, "Member 'GridLevelObject_AddPathableCellsInDirection::CellDirection' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddPathableCellsInDirection, TerrainTraverseFlags) == 0x000010, "Member 'GridLevelObject_AddPathableCellsInDirection::TerrainTraverseFlags' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddPathableCellsInDirection, MaxCellRange) == 0x000014, "Member 'GridLevelObject_AddPathableCellsInDirection::MaxCellRange' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddPathableCellsInDirection, PathableCells) == 0x000018, "Member 'GridLevelObject_AddPathableCellsInDirection::PathableCells' has a wrong offset!");
static_assert(offsetof(GridLevelObject_AddPathableCellsInDirection, ReturnValue) == 0x000068, "Member 'GridLevelObject_AddPathableCellsInDirection::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.CanEnterCell
// 0x0014 (0x0014 - 0x0000)
struct GridLevelObject_CanEnterCell final
{
public:
	struct FIntPoint                              SourceCellLocation;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              TargetCellLocation;                                // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_CanEnterCell) == 0x000004, "Wrong alignment on GridLevelObject_CanEnterCell");
static_assert(sizeof(GridLevelObject_CanEnterCell) == 0x000014, "Wrong size on GridLevelObject_CanEnterCell");
static_assert(offsetof(GridLevelObject_CanEnterCell, SourceCellLocation) == 0x000000, "Member 'GridLevelObject_CanEnterCell::SourceCellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CanEnterCell, TargetCellLocation) == 0x000008, "Member 'GridLevelObject_CanEnterCell::TargetCellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CanEnterCell, ReturnValue) == 0x000010, "Member 'GridLevelObject_CanEnterCell::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.CanEnterCellWithState
// 0x001C (0x001C - 0x0000)
struct GridLevelObject_CanEnterCellWithState final
{
public:
	struct FIntPoint                              SourceCellLocation;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              TargetCellLocation;                                // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTraverseBreakableWalls;                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TerrainTraverseFlags;                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_CanEnterCellWithState) == 0x000004, "Wrong alignment on GridLevelObject_CanEnterCellWithState");
static_assert(sizeof(GridLevelObject_CanEnterCellWithState) == 0x00001C, "Wrong size on GridLevelObject_CanEnterCellWithState");
static_assert(offsetof(GridLevelObject_CanEnterCellWithState, SourceCellLocation) == 0x000000, "Member 'GridLevelObject_CanEnterCellWithState::SourceCellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CanEnterCellWithState, TargetCellLocation) == 0x000008, "Member 'GridLevelObject_CanEnterCellWithState::TargetCellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CanEnterCellWithState, bCanTraverseBreakableWalls) == 0x000010, "Member 'GridLevelObject_CanEnterCellWithState::bCanTraverseBreakableWalls' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CanEnterCellWithState, TerrainTraverseFlags) == 0x000014, "Member 'GridLevelObject_CanEnterCellWithState::TerrainTraverseFlags' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CanEnterCellWithState, ReturnValue) == 0x000018, "Member 'GridLevelObject_CanEnterCellWithState::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.CellTraceInDirection
// 0x0020 (0x0020 - 0x0000)
struct GridLevelObject_CellTraceInDirection final
{
public:
	struct FIntPoint                              SourceCellLocation;                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              CellDirection;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TerrainTraverseFlags;                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCellRange;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_CellTraceInDirection) == 0x000004, "Wrong alignment on GridLevelObject_CellTraceInDirection");
static_assert(sizeof(GridLevelObject_CellTraceInDirection) == 0x000020, "Wrong size on GridLevelObject_CellTraceInDirection");
static_assert(offsetof(GridLevelObject_CellTraceInDirection, SourceCellLocation) == 0x000000, "Member 'GridLevelObject_CellTraceInDirection::SourceCellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CellTraceInDirection, CellDirection) == 0x000008, "Member 'GridLevelObject_CellTraceInDirection::CellDirection' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CellTraceInDirection, TerrainTraverseFlags) == 0x000010, "Member 'GridLevelObject_CellTraceInDirection::TerrainTraverseFlags' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CellTraceInDirection, MaxCellRange) == 0x000014, "Member 'GridLevelObject_CellTraceInDirection::MaxCellRange' has a wrong offset!");
static_assert(offsetof(GridLevelObject_CellTraceInDirection, ReturnValue) == 0x000018, "Member 'GridLevelObject_CellTraceInDirection::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.FindShortestPath
// 0x0080 (0x0080 - 0x0000)
struct GridLevelObject_FindShortestPath final
{
public:
	struct FVector2D                              SourceLocation;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetLocation;                                    // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TerrainTraverseFlags;                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPathCost;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FIntPoint, float>                 AddedCostMap;                                      // 0x0018(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FIntPoint>                      OutPathLocations;                                  // 0x0068(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_FindShortestPath) == 0x000008, "Wrong alignment on GridLevelObject_FindShortestPath");
static_assert(sizeof(GridLevelObject_FindShortestPath) == 0x000080, "Wrong size on GridLevelObject_FindShortestPath");
static_assert(offsetof(GridLevelObject_FindShortestPath, SourceLocation) == 0x000000, "Member 'GridLevelObject_FindShortestPath::SourceLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_FindShortestPath, TargetLocation) == 0x000008, "Member 'GridLevelObject_FindShortestPath::TargetLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_FindShortestPath, TerrainTraverseFlags) == 0x000010, "Member 'GridLevelObject_FindShortestPath::TerrainTraverseFlags' has a wrong offset!");
static_assert(offsetof(GridLevelObject_FindShortestPath, MaxPathCost) == 0x000014, "Member 'GridLevelObject_FindShortestPath::MaxPathCost' has a wrong offset!");
static_assert(offsetof(GridLevelObject_FindShortestPath, AddedCostMap) == 0x000018, "Member 'GridLevelObject_FindShortestPath::AddedCostMap' has a wrong offset!");
static_assert(offsetof(GridLevelObject_FindShortestPath, OutPathLocations) == 0x000068, "Member 'GridLevelObject_FindShortestPath::OutPathLocations' has a wrong offset!");
static_assert(offsetof(GridLevelObject_FindShortestPath, ReturnValue) == 0x000078, "Member 'GridLevelObject_FindShortestPath::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.GetCellLocationFromLevelLocation
// 0x0010 (0x0010 - 0x0000)
struct GridLevelObject_GetCellLocationFromLevelLocation final
{
public:
	struct FVector2D                              Location;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_GetCellLocationFromLevelLocation) == 0x000004, "Wrong alignment on GridLevelObject_GetCellLocationFromLevelLocation");
static_assert(sizeof(GridLevelObject_GetCellLocationFromLevelLocation) == 0x000010, "Wrong size on GridLevelObject_GetCellLocationFromLevelLocation");
static_assert(offsetof(GridLevelObject_GetCellLocationFromLevelLocation, Location) == 0x000000, "Member 'GridLevelObject_GetCellLocationFromLevelLocation::Location' has a wrong offset!");
static_assert(offsetof(GridLevelObject_GetCellLocationFromLevelLocation, ReturnValue) == 0x000008, "Member 'GridLevelObject_GetCellLocationFromLevelLocation::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.GetLevelLocationFromCellLocation
// 0x0010 (0x0010 - 0x0000)
struct GridLevelObject_GetLevelLocationFromCellLocation final
{
public:
	struct FIntPoint                              CellLocation;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_GetLevelLocationFromCellLocation) == 0x000004, "Wrong alignment on GridLevelObject_GetLevelLocationFromCellLocation");
static_assert(sizeof(GridLevelObject_GetLevelLocationFromCellLocation) == 0x000010, "Wrong size on GridLevelObject_GetLevelLocationFromCellLocation");
static_assert(offsetof(GridLevelObject_GetLevelLocationFromCellLocation, CellLocation) == 0x000000, "Member 'GridLevelObject_GetLevelLocationFromCellLocation::CellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_GetLevelLocationFromCellLocation, ReturnValue) == 0x000008, "Member 'GridLevelObject_GetLevelLocationFromCellLocation::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.GetPathableCellSet
// 0x00A0 (0x00A0 - 0x0000)
struct GridLevelObject_GetPathableCellSet final
{
public:
	TSet<struct FIntPoint>                        ExcludeCells;                                      // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	TSet<struct FIntPoint>                        ReturnValue;                                       // 0x0050(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_GetPathableCellSet) == 0x000008, "Wrong alignment on GridLevelObject_GetPathableCellSet");
static_assert(sizeof(GridLevelObject_GetPathableCellSet) == 0x0000A0, "Wrong size on GridLevelObject_GetPathableCellSet");
static_assert(offsetof(GridLevelObject_GetPathableCellSet, ExcludeCells) == 0x000000, "Member 'GridLevelObject_GetPathableCellSet::ExcludeCells' has a wrong offset!");
static_assert(offsetof(GridLevelObject_GetPathableCellSet, ReturnValue) == 0x000050, "Member 'GridLevelObject_GetPathableCellSet::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.GetTerrainTypeAtCellLocation
// 0x000C (0x000C - 0x0000)
struct GridLevelObject_GetTerrainTypeAtCellLocation final
{
public:
	struct FIntPoint                              CellLocation;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_GetTerrainTypeAtCellLocation) == 0x000004, "Wrong alignment on GridLevelObject_GetTerrainTypeAtCellLocation");
static_assert(sizeof(GridLevelObject_GetTerrainTypeAtCellLocation) == 0x00000C, "Wrong size on GridLevelObject_GetTerrainTypeAtCellLocation");
static_assert(offsetof(GridLevelObject_GetTerrainTypeAtCellLocation, CellLocation) == 0x000000, "Member 'GridLevelObject_GetTerrainTypeAtCellLocation::CellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_GetTerrainTypeAtCellLocation, ReturnValue) == 0x000008, "Member 'GridLevelObject_GetTerrainTypeAtCellLocation::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.GetUnpathableCellSet
// 0x0050 (0x0050 - 0x0000)
struct GridLevelObject_GetUnpathableCellSet final
{
public:
	TSet<struct FIntPoint>                        ReturnValue;                                       // 0x0000(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(GridLevelObject_GetUnpathableCellSet) == 0x000008, "Wrong alignment on GridLevelObject_GetUnpathableCellSet");
static_assert(sizeof(GridLevelObject_GetUnpathableCellSet) == 0x000050, "Wrong size on GridLevelObject_GetUnpathableCellSet");
static_assert(offsetof(GridLevelObject_GetUnpathableCellSet, ReturnValue) == 0x000000, "Member 'GridLevelObject_GetUnpathableCellSet::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.IsCellLocationPathable
// 0x000C (0x000C - 0x0000)
struct GridLevelObject_IsCellLocationPathable final
{
public:
	struct FIntPoint                              CellLocation;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_IsCellLocationPathable) == 0x000004, "Wrong alignment on GridLevelObject_IsCellLocationPathable");
static_assert(sizeof(GridLevelObject_IsCellLocationPathable) == 0x00000C, "Wrong size on GridLevelObject_IsCellLocationPathable");
static_assert(offsetof(GridLevelObject_IsCellLocationPathable, CellLocation) == 0x000000, "Member 'GridLevelObject_IsCellLocationPathable::CellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_IsCellLocationPathable, ReturnValue) == 0x000008, "Member 'GridLevelObject_IsCellLocationPathable::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.IsCellLocationValid
// 0x000C (0x000C - 0x0000)
struct GridLevelObject_IsCellLocationValid final
{
public:
	struct FIntPoint                              CellLocation;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_IsCellLocationValid) == 0x000004, "Wrong alignment on GridLevelObject_IsCellLocationValid");
static_assert(sizeof(GridLevelObject_IsCellLocationValid) == 0x00000C, "Wrong size on GridLevelObject_IsCellLocationValid");
static_assert(offsetof(GridLevelObject_IsCellLocationValid, CellLocation) == 0x000000, "Member 'GridLevelObject_IsCellLocationValid::CellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_IsCellLocationValid, ReturnValue) == 0x000008, "Member 'GridLevelObject_IsCellLocationValid::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.IsTraversableTerrain
// 0x0010 (0x0010 - 0x0000)
struct GridLevelObject_IsTraversableTerrain final
{
public:
	struct FIntPoint                              CellLocation;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TerrainTraverseFlags;                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_IsTraversableTerrain) == 0x000004, "Wrong alignment on GridLevelObject_IsTraversableTerrain");
static_assert(sizeof(GridLevelObject_IsTraversableTerrain) == 0x000010, "Wrong size on GridLevelObject_IsTraversableTerrain");
static_assert(offsetof(GridLevelObject_IsTraversableTerrain, CellLocation) == 0x000000, "Member 'GridLevelObject_IsTraversableTerrain::CellLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_IsTraversableTerrain, TerrainTraverseFlags) == 0x000008, "Member 'GridLevelObject_IsTraversableTerrain::TerrainTraverseFlags' has a wrong offset!");
static_assert(offsetof(GridLevelObject_IsTraversableTerrain, ReturnValue) == 0x00000C, "Member 'GridLevelObject_IsTraversableTerrain::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.IsWallBlocked
// 0x0014 (0x0014 - 0x0000)
struct GridLevelObject_IsWallBlocked final
{
public:
	struct FIntRectangle                          CellPair;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_IsWallBlocked) == 0x000004, "Wrong alignment on GridLevelObject_IsWallBlocked");
static_assert(sizeof(GridLevelObject_IsWallBlocked) == 0x000014, "Wrong size on GridLevelObject_IsWallBlocked");
static_assert(offsetof(GridLevelObject_IsWallBlocked, CellPair) == 0x000000, "Member 'GridLevelObject_IsWallBlocked::CellPair' has a wrong offset!");
static_assert(offsetof(GridLevelObject_IsWallBlocked, ReturnValue) == 0x000010, "Member 'GridLevelObject_IsWallBlocked::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.IsWallBreakable
// 0x0014 (0x0014 - 0x0000)
struct GridLevelObject_IsWallBreakable final
{
public:
	struct FIntRectangle                          CellPair;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_IsWallBreakable) == 0x000004, "Wrong alignment on GridLevelObject_IsWallBreakable");
static_assert(sizeof(GridLevelObject_IsWallBreakable) == 0x000014, "Wrong size on GridLevelObject_IsWallBreakable");
static_assert(offsetof(GridLevelObject_IsWallBreakable, CellPair) == 0x000000, "Member 'GridLevelObject_IsWallBreakable::CellPair' has a wrong offset!");
static_assert(offsetof(GridLevelObject_IsWallBreakable, ReturnValue) == 0x000010, "Member 'GridLevelObject_IsWallBreakable::ReturnValue' has a wrong offset!");

// Function CoreGame.GridLevelObject.LineTraceGridWalls
// 0x0048 (0x0048 - 0x0000)
struct GridLevelObject_LineTraceGridWalls final
{
public:
	struct FVector2D                              SourceLocation;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TargetLocation;                                    // 0x0008(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRadius;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIntRectangle>                  IgnoreCellPairs;                                   // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FGridTraceHitResult                    OutHitResult;                                      // 0x0028(0x001C)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GridLevelObject_LineTraceGridWalls) == 0x000008, "Wrong alignment on GridLevelObject_LineTraceGridWalls");
static_assert(sizeof(GridLevelObject_LineTraceGridWalls) == 0x000048, "Wrong size on GridLevelObject_LineTraceGridWalls");
static_assert(offsetof(GridLevelObject_LineTraceGridWalls, SourceLocation) == 0x000000, "Member 'GridLevelObject_LineTraceGridWalls::SourceLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_LineTraceGridWalls, TargetLocation) == 0x000008, "Member 'GridLevelObject_LineTraceGridWalls::TargetLocation' has a wrong offset!");
static_assert(offsetof(GridLevelObject_LineTraceGridWalls, TraceRadius) == 0x000010, "Member 'GridLevelObject_LineTraceGridWalls::TraceRadius' has a wrong offset!");
static_assert(offsetof(GridLevelObject_LineTraceGridWalls, IgnoreCellPairs) == 0x000018, "Member 'GridLevelObject_LineTraceGridWalls::IgnoreCellPairs' has a wrong offset!");
static_assert(offsetof(GridLevelObject_LineTraceGridWalls, OutHitResult) == 0x000028, "Member 'GridLevelObject_LineTraceGridWalls::OutHitResult' has a wrong offset!");
static_assert(offsetof(GridLevelObject_LineTraceGridWalls, ReturnValue) == 0x000044, "Member 'GridLevelObject_LineTraceGridWalls::ReturnValue' has a wrong offset!");

// Function CoreGame.Shuffler.GetNextIndex
// 0x0004 (0x0004 - 0x0000)
struct Shuffler_GetNextIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Shuffler_GetNextIndex) == 0x000004, "Wrong alignment on Shuffler_GetNextIndex");
static_assert(sizeof(Shuffler_GetNextIndex) == 0x000004, "Wrong size on Shuffler_GetNextIndex");
static_assert(offsetof(Shuffler_GetNextIndex, ReturnValue) == 0x000000, "Member 'Shuffler_GetNextIndex::ReturnValue' has a wrong offset!");

// Function CoreGame.Shuffler.SetCount
// 0x0004 (0x0004 - 0x0000)
struct Shuffler_SetCount final
{
public:
	int32                                         CountToSet;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Shuffler_SetCount) == 0x000004, "Wrong alignment on Shuffler_SetCount");
static_assert(sizeof(Shuffler_SetCount) == 0x000004, "Wrong size on Shuffler_SetCount");
static_assert(offsetof(Shuffler_SetCount, CountToSet) == 0x000000, "Member 'Shuffler_SetCount::CountToSet' has a wrong offset!");

// Function CoreGame.SymmetricRandomWalk.GetCurrentValue
// 0x0008 (0x0008 - 0x0000)
struct SymmetricRandomWalk_GetCurrentValue final
{
public:
	int32                                         SampleIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SymmetricRandomWalk_GetCurrentValue) == 0x000004, "Wrong alignment on SymmetricRandomWalk_GetCurrentValue");
static_assert(sizeof(SymmetricRandomWalk_GetCurrentValue) == 0x000008, "Wrong size on SymmetricRandomWalk_GetCurrentValue");
static_assert(offsetof(SymmetricRandomWalk_GetCurrentValue, SampleIndex) == 0x000000, "Member 'SymmetricRandomWalk_GetCurrentValue::SampleIndex' has a wrong offset!");
static_assert(offsetof(SymmetricRandomWalk_GetCurrentValue, ReturnValue) == 0x000004, "Member 'SymmetricRandomWalk_GetCurrentValue::ReturnValue' has a wrong offset!");

// Function CoreGame.SymmetricRandomWalk.GetCurrentValues
// 0x0010 (0x0010 - 0x0000)
struct SymmetricRandomWalk_GetCurrentValues final
{
public:
	TArray<float>                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SymmetricRandomWalk_GetCurrentValues) == 0x000008, "Wrong alignment on SymmetricRandomWalk_GetCurrentValues");
static_assert(sizeof(SymmetricRandomWalk_GetCurrentValues) == 0x000010, "Wrong size on SymmetricRandomWalk_GetCurrentValues");
static_assert(offsetof(SymmetricRandomWalk_GetCurrentValues, ReturnValue) == 0x000000, "Member 'SymmetricRandomWalk_GetCurrentValues::ReturnValue' has a wrong offset!");

// Function CoreGame.SymmetricRandomWalk.SetWalkParameters
// 0x0028 (0x0028 - 0x0000)
struct SymmetricRandomWalk_SetWalkParameters final
{
public:
	TArray<float>                                 InitValues;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinStep;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStep;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVal;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVal;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLerp;                                             // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SymmetricRandomWalk_SetWalkParameters) == 0x000008, "Wrong alignment on SymmetricRandomWalk_SetWalkParameters");
static_assert(sizeof(SymmetricRandomWalk_SetWalkParameters) == 0x000028, "Wrong size on SymmetricRandomWalk_SetWalkParameters");
static_assert(offsetof(SymmetricRandomWalk_SetWalkParameters, InitValues) == 0x000000, "Member 'SymmetricRandomWalk_SetWalkParameters::InitValues' has a wrong offset!");
static_assert(offsetof(SymmetricRandomWalk_SetWalkParameters, Interval) == 0x000010, "Member 'SymmetricRandomWalk_SetWalkParameters::Interval' has a wrong offset!");
static_assert(offsetof(SymmetricRandomWalk_SetWalkParameters, MinStep) == 0x000014, "Member 'SymmetricRandomWalk_SetWalkParameters::MinStep' has a wrong offset!");
static_assert(offsetof(SymmetricRandomWalk_SetWalkParameters, MaxStep) == 0x000018, "Member 'SymmetricRandomWalk_SetWalkParameters::MaxStep' has a wrong offset!");
static_assert(offsetof(SymmetricRandomWalk_SetWalkParameters, MinVal) == 0x00001C, "Member 'SymmetricRandomWalk_SetWalkParameters::MinVal' has a wrong offset!");
static_assert(offsetof(SymmetricRandomWalk_SetWalkParameters, MaxVal) == 0x000020, "Member 'SymmetricRandomWalk_SetWalkParameters::MaxVal' has a wrong offset!");
static_assert(offsetof(SymmetricRandomWalk_SetWalkParameters, bLerp) == 0x000024, "Member 'SymmetricRandomWalk_SetWalkParameters::bLerp' has a wrong offset!");

// Function CoreGame.WeightedAverageBase.SetSmoothingFactor
// 0x0004 (0x0004 - 0x0000)
struct WeightedAverageBase_SetSmoothingFactor final
{
public:
	float                                         Smoothing_0;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageBase_SetSmoothingFactor) == 0x000004, "Wrong alignment on WeightedAverageBase_SetSmoothingFactor");
static_assert(sizeof(WeightedAverageBase_SetSmoothingFactor) == 0x000004, "Wrong size on WeightedAverageBase_SetSmoothingFactor");
static_assert(offsetof(WeightedAverageBase_SetSmoothingFactor, Smoothing_0) == 0x000000, "Member 'WeightedAverageBase_SetSmoothingFactor::Smoothing_0' has a wrong offset!");

// Function CoreGame.WeightedAverageFloat.GetSmoothedFloat
// 0x0010 (0x0010 - 0x0000)
struct WeightedAverageFloat_GetSmoothedFloat final
{
public:
	float                                         Sample;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageFloat_GetSmoothedFloat) == 0x000004, "Wrong alignment on WeightedAverageFloat_GetSmoothedFloat");
static_assert(sizeof(WeightedAverageFloat_GetSmoothedFloat) == 0x000010, "Wrong size on WeightedAverageFloat_GetSmoothedFloat");
static_assert(offsetof(WeightedAverageFloat_GetSmoothedFloat, Sample) == 0x000000, "Member 'WeightedAverageFloat_GetSmoothedFloat::Sample' has a wrong offset!");
static_assert(offsetof(WeightedAverageFloat_GetSmoothedFloat, CurrentTime) == 0x000004, "Member 'WeightedAverageFloat_GetSmoothedFloat::CurrentTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageFloat_GetSmoothedFloat, DeltaTime) == 0x000008, "Member 'WeightedAverageFloat_GetSmoothedFloat::DeltaTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageFloat_GetSmoothedFloat, ReturnValue) == 0x00000C, "Member 'WeightedAverageFloat_GetSmoothedFloat::ReturnValue' has a wrong offset!");

// Function CoreGame.WeightedAverageFloat.GetElapsedTimeSinceLastSample
// 0x0008 (0x0008 - 0x0000)
struct WeightedAverageFloat_GetElapsedTimeSinceLastSample final
{
public:
	float                                         CurrentTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageFloat_GetElapsedTimeSinceLastSample) == 0x000004, "Wrong alignment on WeightedAverageFloat_GetElapsedTimeSinceLastSample");
static_assert(sizeof(WeightedAverageFloat_GetElapsedTimeSinceLastSample) == 0x000008, "Wrong size on WeightedAverageFloat_GetElapsedTimeSinceLastSample");
static_assert(offsetof(WeightedAverageFloat_GetElapsedTimeSinceLastSample, CurrentTime) == 0x000000, "Member 'WeightedAverageFloat_GetElapsedTimeSinceLastSample::CurrentTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageFloat_GetElapsedTimeSinceLastSample, ReturnValue) == 0x000004, "Member 'WeightedAverageFloat_GetElapsedTimeSinceLastSample::ReturnValue' has a wrong offset!");

// Function CoreGame.WeightedAverageFloat.GetTotalElapsedSampleTime
// 0x0004 (0x0004 - 0x0000)
struct WeightedAverageFloat_GetTotalElapsedSampleTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageFloat_GetTotalElapsedSampleTime) == 0x000004, "Wrong alignment on WeightedAverageFloat_GetTotalElapsedSampleTime");
static_assert(sizeof(WeightedAverageFloat_GetTotalElapsedSampleTime) == 0x000004, "Wrong size on WeightedAverageFloat_GetTotalElapsedSampleTime");
static_assert(offsetof(WeightedAverageFloat_GetTotalElapsedSampleTime, ReturnValue) == 0x000000, "Member 'WeightedAverageFloat_GetTotalElapsedSampleTime::ReturnValue' has a wrong offset!");

// Function CoreGame.WeightedAverageVec2.GetSmoothedVec2
// 0x0018 (0x0018 - 0x0000)
struct WeightedAverageVec2_GetSmoothedVec2 final
{
public:
	struct FVector2D                              Sample;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageVec2_GetSmoothedVec2) == 0x000004, "Wrong alignment on WeightedAverageVec2_GetSmoothedVec2");
static_assert(sizeof(WeightedAverageVec2_GetSmoothedVec2) == 0x000018, "Wrong size on WeightedAverageVec2_GetSmoothedVec2");
static_assert(offsetof(WeightedAverageVec2_GetSmoothedVec2, Sample) == 0x000000, "Member 'WeightedAverageVec2_GetSmoothedVec2::Sample' has a wrong offset!");
static_assert(offsetof(WeightedAverageVec2_GetSmoothedVec2, CurrentTime) == 0x000008, "Member 'WeightedAverageVec2_GetSmoothedVec2::CurrentTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageVec2_GetSmoothedVec2, DeltaTime) == 0x00000C, "Member 'WeightedAverageVec2_GetSmoothedVec2::DeltaTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageVec2_GetSmoothedVec2, ReturnValue) == 0x000010, "Member 'WeightedAverageVec2_GetSmoothedVec2::ReturnValue' has a wrong offset!");

// Function CoreGame.WeightedAverageVec2.GetElapsedTimeSinceLastSample
// 0x0008 (0x0008 - 0x0000)
struct WeightedAverageVec2_GetElapsedTimeSinceLastSample final
{
public:
	float                                         CurrentTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageVec2_GetElapsedTimeSinceLastSample) == 0x000004, "Wrong alignment on WeightedAverageVec2_GetElapsedTimeSinceLastSample");
static_assert(sizeof(WeightedAverageVec2_GetElapsedTimeSinceLastSample) == 0x000008, "Wrong size on WeightedAverageVec2_GetElapsedTimeSinceLastSample");
static_assert(offsetof(WeightedAverageVec2_GetElapsedTimeSinceLastSample, CurrentTime) == 0x000000, "Member 'WeightedAverageVec2_GetElapsedTimeSinceLastSample::CurrentTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageVec2_GetElapsedTimeSinceLastSample, ReturnValue) == 0x000004, "Member 'WeightedAverageVec2_GetElapsedTimeSinceLastSample::ReturnValue' has a wrong offset!");

// Function CoreGame.WeightedAverageVec2.GetTotalElapsedSampleTime
// 0x0004 (0x0004 - 0x0000)
struct WeightedAverageVec2_GetTotalElapsedSampleTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageVec2_GetTotalElapsedSampleTime) == 0x000004, "Wrong alignment on WeightedAverageVec2_GetTotalElapsedSampleTime");
static_assert(sizeof(WeightedAverageVec2_GetTotalElapsedSampleTime) == 0x000004, "Wrong size on WeightedAverageVec2_GetTotalElapsedSampleTime");
static_assert(offsetof(WeightedAverageVec2_GetTotalElapsedSampleTime, ReturnValue) == 0x000000, "Member 'WeightedAverageVec2_GetTotalElapsedSampleTime::ReturnValue' has a wrong offset!");

// Function CoreGame.WeightedAverageVec3.GetSmoothedVec3
// 0x0020 (0x0020 - 0x0000)
struct WeightedAverageVec3_GetSmoothedVec3 final
{
public:
	struct FVector                                Sample;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTime;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageVec3_GetSmoothedVec3) == 0x000004, "Wrong alignment on WeightedAverageVec3_GetSmoothedVec3");
static_assert(sizeof(WeightedAverageVec3_GetSmoothedVec3) == 0x000020, "Wrong size on WeightedAverageVec3_GetSmoothedVec3");
static_assert(offsetof(WeightedAverageVec3_GetSmoothedVec3, Sample) == 0x000000, "Member 'WeightedAverageVec3_GetSmoothedVec3::Sample' has a wrong offset!");
static_assert(offsetof(WeightedAverageVec3_GetSmoothedVec3, CurrentTime) == 0x00000C, "Member 'WeightedAverageVec3_GetSmoothedVec3::CurrentTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageVec3_GetSmoothedVec3, DeltaTime) == 0x000010, "Member 'WeightedAverageVec3_GetSmoothedVec3::DeltaTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageVec3_GetSmoothedVec3, ReturnValue) == 0x000014, "Member 'WeightedAverageVec3_GetSmoothedVec3::ReturnValue' has a wrong offset!");

// Function CoreGame.WeightedAverageVec3.GetElapsedTimeSinceLastSample
// 0x0008 (0x0008 - 0x0000)
struct WeightedAverageVec3_GetElapsedTimeSinceLastSample final
{
public:
	float                                         CurrentTime;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageVec3_GetElapsedTimeSinceLastSample) == 0x000004, "Wrong alignment on WeightedAverageVec3_GetElapsedTimeSinceLastSample");
static_assert(sizeof(WeightedAverageVec3_GetElapsedTimeSinceLastSample) == 0x000008, "Wrong size on WeightedAverageVec3_GetElapsedTimeSinceLastSample");
static_assert(offsetof(WeightedAverageVec3_GetElapsedTimeSinceLastSample, CurrentTime) == 0x000000, "Member 'WeightedAverageVec3_GetElapsedTimeSinceLastSample::CurrentTime' has a wrong offset!");
static_assert(offsetof(WeightedAverageVec3_GetElapsedTimeSinceLastSample, ReturnValue) == 0x000004, "Member 'WeightedAverageVec3_GetElapsedTimeSinceLastSample::ReturnValue' has a wrong offset!");

// Function CoreGame.WeightedAverageVec3.GetTotalElapsedSampleTime
// 0x0004 (0x0004 - 0x0000)
struct WeightedAverageVec3_GetTotalElapsedSampleTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WeightedAverageVec3_GetTotalElapsedSampleTime) == 0x000004, "Wrong alignment on WeightedAverageVec3_GetTotalElapsedSampleTime");
static_assert(sizeof(WeightedAverageVec3_GetTotalElapsedSampleTime) == 0x000004, "Wrong size on WeightedAverageVec3_GetTotalElapsedSampleTime");
static_assert(offsetof(WeightedAverageVec3_GetTotalElapsedSampleTime, ReturnValue) == 0x000000, "Member 'WeightedAverageVec3_GetTotalElapsedSampleTime::ReturnValue' has a wrong offset!");

}

