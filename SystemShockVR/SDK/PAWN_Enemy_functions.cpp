#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PAWN_Enemy

#include "Basic.hpp"

#include "PAWN_Enemy_classes.hpp"
#include "PAWN_Enemy_parameters.hpp"


namespace SDK
{

// Function PAWN_Enemy.PAWN_Enemy_C.OnEnemyBehaviorStateChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::OnEnemyBehaviorStateChanged__DelegateSignature(class APAWN_Enemy_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnEnemyBehaviorStateChanged__DelegateSignature");

	Params::PAWN_Enemy_C_OnEnemyBehaviorStateChanged__DelegateSignature Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.ExecuteUbergraph_PAWN_Enemy
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::ExecuteUbergraph_PAWN_Enemy(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ExecuteUbergraph_PAWN_Enemy");

	Params::PAWN_Enemy_C_ExecuteUbergraph_PAWN_Enemy Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.BndEvt__PAWN_Enemy_COMP_DismembermentManager_K2Node_ComponentBoundEvent_6_OnDynaDamage__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class FName                             DynaElementName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnBeginPlay                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::BndEvt__PAWN_Enemy_COMP_DismembermentManager_K2Node_ComponentBoundEvent_6_OnDynaDamage__DelegateSignature(class FName DynaElementName, bool OnBeginPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "BndEvt__PAWN_Enemy_COMP_DismembermentManager_K2Node_ComponentBoundEvent_6_OnDynaDamage__DelegateSignature");

	Params::PAWN_Enemy_C_BndEvt__PAWN_Enemy_COMP_DismembermentManager_K2Node_ComponentBoundEvent_6_OnDynaDamage__DelegateSignature Parms{};

	Parms.DynaElementName = DynaElementName;
	Parms.OnBeginPlay = OnBeginPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.BndEvt__PAWN_Enemy_COMP_DismembermentManager_K2Node_ComponentBoundEvent_1_OnLimbDismembered__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class FName                             LimbName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_DismemberableLimb        LimbData                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// class ADismembermentLimb_Base_C*        LimbActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnBeginPlay                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::BndEvt__PAWN_Enemy_COMP_DismembermentManager_K2Node_ComponentBoundEvent_1_OnLimbDismembered__DelegateSignature(class FName LimbName, const struct FSTRUCT_DismemberableLimb& LimbData, class ADismembermentLimb_Base_C* LimbActor, bool OnBeginPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "BndEvt__PAWN_Enemy_COMP_DismembermentManager_K2Node_ComponentBoundEvent_1_OnLimbDismembered__DelegateSignature");

	Params::PAWN_Enemy_C_BndEvt__PAWN_Enemy_COMP_DismembermentManager_K2Node_ComponentBoundEvent_1_OnLimbDismembered__DelegateSignature Parms{};

	Parms.LimbName = LimbName;
	Parms.LimbData = std::move(LimbData);
	Parms.LimbActor = LimbActor;
	Parms.OnBeginPlay = OnBeginPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.BndEvt__PAWN_Enemy_COMP_ScannableObject_K2Node_ComponentBoundEvent_5_VoxelScannableVisibilitySignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// bool                                    bVisibleState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::BndEvt__PAWN_Enemy_COMP_ScannableObject_K2Node_ComponentBoundEvent_5_VoxelScannableVisibilitySignature__DelegateSignature(bool bVisibleState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "BndEvt__PAWN_Enemy_COMP_ScannableObject_K2Node_ComponentBoundEvent_5_VoxelScannableVisibilitySignature__DelegateSignature");

	Params::PAWN_Enemy_C_BndEvt__PAWN_Enemy_COMP_ScannableObject_K2Node_ComponentBoundEvent_5_VoxelScannableVisibilitySignature__DelegateSignature Parms{};

	Parms.bVisibleState = bVisibleState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.BndEvt__PAWN_Enemy_COMP_VoxelCullableNavAgent_K2Node_ComponentBoundEvent_4_CullableAudibilitySignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// bool                                    bAudibleState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::BndEvt__PAWN_Enemy_COMP_VoxelCullableNavAgent_K2Node_ComponentBoundEvent_4_CullableAudibilitySignature__DelegateSignature(bool bAudibleState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "BndEvt__PAWN_Enemy_COMP_VoxelCullableNavAgent_K2Node_ComponentBoundEvent_4_CullableAudibilitySignature__DelegateSignature");

	Params::PAWN_Enemy_C_BndEvt__PAWN_Enemy_COMP_VoxelCullableNavAgent_K2Node_ComponentBoundEvent_4_CullableAudibilitySignature__DelegateSignature Parms{};

	Parms.bAudibleState = bAudibleState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ReceiveEndPlay");

	Params::PAWN_Enemy_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.BndEvt__COMP_VoxelNavAgent_K2Node_ComponentBoundEvent_3_CullableVisibilitySignature__DelegateSignature
// (BlueprintEvent)
// Parameters:
// bool                                    bVisibleState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::BndEvt__COMP_VoxelNavAgent_K2Node_ComponentBoundEvent_3_CullableVisibilitySignature__DelegateSignature(bool bVisibleState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "BndEvt__COMP_VoxelNavAgent_K2Node_ComponentBoundEvent_3_CullableVisibilitySignature__DelegateSignature");

	Params::PAWN_Enemy_C_BndEvt__COMP_VoxelNavAgent_K2Node_ComponentBoundEvent_3_CullableVisibilitySignature__DelegateSignature Parms{};

	Parms.bVisibleState = bVisibleState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.ReceivePossessed
// (Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      NewController                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::ReceivePossessed(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ReceivePossessed");

	Params::PAWN_Enemy_C_ReceivePossessed Parms{};

	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.BndEvt__COMP_EnemySensingComponent_K2Node_ComponentBoundEvent_0_OnHearPawn__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Loudness                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::BndEvt__COMP_EnemySensingComponent_K2Node_ComponentBoundEvent_0_OnHearPawn__DelegateSignature(class APAWN_SystemShockCharacter_C* Pawn, const struct FVector& Location, float Loudness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "BndEvt__COMP_EnemySensingComponent_K2Node_ComponentBoundEvent_0_OnHearPawn__DelegateSignature");

	Params::PAWN_Enemy_C_BndEvt__COMP_EnemySensingComponent_K2Node_ComponentBoundEvent_0_OnHearPawn__DelegateSignature Parms{};

	Parms.Pawn = Pawn;
	Parms.Location = std::move(Location);
	Parms.Loudness = Loudness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.BndEvt__COMP_EnemySensingComponent_K2Node_ComponentBoundEvent_2_OnSeePawn__DelegateSignature
// (BlueprintEvent)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::BndEvt__COMP_EnemySensingComponent_K2Node_ComponentBoundEvent_2_OnSeePawn__DelegateSignature(class APAWN_SystemShockCharacter_C* Pawn, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "BndEvt__COMP_EnemySensingComponent_K2Node_ComponentBoundEvent_2_OnSeePawn__DelegateSignature");

	Params::PAWN_Enemy_C_BndEvt__COMP_EnemySensingComponent_K2Node_ComponentBoundEvent_2_OnSeePawn__DelegateSignature Parms{};

	Parms.Pawn = Pawn;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnCursorLeave
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Cursor_Primitive                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::OnCursorLeave(class UPrimitiveComponent* Cursor_Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnCursorLeave");

	Params::PAWN_Enemy_C_OnCursorLeave Parms{};

	Parms.Cursor_Primitive = Cursor_Primitive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnCursorEnter
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Cursor_Primitive                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::OnCursorEnter(class UPrimitiveComponent* Cursor_Primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnCursorEnter");

	Params::PAWN_Enemy_C_OnCursorEnter Parms{};

	Parms.Cursor_Primitive = Cursor_Primitive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_TargetAssignmentType               AssignType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UOBJ_EnemyTarget_C*               Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetTarget(ENUM_TargetAssignmentType AssignType, class UOBJ_EnemyTarget_C* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetTarget");

	Params::PAWN_Enemy_C_SetTarget Parms{};

	Parms.AssignType = AssignType;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// ENUM_TargetAssignmentType               Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UOBJ_EnemyTarget_C*               Target                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetTarget(ENUM_TargetAssignmentType Type, class UOBJ_EnemyTarget_C** Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetTarget");

	Params::PAWN_Enemy_C_GetTarget Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (Target != nullptr)
		*Target = Parms.Target;
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnCharacterDied
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UOBJ_ImpactData_C*                ImpactData                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FAttribDamageInstance            DamageInstance                                         (BlueprintVisible, BlueprintReadOnly, Parm)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnCharacterDied(class UOBJ_ImpactData_C* ImpactData, const struct FAttribDamageInstance& DamageInstance, class AActor* OtherActor, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnCharacterDied");

	Params::PAWN_Enemy_C_OnCharacterDied Parms{};

	Parms.ImpactData = ImpactData;
	Parms.DamageInstance = std::move(DamageInstance);
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.ReceiveAnimationMessage
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// EActorMessagePriority                   Priority                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Message                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool APAWN_Enemy_C::ReceiveAnimationMessage(const EActorMessagePriority& Priority, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ReceiveAnimationMessage");

	Params::PAWN_Enemy_C_ReceiveAnimationMessage Parms{};

	Parms.Priority = Priority;
	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryAssignInitialBehavior
// (Protected, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::TryAssignInitialBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryAssignInitialBehavior");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryRestoreLocalBehavior
// (Protected, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::TryRestoreLocalBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryRestoreLocalBehavior");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TrySetEnemyName
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TrySetEnemyName(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TrySetEnemyName");

	Params::PAWN_Enemy_C_TrySetEnemyName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.TrySetSpawnData
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TrySetSpawnData(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TrySetSpawnData");

	Params::PAWN_Enemy_C_TrySetSpawnData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryGenerateLoot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryGenerateLoot(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryGenerateLoot");

	Params::PAWN_Enemy_C_TryGenerateLoot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.ShouldCloseLootWindow
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           NewChannelingInteract                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::ShouldCloseLootWindow(class AActor* NewChannelingInteract, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ShouldCloseLootWindow");

	Params::PAWN_Enemy_C_ShouldCloseLootWindow Parms{};

	Parms.NewChannelingInteract = NewChannelingInteract;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetExploitDamagePercentage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           SourceActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ImpactLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          AttackDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AttackRadius                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AllowSneakAttack                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   ExploitDamagePercent                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetExploitDamagePercentage(class AActor* SourceActor, class FName BoneName, const struct FVector& ImpactLocation, const struct FVector& AttackDirection, float AttackRadius, bool AllowSneakAttack, float* ExploitDamagePercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetExploitDamagePercentage");

	Params::PAWN_Enemy_C_GetExploitDamagePercentage Parms{};

	Parms.SourceActor = SourceActor;
	Parms.BoneName = BoneName;
	Parms.ImpactLocation = std::move(ImpactLocation);
	Parms.AttackDirection = std::move(AttackDirection);
	Parms.AttackRadius = AttackRadius;
	Parms.AllowSneakAttack = AllowSneakAttack;

	UObject::ProcessEvent(Func, &Parms);

	if (ExploitDamagePercent != nullptr)
		*ExploitDamagePercent = Parms.ExploitDamagePercent;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetArmorAugmentationPercentage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ImpactLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ArmorAugmentPercent                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetArmorAugmentationPercentage(class FName BoneName, const struct FVector& ImpactLocation, float* ArmorAugmentPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetArmorAugmentationPercentage");

	Params::PAWN_Enemy_C_GetArmorAugmentationPercentage Parms{};

	Parms.BoneName = BoneName;
	Parms.ImpactLocation = std::move(ImpactLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (ArmorAugmentPercent != nullptr)
		*ArmorAugmentPercent = Parms.ArmorAugmentPercent;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GrantDefaultCharacterLoadout
// (Public, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::GrantDefaultCharacterLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GrantDefaultCharacterLoadout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetLowFiVisibilityState
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewLowFiState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetLowFiVisibilityState(bool NewLowFiState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetLowFiVisibilityState");

	Params::PAWN_Enemy_C_SetLowFiVisibilityState Parms{};

	Parms.NewLowFiState = NewLowFiState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetLowFiBehaviorState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewLowFiState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetLowFiBehaviorState(bool NewLowFiState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetLowFiBehaviorState");

	Params::PAWN_Enemy_C_SetLowFiBehaviorState Parms{};

	Parms.NewLowFiState = NewLowFiState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.AttemptToEnterLowFiBehavior
// (Private, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::AttemptToEnterLowFiBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "AttemptToEnterLowFiBehavior");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.ForceRetryLowFiBehaviorAfterDuration
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::ForceRetryLowFiBehaviorAfterDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ForceRetryLowFiBehaviorAfterDuration");

	Params::PAWN_Enemy_C_ForceRetryLowFiBehaviorAfterDuration Parms{};

	Parms.Duration = Duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetBehaviorEnabled
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetBehaviorEnabled(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetBehaviorEnabled");

	Params::PAWN_Enemy_C_SetBehaviorEnabled Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsBehaviorDisabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsBehaviorDisabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsBehaviorDisabled");

	Params::PAWN_Enemy_C_IsBehaviorDisabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.HasImportantBehavior
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::HasImportantBehavior(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "HasImportantBehavior");

	Params::PAWN_Enemy_C_HasImportantBehavior Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsAnyBehaviorEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsAnyBehaviorEnabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsAnyBehaviorEnabled");

	Params::PAWN_Enemy_C_IsAnyBehaviorEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.InitializeDynamicBehaviors
// (Public, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::InitializeDynamicBehaviors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "InitializeDynamicBehaviors");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetDynamicCombatBehavior
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBehaviorTree*                    DynamicBehavior                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetDynamicCombatBehavior(class UBehaviorTree* DynamicBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetDynamicCombatBehavior");

	Params::PAWN_Enemy_C_SetDynamicCombatBehavior Parms{};

	Parms.DynamicBehavior = DynamicBehavior;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetDynamicIdleBehavior
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBehaviorTree*                    DynamicBehavior                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetDynamicIdleBehavior(class UBehaviorTree* DynamicBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetDynamicIdleBehavior");

	Params::PAWN_Enemy_C_SetDynamicIdleBehavior Parms{};

	Parms.DynamicBehavior = DynamicBehavior;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnLowFiBehaviorStateChanged
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewLowFiState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnLowFiBehaviorStateChanged(bool NewLowFiState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnLowFiBehaviorStateChanged");

	Params::PAWN_Enemy_C_OnLowFiBehaviorStateChanged Parms{};

	Parms.NewLowFiState = NewLowFiState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetDisableBehaviorCullingWhilePatrolling
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetDisableBehaviorCullingWhilePatrolling(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetDisableBehaviorCullingWhilePatrolling");

	Params::PAWN_Enemy_C_SetDisableBehaviorCullingWhilePatrolling Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.ShouldDisableBehaviorCullingWhilePatrolling
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::ShouldDisableBehaviorCullingWhilePatrolling(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ShouldDisableBehaviorCullingWhilePatrolling");

	Params::PAWN_Enemy_C_ShouldDisableBehaviorCullingWhilePatrolling Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.AddElapsedLowFiBehaviorTime
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ElapsedTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::AddElapsedLowFiBehaviorTime(float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "AddElapsedLowFiBehaviorTime");

	Params::PAWN_Enemy_C_AddElapsedLowFiBehaviorTime Parms{};

	Parms.ElapsedTime = ElapsedTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.UpdateLastLowFiBehaviorTimestamp
// (Public, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::UpdateLastLowFiBehaviorTimestamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "UpdateLastLowFiBehaviorTimestamp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetElapsedTimeSinceLastLowFiBehavior
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetElapsedTimeSinceLastLowFiBehavior(float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetElapsedTimeSinceLastLowFiBehavior");

	Params::PAWN_Enemy_C_GetElapsedTimeSinceLastLowFiBehavior Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsLowFiBehaviorEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsLowFiBehaviorEnabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsLowFiBehaviorEnabled");

	Params::PAWN_Enemy_C_IsLowFiBehaviorEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsLowFiVisibilityEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsLowFiVisibilityEnabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsLowFiVisibilityEnabled");

	Params::PAWN_Enemy_C_IsLowFiVisibilityEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsLowFiAudibilityEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsLowFiAudibilityEnabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsLowFiAudibilityEnabled");

	Params::PAWN_Enemy_C_IsLowFiAudibilityEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsLowFiBehaviorAndVisibilityEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsLowFiBehaviorAndVisibilityEnabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsLowFiBehaviorAndVisibilityEnabled");

	Params::PAWN_Enemy_C_IsLowFiBehaviorAndVisibilityEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.CanSetLowFiBehaviorEnabled
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::CanSetLowFiBehaviorEnabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "CanSetLowFiBehaviorEnabled");

	Params::PAWN_Enemy_C_CanSetLowFiBehaviorEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsNearSpawnLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    CheckRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsNearSpawnLocation(bool CheckRotation, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsNearSpawnLocation");

	Params::PAWN_Enemy_C_IsNearSpawnLocation Parms{};

	Parms.CheckRotation = CheckRotation;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsEnemyAware
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsEnemyAware(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsEnemyAware");

	Params::PAWN_Enemy_C_IsEnemyAware Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsEnemyMobile
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsEnemyMobile(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsEnemyMobile");

	Params::PAWN_Enemy_C_IsEnemyMobile Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetIsAware
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetIsAware(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetIsAware");

	Params::PAWN_Enemy_C_SetIsAware Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetIsMobile
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetIsMobile(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetIsMobile");

	Params::PAWN_Enemy_C_SetIsMobile Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.ValidateDefaultAwareness
// (Private, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::ValidateDefaultAwareness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ValidateDefaultAwareness");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnEnemyAwarenessChanged
// (Protected, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::OnEnemyAwarenessChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnEnemyAwarenessChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnEnemyMobilityChanged
// (Private, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::OnEnemyMobilityChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnEnemyMobilityChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.InitializeCharacterAsDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::InitializeCharacterAsDead(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "InitializeCharacterAsDead");

	Params::PAWN_Enemy_C_InitializeCharacterAsDead Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnCharacterHurt
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FAttribDamageInstance            DamageInstance                                         (BlueprintVisible, BlueprintReadOnly, Parm)
// class UOBJ_ImpactData_C*                ImpactData                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnCharacterHurt(class AActor* OtherActor, const struct FAttribDamageInstance& DamageInstance, class UOBJ_ImpactData_C* ImpactData, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnCharacterHurt");

	Params::PAWN_Enemy_C_OnCharacterHurt Parms{};

	Parms.OtherActor = OtherActor;
	Parms.DamageInstance = std::move(DamageInstance);
	Parms.ImpactData = ImpactData;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetCharacterPropertiesToDead
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetCharacterPropertiesToDead(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetCharacterPropertiesToDead");

	Params::PAWN_Enemy_C_SetCharacterPropertiesToDead Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetMeshPropertiesToDead
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    LowFiUpdated                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetMeshPropertiesToDead(bool LowFiUpdated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetMeshPropertiesToDead");

	Params::PAWN_Enemy_C_SetMeshPropertiesToDead Parms{};

	Parms.LowFiUpdated = LowFiUpdated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetDeadDisplayName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             Result                                                 (Parm, OutParm)

void APAWN_Enemy_C::GetDeadDisplayName(class FText* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetDeadDisplayName");

	Params::PAWN_Enemy_C_GetDeadDisplayName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetDeadDescriptionText
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             Text                                                   (Parm, OutParm)

void APAWN_Enemy_C::GetDeadDescriptionText(class FText* Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetDeadDescriptionText");

	Params::PAWN_Enemy_C_GetDeadDescriptionText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Text != nullptr)
		*Text = std::move(Parms.Text);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetDeathBlow
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UOBJ_ImpactData_C*                ImpactData                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FAttribDamageInstance            Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FSTRUCT_DeathBlowData            DeathBlow                                              (Parm, OutParm, HasGetValueTypeHash)

void APAWN_Enemy_C::GetDeathBlow(class UOBJ_ImpactData_C* ImpactData, const struct FAttribDamageInstance& Damage, struct FSTRUCT_DeathBlowData* DeathBlow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetDeathBlow");

	Params::PAWN_Enemy_C_GetDeathBlow Parms{};

	Parms.ImpactData = ImpactData;
	Parms.Damage = std::move(Damage);

	UObject::ProcessEvent(Func, &Parms);

	if (DeathBlow != nullptr)
		*DeathBlow = std::move(Parms.DeathBlow);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetPawnEmotion
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// ENUM_Emotions                           Emotion                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetPawnEmotion(ENUM_Emotions* Emotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetPawnEmotion");

	Params::PAWN_Enemy_C_GetPawnEmotion Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Emotion != nullptr)
		*Emotion = Parms.Emotion;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetPawnEmotion
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_Emotions                           NewEmotion                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetPawnEmotion(ENUM_Emotions NewEmotion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetPawnEmotion");

	Params::PAWN_Enemy_C_SetPawnEmotion Parms{};

	Parms.NewEmotion = NewEmotion;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnDeathImpact
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FAttribDamageInstance            DamageInstance                                         (BlueprintVisible, BlueprintReadOnly, Parm)
// class UOBJ_ImpactData_C*                ImpactData                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnDeathImpact(const struct FAttribDamageInstance& DamageInstance, class UOBJ_ImpactData_C* ImpactData, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnDeathImpact");

	Params::PAWN_Enemy_C_OnDeathImpact Parms{};

	Parms.DamageInstance = std::move(DamageInstance);
	Parms.ImpactData = ImpactData;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetManeuverLocation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsValid                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetManeuverLocation(bool IsValid, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetManeuverLocation");

	Params::PAWN_Enemy_C_SetManeuverLocation Parms{};

	Parms.IsValid = IsValid;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetManeuverLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsValid                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetManeuverLocation(bool* IsValid, struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetManeuverLocation");

	Params::PAWN_Enemy_C_GetManeuverLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsValid != nullptr)
		*IsValid = Parms.IsValid;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetDynamicPatrolBehavior
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBehaviorTree*                    DynamicBehavior                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetDynamicPatrolBehavior(class UBehaviorTree* DynamicBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetDynamicPatrolBehavior");

	Params::PAWN_Enemy_C_SetDynamicPatrolBehavior Parms{};

	Parms.DynamicBehavior = DynamicBehavior;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnEnemyShouldBeVisible
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    VisibilityState                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnEnemyShouldBeVisible(bool VisibilityState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnEnemyShouldBeVisible");

	Params::PAWN_Enemy_C_OnEnemyShouldBeVisible Parms{};

	Parms.VisibilityState = VisibilityState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnEnemyMightBeAudible
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    AudibilityState                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnEnemyMightBeAudible(bool AudibilityState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnEnemyMightBeAudible");

	Params::PAWN_Enemy_C_OnEnemyMightBeAudible Parms{};

	Parms.AudibilityState = AudibilityState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.AssignNextPatrolNode
// (Public, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::AssignNextPatrolNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "AssignNextPatrolNode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryPrintExploitDamageBonus
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   BonusPercent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             BoneName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::TryPrintExploitDamageBonus(float BonusPercent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryPrintExploitDamageBonus");

	Params::PAWN_Enemy_C_TryPrintExploitDamageBonus Parms{};

	Parms.BonusPercent = BonusPercent;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryStaggerFromDamage
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FAttribDamageInstance            DamageInstance                                         (BlueprintVisible, BlueprintReadOnly, Parm)

void APAWN_Enemy_C::TryStaggerFromDamage(const struct FAttribDamageInstance& DamageInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryStaggerFromDamage");

	Params::PAWN_Enemy_C_TryStaggerFromDamage Parms{};

	Parms.DamageInstance = std::move(DamageInstance);

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetDynamicStaggerBehavior
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBehaviorTree*                    DynamicBehavior                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetDynamicStaggerBehavior(class UBehaviorTree* DynamicBehavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetDynamicStaggerBehavior");

	Params::PAWN_Enemy_C_SetDynamicStaggerBehavior Parms{};

	Parms.DynamicBehavior = DynamicBehavior;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetAnimStance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_Emotions                           Stance                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetAnimStance(ENUM_Emotions Stance, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetAnimStance");

	Params::PAWN_Enemy_C_SetAnimStance Parms{};

	Parms.Stance = Stance;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.InitializeCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::InitializeCharacter(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "InitializeCharacter");

	Params::PAWN_Enemy_C_InitializeCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SpawnHeroGib
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           Class_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       SpawnTransform                                         (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FVector                          Impulse                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Angular_Velocity                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SpawnHeroGib(class UClass* Class_0, const struct FTransform& SpawnTransform, const struct FVector& Impulse, const struct FVector& Angular_Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SpawnHeroGib");

	Params::PAWN_Enemy_C_SpawnHeroGib Parms{};

	Parms.Class_0 = Class_0;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.Impulse = std::move(Impulse);
	Parms.Angular_Velocity = std::move(Angular_Velocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnLimbDismembered
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Limb                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_DismemberableLimb        LimbData                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// class ADismembermentLimb_Base_C*        LimbActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnBeginPlay                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnLimbDismembered(class FName Limb, const struct FSTRUCT_DismemberableLimb& LimbData, class ADismembermentLimb_Base_C* LimbActor, bool OnBeginPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnLimbDismembered");

	Params::PAWN_Enemy_C_OnLimbDismembered Parms{};

	Parms.Limb = Limb;
	Parms.LimbData = std::move(LimbData);
	Parms.LimbActor = LimbActor;
	Parms.OnBeginPlay = OnBeginPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnDynaDamage
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             DynaElement                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnBeginPlay                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnDynaDamage(class FName DynaElement, bool OnBeginPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnDynaDamage");

	Params::PAWN_Enemy_C_OnDynaDamage Parms{};

	Parms.DynaElement = DynaElement;
	Parms.OnBeginPlay = OnBeginPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetDefaultAttributeOverrides
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FDefaultAttribute>        OverrideAttribs                                        (Parm, OutParm)

void APAWN_Enemy_C::GetDefaultAttributeOverrides(TArray<struct FDefaultAttribute>* OverrideAttribs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetDefaultAttributeOverrides");

	Params::PAWN_Enemy_C_GetDefaultAttributeOverrides Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OverrideAttribs != nullptr)
		*OverrideAttribs = std::move(Parms.OverrideAttribs);
}


// Function PAWN_Enemy.PAWN_Enemy_C.ShouldSaveActor
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStreamingSaveGameActorParams    Params_0                                               (Parm, OutParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool APAWN_Enemy_C::ShouldSaveActor(struct FStreamingSaveGameActorParams* Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ShouldSaveActor");

	Params::PAWN_Enemy_C_ShouldSaveActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Params_0 != nullptr)
		*Params_0 = std::move(Parms.Params_0);

	return Parms.ReturnValue;
}


// Function PAWN_Enemy.PAWN_Enemy_C.HasCustomDeathBehavior
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::HasCustomDeathBehavior(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "HasCustomDeathBehavior");

	Params::PAWN_Enemy_C_HasCustomDeathBehavior Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetEnemyScanShape
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UShapeComponent*                  ShapeComponent                                         (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetEnemyScanShape(class UShapeComponent** ShapeComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetEnemyScanShape");

	Params::PAWN_Enemy_C_GetEnemyScanShape Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ShapeComponent != nullptr)
		*ShapeComponent = Parms.ShapeComponent;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsEnemyScannable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsEnemyScannable(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsEnemyScannable");

	Params::PAWN_Enemy_C_IsEnemyScannable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.CanHackEnemy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APAWN_SystemShockCharacter_C*     SourceCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::CanHackEnemy(class APAWN_SystemShockCharacter_C* SourceCharacter, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "CanHackEnemy");

	Params::PAWN_Enemy_C_CanHackEnemy Parms{};

	Parms.SourceCharacter = SourceCharacter;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetEnemyType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// ENUM_EnemyType                          Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetEnemyType(ENUM_EnemyType* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetEnemyType");

	Params::PAWN_Enemy_C_GetEnemyType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetActorLinkedToEnemy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetActorLinkedToEnemy(class AActor** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetActorLinkedToEnemy");

	Params::PAWN_Enemy_C_GetActorLinkedToEnemy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.UpdateEnemyScannableSettings
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::UpdateEnemyScannableSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "UpdateEnemyScannableSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SpawnLootPickups
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::SpawnLootPickups()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SpawnLootPickups");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.UpdateCustomDeathBehavior
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsFinished                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::UpdateCustomDeathBehavior(bool* IsFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "UpdateCustomDeathBehavior");

	Params::PAWN_Enemy_C_UpdateCustomDeathBehavior Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsFinished != nullptr)
		*IsFinished = Parms.IsFinished;
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnStaggerFinished
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::OnStaggerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnStaggerFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.CanShootFromSocket
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          BarrelLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::CanShootFromSocket(class FName SocketName, const struct FVector& BarrelLocation, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "CanShootFromSocket");

	Params::PAWN_Enemy_C_CanShootFromSocket Parms{};

	Parms.SocketName = SocketName;
	Parms.BarrelLocation = std::move(BarrelLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetWeakspotBoneNameForAttack
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          SourceLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ArmorPenetration                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             ResultBoneName                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetWeakspotBoneNameForAttack(const struct FVector& SourceLocation, int32 ArmorPenetration, class FName* ResultBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetWeakspotBoneNameForAttack");

	Params::PAWN_Enemy_C_GetWeakspotBoneNameForAttack Parms{};

	Parms.SourceLocation = std::move(SourceLocation);
	Parms.ArmorPenetration = ArmorPenetration;

	UObject::ProcessEvent(Func, &Parms);

	if (ResultBoneName != nullptr)
		*ResultBoneName = Parms.ResultBoneName;
}


// Function PAWN_Enemy.PAWN_Enemy_C.ClearUniversalWeakpointSockets
// (Public, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::ClearUniversalWeakpointSockets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ClearUniversalWeakpointSockets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetCanStaggerFromDamage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetCanStaggerFromDamage(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetCanStaggerFromDamage");

	Params::PAWN_Enemy_C_SetCanStaggerFromDamage Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetPreferredRangeBias
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Bias                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetPreferredRangeBias(float* Bias)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetPreferredRangeBias");

	Params::PAWN_Enemy_C_GetPreferredRangeBias Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Bias != nullptr)
		*Bias = Parms.Bias;
}


// Function PAWN_Enemy.PAWN_Enemy_C.ReceivePendingBodyTransforms
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FTransform>               BodyTransforms                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool APAWN_Enemy_C::ReceivePendingBodyTransforms(class USkeletalMeshComponent* SkeletalMeshComponent, const TArray<struct FTransform>& BodyTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ReceivePendingBodyTransforms");

	Params::PAWN_Enemy_C_ReceivePendingBodyTransforms Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.BodyTransforms = std::move(BodyTransforms);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetLocalBehaviorComponent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ULocalBehaviorComponent_C*        LocalBehaviorComponent_0                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetLocalBehaviorComponent(class ULocalBehaviorComponent_C* LocalBehaviorComponent_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetLocalBehaviorComponent");

	Params::PAWN_Enemy_C_SetLocalBehaviorComponent Parms{};

	Parms.LocalBehaviorComponent_0 = LocalBehaviorComponent_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetLocalBehaviorComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ULocalBehaviorComponent_C*        LocalBehaviorComponent_0                               (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetLocalBehaviorComponent(class ULocalBehaviorComponent_C** LocalBehaviorComponent_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetLocalBehaviorComponent");

	Params::PAWN_Enemy_C_GetLocalBehaviorComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LocalBehaviorComponent_0 != nullptr)
		*LocalBehaviorComponent_0 = Parms.LocalBehaviorComponent_0;
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnLivingCharacterDestroyed
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    RemovedDuringMapChange                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnLivingCharacterDestroyed(bool RemovedDuringMapChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnLivingCharacterDestroyed");

	Params::PAWN_Enemy_C_OnLivingCharacterDestroyed Parms{};

	Parms.RemovedDuringMapChange = RemovedDuringMapChange;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetThreatLevel
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetThreatLevel(int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetThreatLevel");

	Params::PAWN_Enemy_C_GetThreatLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsStunned
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsStunned(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsStunned");

	Params::PAWN_Enemy_C_IsStunned Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetShockAgentLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetShockAgentLocation(struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetShockAgentLocation");

	Params::PAWN_Enemy_C_GetShockAgentLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsUnderImmediateThreat
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsUnderImmediateThreat(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsUnderImmediateThreat");

	Params::PAWN_Enemy_C_IsUnderImmediateThreat Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetImmediatelyThreatened
// (Public, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::SetImmediatelyThreatened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetImmediatelyThreatened");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.EVENT_OnDisableAttribChanged
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CurrValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   LastValue                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::EVENT_OnDisableAttribChanged(float CurrValue, float LastValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "EVENT_OnDisableAttribChanged");

	Params::PAWN_Enemy_C_EVENT_OnDisableAttribChanged Parms{};

	Parms.CurrValue = CurrValue;
	Parms.LastValue = LastValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnEnemyCorpseDestroyed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    OnBeginPlay                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnEnemyCorpseDestroyed(bool OnBeginPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnEnemyCorpseDestroyed");

	Params::PAWN_Enemy_C_OnEnemyCorpseDestroyed Parms{};

	Parms.OnBeginPlay = OnBeginPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnMagneticDisableStateChanged
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    DisableState                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnMagneticDisableStateChanged(bool DisableState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnMagneticDisableStateChanged");

	Params::PAWN_Enemy_C_OnMagneticDisableStateChanged Parms{};

	Parms.DisableState = DisableState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsStaggered
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsStaggered(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsStaggered");

	Params::PAWN_Enemy_C_IsStaggered Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetEnemyLightManager
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ULightTransitionManager_C*        Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetEnemyLightManager(class ULightTransitionManager_C** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetEnemyLightManager");

	Params::PAWN_Enemy_C_GetEnemyLightManager Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetLightFadeDurationOnDeath
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetLightFadeDurationOnDeath(float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetLightFadeDurationOnDeath");

	Params::PAWN_Enemy_C_GetLightFadeDurationOnDeath Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsGroundAlignmentEnabled
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsGroundAlignmentEnabled(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsGroundAlignmentEnabled");

	Params::PAWN_Enemy_C_IsGroundAlignmentEnabled Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryInitializeGroundAlignmentSystem
// (Protected, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::TryInitializeGroundAlignmentSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryInitializeGroundAlignmentSystem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.EVENT_UpdateGroundAlignment
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::EVENT_UpdateGroundAlignment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "EVENT_UpdateGroundAlignment");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryModifyGroundAlignmentTimerState
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryModifyGroundAlignmentTimerState(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryModifyGroundAlignmentTimerState");

	Params::PAWN_Enemy_C_TryModifyGroundAlignmentTimerState Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.ForceStartNextGroundAlignmentTick
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::ForceStartNextGroundAlignmentTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ForceStartNextGroundAlignmentTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryStartGroundAlignmentTimer
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryStartGroundAlignmentTimer(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryStartGroundAlignmentTimer");

	Params::PAWN_Enemy_C_TryStartGroundAlignmentTimer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryStopGroundAlignmentTimer
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryStopGroundAlignmentTimer(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryStopGroundAlignmentTimer");

	Params::PAWN_Enemy_C_TryStopGroundAlignmentTimer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.ComputeGroundAlignmentNormal
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Normal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::ComputeGroundAlignmentNormal(struct FVector* Normal, float* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ComputeGroundAlignmentNormal");

	Params::PAWN_Enemy_C_ComputeGroundAlignmentNormal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Normal != nullptr)
		*Normal = std::move(Parms.Normal);

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetShouldExplorePointsOfInterest
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetShouldExplorePointsOfInterest(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetShouldExplorePointsOfInterest");

	Params::PAWN_Enemy_C_SetShouldExplorePointsOfInterest Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetShouldExplorePointsOfInterest
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::GetShouldExplorePointsOfInterest(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetShouldExplorePointsOfInterest");

	Params::PAWN_Enemy_C_GetShouldExplorePointsOfInterest Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetLocalBehaviorAnimationDataByType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_LocalBehaviorType                  BehaviorType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FSTRUCT_LocalBehaviorAnimations  Result                                                 (Parm, OutParm, HasGetValueTypeHash)

void APAWN_Enemy_C::GetLocalBehaviorAnimationDataByType(ENUM_LocalBehaviorType BehaviorType, bool* Found, struct FSTRUCT_LocalBehaviorAnimations* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetLocalBehaviorAnimationDataByType");

	Params::PAWN_Enemy_C_GetLocalBehaviorAnimationDataByType Parms{};

	Parms.BehaviorType = BehaviorType;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryClaimNextPointOfInterest
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryClaimNextPointOfInterest(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryClaimNextPointOfInterest");

	Params::PAWN_Enemy_C_TryClaimNextPointOfInterest Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryUnclaimCurrentPointOfInterest
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    AddToExcludeList                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryUnclaimCurrentPointOfInterest(bool AddToExcludeList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryUnclaimCurrentPointOfInterest");

	Params::PAWN_Enemy_C_TryUnclaimCurrentPointOfInterest Parms{};

	Parms.AddToExcludeList = AddToExcludeList;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryAssignNextLocalBehavior
// (Public, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::TryAssignNextLocalBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryAssignNextLocalBehavior");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryStartPointOfInterestCreationTimer
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::TryStartPointOfInterestCreationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryStartPointOfInterestCreationTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.EVENT_TryCreatePointOfInterest
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::EVENT_TryCreatePointOfInterest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "EVENT_TryCreatePointOfInterest");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.InitializePointOfInterestAfterDeath
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USpawnedPointOfInterest_C*        Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::InitializePointOfInterestAfterDeath(class USpawnedPointOfInterest_C* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "InitializePointOfInterestAfterDeath");

	Params::PAWN_Enemy_C_InitializePointOfInterestAfterDeath Parms{};

	Parms.Component = Component;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.EVENT_OnDelayedStopLogic
// (Private, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::EVENT_OnDelayedStopLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "EVENT_OnDelayedStopLogic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.EVENT_OnTryCleanupBeforeUnloadLevelCollection
// (Private, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::EVENT_OnTryCleanupBeforeUnloadLevelCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "EVENT_OnTryCleanupBeforeUnloadLevelCollection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnEnemyRadarScannedStateChanged
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnEnemyRadarScannedStateChanged(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnEnemyRadarScannedStateChanged");

	Params::PAWN_Enemy_C_OnEnemyRadarScannedStateChanged Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetMeshComponentsForTeleport
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMeshComponent*>           MeshComponents                                         (Parm, OutParm, ContainsInstancedReference)

void APAWN_Enemy_C::GetMeshComponentsForTeleport(TArray<class UMeshComponent*>* MeshComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetMeshComponentsForTeleport");

	Params::PAWN_Enemy_C_GetMeshComponentsForTeleport Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MeshComponents != nullptr)
		*MeshComponents = std::move(Parms.MeshComponents);
}


// Function PAWN_Enemy.PAWN_Enemy_C.UpdateCharacterStateForTeleport
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ShouldUpdateVisibility                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::UpdateCharacterStateForTeleport(bool ShouldUpdateVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "UpdateCharacterStateForTeleport");

	Params::PAWN_Enemy_C_UpdateCharacterStateForTeleport Parms{};

	Parms.ShouldUpdateVisibility = ShouldUpdateVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetDefaultLightEmissiveIntensity
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Intensity                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TransitionDuration                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::SetDefaultLightEmissiveIntensity(float Intensity, float TransitionDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetDefaultLightEmissiveIntensity");

	Params::PAWN_Enemy_C_SetDefaultLightEmissiveIntensity Parms{};

	Parms.Intensity = Intensity;
	Parms.TransitionDuration = TransitionDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnEnemySpawned
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APatrolNode_C*                    InitialPatrolNode                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             UniqueLootItem                                         (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    AdjustToFloor                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnEnemySpawned(class APatrolNode_C* InitialPatrolNode, TSoftClassPtr<class UClass> UniqueLootItem, bool AdjustToFloor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnEnemySpawned");

	Params::PAWN_Enemy_C_OnEnemySpawned Parms{};

	Parms.InitialPatrolNode = InitialPatrolNode;
	Parms.UniqueLootItem = UniqueLootItem;
	Parms.AdjustToFloor = AdjustToFloor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsCharacterVisible
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsCharacterVisible(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsCharacterVisible");

	Params::PAWN_Enemy_C_IsCharacterVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnCharacterVisibilityChanged
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    VisibilityState                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::OnCharacterVisibilityChanged(bool VisibilityState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnCharacterVisibilityChanged");

	Params::PAWN_Enemy_C_OnCharacterVisibilityChanged Parms{};

	Parms.VisibilityState = VisibilityState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PAWN_Enemy.PAWN_Enemy_C.OnSkillTargetChanged
// (Protected, BlueprintCallable, BlueprintEvent)

void APAWN_Enemy_C::OnSkillTargetChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "OnSkillTargetChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetLocalVisionRotation
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FRotator                         Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::GetLocalVisionRotation(struct FRotator* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetLocalVisionRotation");

	Params::PAWN_Enemy_C_GetLocalVisionRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryUpdateSpawnLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryUpdateSpawnLocation(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryUpdateSpawnLocation");

	Params::PAWN_Enemy_C_TryUpdateSpawnLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsRealspaceCharacter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsRealspaceCharacter(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsRealspaceCharacter");

	Params::PAWN_Enemy_C_IsRealspaceCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetInteractBroken
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FText                             BrokenMessage                                          (Parm, OutParm)

void APAWN_Enemy_C::GetInteractBroken(bool* Result, class FText* BrokenMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetInteractBroken");

	Params::PAWN_Enemy_C_GetInteractBroken Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (BrokenMessage != nullptr)
		*BrokenMessage = std::move(Parms.BrokenMessage);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetInteractLocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           SourceActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FText                             LockMessage                                            (Parm, OutParm)

void APAWN_Enemy_C::GetInteractLocked(class AActor* SourceActor, bool* Result, class FText* LockMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetInteractLocked");

	Params::PAWN_Enemy_C_GetInteractLocked Parms{};

	Parms.SourceActor = SourceActor;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (LockMessage != nullptr)
		*LockMessage = std::move(Parms.LockMessage);
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetInteractBusy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FText                             BusyMessage                                            (Parm, OutParm)

void APAWN_Enemy_C::GetInteractBusy(bool* Result, class FText* BusyMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetInteractBusy");

	Params::PAWN_Enemy_C_GetInteractBusy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (BusyMessage != nullptr)
		*BusyMessage = std::move(Parms.BusyMessage);
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetInteractLocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Locked                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetInteractLocked(bool Locked, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetInteractLocked");

	Params::PAWN_Enemy_C_SetInteractLocked Parms{};

	Parms.Locked = Locked;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.StopChanneling
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           NewChannelingInteract                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::StopChanneling(class AActor* NewChannelingInteract, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "StopChanneling");

	Params::PAWN_Enemy_C_StopChanneling Parms{};

	Parms.NewChannelingInteract = NewChannelingInteract;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetTargetShape
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              CursorPrimitive                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UShapeComponent*                  ShapeComponent                                         (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetTargetShape(class UPrimitiveComponent* CursorPrimitive, class UShapeComponent** ShapeComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetTargetShape");

	Params::PAWN_Enemy_C_GetTargetShape Parms{};

	Parms.CursorPrimitive = CursorPrimitive;

	UObject::ProcessEvent(Func, &Parms);

	if (ShapeComponent != nullptr)
		*ShapeComponent = Parms.ShapeComponent;
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryInteract
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           SourceActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              CursorPrimitive                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_InteractionType                    InteractionType                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_InteractResults          InteractResults                                        (Parm, OutParm, HasGetValueTypeHash)

void APAWN_Enemy_C::TryInteract(class AActor* SourceActor, class UPrimitiveComponent* CursorPrimitive, ENUM_InteractionType InteractionType, struct FSTRUCT_InteractResults* InteractResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryInteract");

	Params::PAWN_Enemy_C_TryInteract Parms{};

	Parms.SourceActor = SourceActor;
	Parms.CursorPrimitive = CursorPrimitive;
	Parms.InteractionType = InteractionType;

	UObject::ProcessEvent(Func, &Parms);

	if (InteractResults != nullptr)
		*InteractResults = std::move(Parms.InteractResults);
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryReceiveItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UITEM_Base_C*                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryReceiveItem(class UITEM_Base_C* Item, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryReceiveItem");

	Params::PAWN_Enemy_C_TryReceiveItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsHiddenInteractablePrimitive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              CursorPrimitive                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsHiddenInteractablePrimitive(class APAWN_SystemShockCharacter_C* Character, class UPrimitiveComponent* CursorPrimitive, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsHiddenInteractablePrimitive");

	Params::PAWN_Enemy_C_IsHiddenInteractablePrimitive Parms{};

	Parms.Character = Character;
	Parms.CursorPrimitive = CursorPrimitive;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.ShouldIgnoreInteractRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::ShouldIgnoreInteractRange(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "ShouldIgnoreInteractRange");

	Params::PAWN_Enemy_C_ShouldIgnoreInteractRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.CanReceiveItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UITEM_Base_C*                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::CanReceiveItem(class UITEM_Base_C* Item, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "CanReceiveItem");

	Params::PAWN_Enemy_C_CanReceiveItem Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.IsInteractActivated
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::IsInteractActivated(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "IsInteractActivated");

	Params::PAWN_Enemy_C_IsInteractActivated Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetInteractDestroyed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::GetInteractDestroyed(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetInteractDestroyed");

	Params::PAWN_Enemy_C_GetInteractDestroyed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.CanInteractBeDestroyed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::CanInteractBeDestroyed(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "CanInteractBeDestroyed");

	Params::PAWN_Enemy_C_CanInteractBeDestroyed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.SetInteractPowered
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::SetInteractPowered(bool State, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "SetInteractPowered");

	Params::PAWN_Enemy_C_SetInteractPowered Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.CanModifyInteractPower
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::CanModifyInteractPower(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "CanModifyInteractPower");

	Params::PAWN_Enemy_C_CanModifyInteractPower Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetChannelingHoldDuration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void APAWN_Enemy_C::GetChannelingHoldDuration(float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetChannelingHoldDuration");

	Params::PAWN_Enemy_C_GetChannelingHoldDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.FinishedChannelingHoldInteraction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::FinishedChannelingHoldInteraction(class APAWN_SystemShockCharacter_C* Character, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "FinishedChannelingHoldInteraction");

	Params::PAWN_Enemy_C_FinishedChannelingHoldInteraction Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.TryDetachInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SimulatePhysics                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void APAWN_Enemy_C::TryDetachInteract(bool SimulatePhysics, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "TryDetachInteract");

	Params::PAWN_Enemy_C_TryDetachInteract Parms{};

	Parms.SimulatePhysics = SimulatePhysics;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PAWN_Enemy.PAWN_Enemy_C.GetEnemyDisplayName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             Text                                                   (Parm, OutParm)

void APAWN_Enemy_C::GetEnemyDisplayName(class FText* Text) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PAWN_Enemy_C", "GetEnemyDisplayName");

	Params::PAWN_Enemy_C_GetEnemyDisplayName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Text != nullptr)
		*Text = std::move(Parms.Text);
}

}

