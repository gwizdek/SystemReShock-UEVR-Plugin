#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: WEAPON_MagPulse

#include "Basic.hpp"

#include "STRUCT_WeaponMode_structs.hpp"
#include "STRUCT_WeaponPropertyValue_structs.hpp"
#include "AttributeSystem_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.ExecuteUbergraph_WEAPON_MagPulse
// 0x00F8 (0x00F8 - 0x0000)
struct WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse final
{
public:
	int32                                         EntryPoint;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TDelegate<void(class UObject* Loaded)>        K2Node_CreateDelegate_OutputDelegate;              // 0x0004(0x0010)(ZeroConstructor, NoDestructor)
	TDelegate<void(class UObject* Loaded)>        K2Node_CreateDelegate_OutputDelegate_1;            // 0x0014(0x0010)(ZeroConstructor, NoDestructor)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                K2Node_CustomEvent_Loaded_4;                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TDelegate<void(class UObject* Loaded)>        K2Node_CreateDelegate_OutputDelegate_2;            // 0x0030(0x0010)(ZeroConstructor, NoDestructor)
	class UObject*                                Temp_object_Variable;                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           K2Node_DynamicCast_AsAnim_Montage;                 // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                K2Node_CustomEvent_Loaded_3;                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UObject*                                Temp_object_Variable_1;                            // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UForceFeedbackEffect*                   K2Node_DynamicCast_AsForce_Feedback_Effect;        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_1;                     // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                K2Node_CustomEvent_Loaded_2;                       // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UObject*                                Temp_object_Variable_2;                            // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UForceFeedbackEffect*                   K2Node_DynamicCast_AsForce_Feedback_Effect_1;      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_2;                     // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                K2Node_CustomEvent_Loaded_1;                       // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UObject*                                Temp_object_Variable_3;                            // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UNiagaraSystem*                         K2Node_DynamicCast_AsNiagara_System;               // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_3;                     // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                K2Node_CustomEvent_Loaded;                         // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UObject*                                Temp_object_Variable_4;                            // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UNiagaraSystem*                         K2Node_DynamicCast_AsNiagara_System_1;             // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess_4;                     // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UObject* Loaded)>        K2Node_CreateDelegate_OutputDelegate_3;            // 0x00D4(0x0010)(ZeroConstructor, NoDestructor)
	TDelegate<void(class UObject* Loaded)>        K2Node_CreateDelegate_OutputDelegate_4;            // 0x00E4(0x0010)(ZeroConstructor, NoDestructor)
	bool                                          CallFunc_EqualEqual_ByteByte_ReturnValue;          // 0x00F4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse");
static_assert(sizeof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse) == 0x0000F8, "Wrong size on WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, EntryPoint) == 0x000000, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::EntryPoint' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CreateDelegate_OutputDelegate) == 0x000004, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CreateDelegate_OutputDelegate' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CreateDelegate_OutputDelegate_1) == 0x000014, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CreateDelegate_OutputDelegate_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CustomEvent_Loaded_4) == 0x000028, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CustomEvent_Loaded_4' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CreateDelegate_OutputDelegate_2) == 0x000030, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CreateDelegate_OutputDelegate_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, Temp_object_Variable) == 0x000040, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::Temp_object_Variable' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_AsAnim_Montage) == 0x000048, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_AsAnim_Montage' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_bSuccess) == 0x000050, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CustomEvent_Loaded_3) == 0x000058, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CustomEvent_Loaded_3' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, Temp_object_Variable_1) == 0x000060, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::Temp_object_Variable_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_AsForce_Feedback_Effect) == 0x000068, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_AsForce_Feedback_Effect' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_bSuccess_1) == 0x000070, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_bSuccess_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CustomEvent_Loaded_2) == 0x000078, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CustomEvent_Loaded_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, Temp_object_Variable_2) == 0x000080, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::Temp_object_Variable_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_AsForce_Feedback_Effect_1) == 0x000088, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_AsForce_Feedback_Effect_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_bSuccess_2) == 0x000090, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_bSuccess_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CustomEvent_Loaded_1) == 0x000098, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CustomEvent_Loaded_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, Temp_object_Variable_3) == 0x0000A0, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::Temp_object_Variable_3' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_AsNiagara_System) == 0x0000A8, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_AsNiagara_System' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_bSuccess_3) == 0x0000B0, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_bSuccess_3' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CustomEvent_Loaded) == 0x0000B8, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CustomEvent_Loaded' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, Temp_object_Variable_4) == 0x0000C0, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::Temp_object_Variable_4' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_AsNiagara_System_1) == 0x0000C8, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_AsNiagara_System_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_DynamicCast_bSuccess_4) == 0x0000D0, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_DynamicCast_bSuccess_4' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CreateDelegate_OutputDelegate_3) == 0x0000D4, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CreateDelegate_OutputDelegate_3' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, K2Node_CreateDelegate_OutputDelegate_4) == 0x0000E4, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::K2Node_CreateDelegate_OutputDelegate_4' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse, CallFunc_EqualEqual_ByteByte_ReturnValue) == 0x0000F4, "Member 'WEAPON_MagPulse_C_ExecuteUbergraph_WEAPON_MagPulse::CallFunc_EqualEqual_ByteByte_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.OnLoaded_7905D5934213E96998D87D899A24F5F8
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_OnLoaded_7905D5934213E96998D87D899A24F5F8 final
{
public:
	class UObject*                                Loaded;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_OnLoaded_7905D5934213E96998D87D899A24F5F8) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_OnLoaded_7905D5934213E96998D87D899A24F5F8");
static_assert(sizeof(WEAPON_MagPulse_C_OnLoaded_7905D5934213E96998D87D899A24F5F8) == 0x000008, "Wrong size on WEAPON_MagPulse_C_OnLoaded_7905D5934213E96998D87D899A24F5F8");
static_assert(offsetof(WEAPON_MagPulse_C_OnLoaded_7905D5934213E96998D87D899A24F5F8, Loaded) == 0x000000, "Member 'WEAPON_MagPulse_C_OnLoaded_7905D5934213E96998D87D899A24F5F8::Loaded' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.OnLoaded_DF0330F84AD5B08E45DD94A65F5DE16A
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_OnLoaded_DF0330F84AD5B08E45DD94A65F5DE16A final
{
public:
	class UObject*                                Loaded;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_OnLoaded_DF0330F84AD5B08E45DD94A65F5DE16A) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_OnLoaded_DF0330F84AD5B08E45DD94A65F5DE16A");
static_assert(sizeof(WEAPON_MagPulse_C_OnLoaded_DF0330F84AD5B08E45DD94A65F5DE16A) == 0x000008, "Wrong size on WEAPON_MagPulse_C_OnLoaded_DF0330F84AD5B08E45DD94A65F5DE16A");
static_assert(offsetof(WEAPON_MagPulse_C_OnLoaded_DF0330F84AD5B08E45DD94A65F5DE16A, Loaded) == 0x000000, "Member 'WEAPON_MagPulse_C_OnLoaded_DF0330F84AD5B08E45DD94A65F5DE16A::Loaded' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.OnLoaded_7AC8171242E08757C012A28D2888D2EE
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_OnLoaded_7AC8171242E08757C012A28D2888D2EE final
{
public:
	class UObject*                                Loaded;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_OnLoaded_7AC8171242E08757C012A28D2888D2EE) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_OnLoaded_7AC8171242E08757C012A28D2888D2EE");
static_assert(sizeof(WEAPON_MagPulse_C_OnLoaded_7AC8171242E08757C012A28D2888D2EE) == 0x000008, "Wrong size on WEAPON_MagPulse_C_OnLoaded_7AC8171242E08757C012A28D2888D2EE");
static_assert(offsetof(WEAPON_MagPulse_C_OnLoaded_7AC8171242E08757C012A28D2888D2EE, Loaded) == 0x000000, "Member 'WEAPON_MagPulse_C_OnLoaded_7AC8171242E08757C012A28D2888D2EE::Loaded' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.OnLoaded_7CE911E0462524EB72113185AFA826F0
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_OnLoaded_7CE911E0462524EB72113185AFA826F0 final
{
public:
	class UObject*                                Loaded;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_OnLoaded_7CE911E0462524EB72113185AFA826F0) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_OnLoaded_7CE911E0462524EB72113185AFA826F0");
static_assert(sizeof(WEAPON_MagPulse_C_OnLoaded_7CE911E0462524EB72113185AFA826F0) == 0x000008, "Wrong size on WEAPON_MagPulse_C_OnLoaded_7CE911E0462524EB72113185AFA826F0");
static_assert(offsetof(WEAPON_MagPulse_C_OnLoaded_7CE911E0462524EB72113185AFA826F0, Loaded) == 0x000000, "Member 'WEAPON_MagPulse_C_OnLoaded_7CE911E0462524EB72113185AFA826F0::Loaded' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.OnLoaded_9B50D63949E067619A9920B4DD9E853D
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_OnLoaded_9B50D63949E067619A9920B4DD9E853D final
{
public:
	class UObject*                                Loaded;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_OnLoaded_9B50D63949E067619A9920B4DD9E853D) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_OnLoaded_9B50D63949E067619A9920B4DD9E853D");
static_assert(sizeof(WEAPON_MagPulse_C_OnLoaded_9B50D63949E067619A9920B4DD9E853D) == 0x000008, "Wrong size on WEAPON_MagPulse_C_OnLoaded_9B50D63949E067619A9920B4DD9E853D");
static_assert(offsetof(WEAPON_MagPulse_C_OnLoaded_9B50D63949E067619A9920B4DD9E853D, Loaded) == 0x000000, "Member 'WEAPON_MagPulse_C_OnLoaded_9B50D63949E067619A9920B4DD9E853D::Loaded' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.ApplyCharge
// 0x00E0 (0x00E0 - 0x0000)
struct WEAPON_MagPulse_C_ApplyCharge final
{
public:
	int32                                         EnergyInReserves;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAttribModApplyData                    EnergyDrainApplyData;                              // 0x0008(0x00A0)(Edit, BlueprintVisible)
	class UCOMP_AttribManager_C*                  OwnerAttribManager;                                // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue;               // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_GetAttribValue_ReturnValue;               // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue;              // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_FTrunc_ReturnValue;                       // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAttribMod*                             CallFunc_ApplyMod_ReturnValue;                     // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue_1;             // 0x00C8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_SystemShockCharacter_C*           CallFunc_GetOwnerCharacter_Character;              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Min_ReturnValue;                          // 0x00D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         CallFunc_Conv_IntToByte_ReturnValue;               // 0x00DC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_EqualEqual_ByteByte_ReturnValue;          // 0x00DD(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         CallFunc_Add_ByteByte_ReturnValue;                 // 0x00DE(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_ApplyCharge) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_ApplyCharge");
static_assert(sizeof(WEAPON_MagPulse_C_ApplyCharge) == 0x0000E0, "Wrong size on WEAPON_MagPulse_C_ApplyCharge");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, EnergyInReserves) == 0x000000, "Member 'WEAPON_MagPulse_C_ApplyCharge::EnergyInReserves' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, EnergyDrainApplyData) == 0x000008, "Member 'WEAPON_MagPulse_C_ApplyCharge::EnergyDrainApplyData' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, OwnerAttribManager) == 0x0000A8, "Member 'WEAPON_MagPulse_C_ApplyCharge::OwnerAttribManager' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_Conv_ByteToInt_ReturnValue) == 0x0000B0, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_Conv_ByteToInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_GetAttribValue_ReturnValue) == 0x0000B4, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_GetAttribValue_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_Conv_IntToFloat_ReturnValue) == 0x0000B8, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_Conv_IntToFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_FTrunc_ReturnValue) == 0x0000BC, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_FTrunc_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_ApplyMod_ReturnValue) == 0x0000C0, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_ApplyMod_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_Conv_ByteToInt_ReturnValue_1) == 0x0000C8, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_Conv_ByteToInt_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_GetOwnerCharacter_Character) == 0x0000D0, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_GetOwnerCharacter_Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_Min_ReturnValue) == 0x0000D8, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_Min_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_Conv_IntToByte_ReturnValue) == 0x0000DC, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_Conv_IntToByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_EqualEqual_ByteByte_ReturnValue) == 0x0000DD, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_EqualEqual_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyCharge, CallFunc_Add_ByteByte_ReturnValue) == 0x0000DE, "Member 'WEAPON_MagPulse_C_ApplyCharge::CallFunc_Add_ByteByte_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.ConsumeAmmo
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_ConsumeAmmo final
{
public:
	float                                         CallFunc_RandomFloat_ReturnValue;                  // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_FloatFloat_ReturnValue;           // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_ConsumeAmmo) == 0x000004, "Wrong alignment on WEAPON_MagPulse_C_ConsumeAmmo");
static_assert(sizeof(WEAPON_MagPulse_C_ConsumeAmmo) == 0x000008, "Wrong size on WEAPON_MagPulse_C_ConsumeAmmo");
static_assert(offsetof(WEAPON_MagPulse_C_ConsumeAmmo, CallFunc_RandomFloat_ReturnValue) == 0x000000, "Member 'WEAPON_MagPulse_C_ConsumeAmmo::CallFunc_RandomFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ConsumeAmmo, CallFunc_Greater_FloatFloat_ReturnValue) == 0x000004, "Member 'WEAPON_MagPulse_C_ConsumeAmmo::CallFunc_Greater_FloatFloat_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.TryCharge
// 0x0030 (0x0030 - 0x0000)
struct WEAPON_MagPulse_C_TryCharge final
{
public:
	class APAWN_SystemShockCharacter_C*           CharacterOwner;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_SystemShockCharacter_C*           CallFunc_GetOwnerCharacter_Character;              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_GetAttribValue_ReturnValue;               // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_FloatFloat_ReturnValue;           // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Less_ByteByte_ReturnValue;                // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_GetAmmoInMagazine_Ammo;                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsActivatable_Result;                     // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Greater_IntInt_ReturnValue;               // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterAction_C*                     CallFunc_TryBeginAction_Action;                    // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Less_ByteByte_ReturnValue_1;              // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_TryCharge) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_TryCharge");
static_assert(sizeof(WEAPON_MagPulse_C_TryCharge) == 0x000030, "Wrong size on WEAPON_MagPulse_C_TryCharge");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CharacterOwner) == 0x000000, "Member 'WEAPON_MagPulse_C_TryCharge::CharacterOwner' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_GetOwnerCharacter_Character) == 0x000008, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_GetOwnerCharacter_Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_GetAttribValue_ReturnValue) == 0x000010, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_GetAttribValue_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_Greater_FloatFloat_ReturnValue) == 0x000014, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_Greater_FloatFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_Less_ByteByte_ReturnValue) == 0x000015, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_Less_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_GetAmmoInMagazine_Ammo) == 0x000018, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_GetAmmoInMagazine_Ammo' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_IsActivatable_Result) == 0x00001C, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_IsActivatable_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_Greater_IntInt_ReturnValue) == 0x00001D, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_Greater_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_TryBeginAction_Action) == 0x000020, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_TryBeginAction_Action' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_Less_ByteByte_ReturnValue_1) == 0x000028, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_Less_ByteByte_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCharge, CallFunc_IsValid_ReturnValue) == 0x000029, "Member 'WEAPON_MagPulse_C_TryCharge::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.SetListenForActionFinished
// 0x0038 (0x0038 - 0x0000)
struct WEAPON_MagPulse_C_SetListenForActionFinished final
{
public:
	bool                                          ShouldListen;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_SystemShockCharacter_C*           CallFunc_GetOwnerCharacter_Character;              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TDelegate<void(class UCharacterAction_C* Action)> K2Node_CreateDelegate_OutputDelegate;              // 0x0010(0x0010)(ZeroConstructor, NoDestructor)
	TDelegate<void(class UCharacterAction_C* Action)> K2Node_CreateDelegate_OutputDelegate_1;            // 0x0020(0x0010)(ZeroConstructor, NoDestructor)
	class APAWN_SystemShockCharacter_C*           CallFunc_GetOwnerCharacter_Character_1;            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_SetListenForActionFinished) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_SetListenForActionFinished");
static_assert(sizeof(WEAPON_MagPulse_C_SetListenForActionFinished) == 0x000038, "Wrong size on WEAPON_MagPulse_C_SetListenForActionFinished");
static_assert(offsetof(WEAPON_MagPulse_C_SetListenForActionFinished, ShouldListen) == 0x000000, "Member 'WEAPON_MagPulse_C_SetListenForActionFinished::ShouldListen' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_SetListenForActionFinished, CallFunc_GetOwnerCharacter_Character) == 0x000008, "Member 'WEAPON_MagPulse_C_SetListenForActionFinished::CallFunc_GetOwnerCharacter_Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_SetListenForActionFinished, K2Node_CreateDelegate_OutputDelegate) == 0x000010, "Member 'WEAPON_MagPulse_C_SetListenForActionFinished::K2Node_CreateDelegate_OutputDelegate' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_SetListenForActionFinished, K2Node_CreateDelegate_OutputDelegate_1) == 0x000020, "Member 'WEAPON_MagPulse_C_SetListenForActionFinished::K2Node_CreateDelegate_OutputDelegate_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_SetListenForActionFinished, CallFunc_GetOwnerCharacter_Character_1) == 0x000030, "Member 'WEAPON_MagPulse_C_SetListenForActionFinished::CallFunc_GetOwnerCharacter_Character_1' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.EVENT_OnActionEnded
// 0x0018 (0x0018 - 0x0000)
struct WEAPON_MagPulse_C_EVENT_OnActionEnded final
{
public:
	class UCharacterAction_C*                     Action;                                            // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           CallFunc_GetMontage_Result;                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_EqualEqual_ObjectObject_ReturnValue;      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_EVENT_OnActionEnded) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_EVENT_OnActionEnded");
static_assert(sizeof(WEAPON_MagPulse_C_EVENT_OnActionEnded) == 0x000018, "Wrong size on WEAPON_MagPulse_C_EVENT_OnActionEnded");
static_assert(offsetof(WEAPON_MagPulse_C_EVENT_OnActionEnded, Action) == 0x000000, "Member 'WEAPON_MagPulse_C_EVENT_OnActionEnded::Action' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_EVENT_OnActionEnded, CallFunc_GetMontage_Result) == 0x000008, "Member 'WEAPON_MagPulse_C_EVENT_OnActionEnded::CallFunc_GetMontage_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_EVENT_OnActionEnded, CallFunc_EqualEqual_ObjectObject_ReturnValue) == 0x000010, "Member 'WEAPON_MagPulse_C_EVENT_OnActionEnded::CallFunc_EqualEqual_ObjectObject_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.SetCurrentChargeCount
// 0x0001 (0x0001 - 0x0000)
struct WEAPON_MagPulse_C_SetCurrentChargeCount final
{
public:
	uint8                                         Count_0;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_SetCurrentChargeCount) == 0x000001, "Wrong alignment on WEAPON_MagPulse_C_SetCurrentChargeCount");
static_assert(sizeof(WEAPON_MagPulse_C_SetCurrentChargeCount) == 0x000001, "Wrong size on WEAPON_MagPulse_C_SetCurrentChargeCount");
static_assert(offsetof(WEAPON_MagPulse_C_SetCurrentChargeCount, Count_0) == 0x000000, "Member 'WEAPON_MagPulse_C_SetCurrentChargeCount::Count_0' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.SetHasBarrelExtension
// 0x0001 (0x0001 - 0x0000)
struct WEAPON_MagPulse_C_SetHasBarrelExtension final
{
public:
	bool                                          State;                                             // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_SetHasBarrelExtension) == 0x000001, "Wrong alignment on WEAPON_MagPulse_C_SetHasBarrelExtension");
static_assert(sizeof(WEAPON_MagPulse_C_SetHasBarrelExtension) == 0x000001, "Wrong size on WEAPON_MagPulse_C_SetHasBarrelExtension");
static_assert(offsetof(WEAPON_MagPulse_C_SetHasBarrelExtension, State) == 0x000000, "Member 'WEAPON_MagPulse_C_SetHasBarrelExtension::State' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.GetChargedMode
// 0x0340 (0x0340 - 0x0000)
struct WEAPON_MagPulse_C_GetChargedMode final
{
public:
	struct FSTRUCT_WeaponMode                     Mode;                                              // 0x0000(0x0100)(BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
	struct FSTRUCT_WeaponMode                     Result;                                            // 0x0100(0x0100)(Parm, OutParm, HasGetValueTypeHash)
	int32                                         SecondaryDamageIndex;                              // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSTRUCT_WeaponMode                     ModifiedMode;                                      // 0x0208(0x0100)(Edit, BlueprintVisible, HasGetValueTypeHash)
	int32                                         CallFunc_GetWeaponPropertyIndexByType_ArrayIndex;  // 0x0308(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue;               // 0x030C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Multiply_IntInt_ReturnValue;              // 0x0310(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue_1;             // 0x0314(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Multiply_IntInt_ReturnValue_1;            // 0x0318(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Add_IntInt_ReturnValue;                   // 0x031C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue_2;             // 0x0320(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue_3;             // 0x0324(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_ByteByte_ReturnValue;             // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_Multiply_IntInt_ReturnValue_2;            // 0x032C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Add_IntInt_ReturnValue_1;                 // 0x0330(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FSTRUCT_WeaponPropertyValue            K2Node_MakeStruct_STRUCT_WeaponPropertyValue;      // 0x0334(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_GetChargedMode) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_GetChargedMode");
static_assert(sizeof(WEAPON_MagPulse_C_GetChargedMode) == 0x000340, "Wrong size on WEAPON_MagPulse_C_GetChargedMode");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, Mode) == 0x000000, "Member 'WEAPON_MagPulse_C_GetChargedMode::Mode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, Result) == 0x000100, "Member 'WEAPON_MagPulse_C_GetChargedMode::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, SecondaryDamageIndex) == 0x000200, "Member 'WEAPON_MagPulse_C_GetChargedMode::SecondaryDamageIndex' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, ModifiedMode) == 0x000208, "Member 'WEAPON_MagPulse_C_GetChargedMode::ModifiedMode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_GetWeaponPropertyIndexByType_ArrayIndex) == 0x000308, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_GetWeaponPropertyIndexByType_ArrayIndex' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Conv_ByteToInt_ReturnValue) == 0x00030C, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Conv_ByteToInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Multiply_IntInt_ReturnValue) == 0x000310, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Multiply_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Conv_ByteToInt_ReturnValue_1) == 0x000314, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Conv_ByteToInt_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Multiply_IntInt_ReturnValue_1) == 0x000318, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Multiply_IntInt_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Add_IntInt_ReturnValue) == 0x00031C, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Add_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Conv_ByteToInt_ReturnValue_2) == 0x000320, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Conv_ByteToInt_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Conv_ByteToInt_ReturnValue_3) == 0x000324, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Conv_ByteToInt_ReturnValue_3' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Greater_ByteByte_ReturnValue) == 0x000328, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Greater_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Multiply_IntInt_ReturnValue_2) == 0x00032C, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Multiply_IntInt_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, CallFunc_Add_IntInt_ReturnValue_1) == 0x000330, "Member 'WEAPON_MagPulse_C_GetChargedMode::CallFunc_Add_IntInt_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetChargedMode, K2Node_MakeStruct_STRUCT_WeaponPropertyValue) == 0x000334, "Member 'WEAPON_MagPulse_C_GetChargedMode::K2Node_MakeStruct_STRUCT_WeaponPropertyValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.UpdateWeaponEmissiveStrength
// 0x0030 (0x0030 - 0x0000)
struct WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength final
{
public:
	bool                                          Charged;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          Temp_bool_Variable;                                // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Temp_float_Variable;                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         Temp_float_Variable_1;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         CallFunc_GetWeaponMeshComponent_Result;            // 0x0010(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         K2Node_Select_Default;                             // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_GetCustomPrimitiveDataFloat_ReturnValue;  // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_FloatFloat_ReturnValue;           // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallFunc_Conv_BoolToFloat_ReturnValue;             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Multiply_FloatFloat_ReturnValue;          // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength");
static_assert(sizeof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength) == 0x000030, "Wrong size on WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, Charged) == 0x000000, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::Charged' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, Temp_bool_Variable) == 0x000001, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::Temp_bool_Variable' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, Temp_float_Variable) == 0x000004, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::Temp_float_Variable' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, Temp_float_Variable_1) == 0x000008, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::Temp_float_Variable_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, CallFunc_GetWeaponMeshComponent_Result) == 0x000010, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::CallFunc_GetWeaponMeshComponent_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, CallFunc_IsValid_ReturnValue) == 0x000018, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, K2Node_Select_Default) == 0x00001C, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::K2Node_Select_Default' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, CallFunc_GetCustomPrimitiveDataFloat_ReturnValue) == 0x000020, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::CallFunc_GetCustomPrimitiveDataFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, CallFunc_Greater_FloatFloat_ReturnValue) == 0x000024, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::CallFunc_Greater_FloatFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, CallFunc_Conv_BoolToFloat_ReturnValue) == 0x000028, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::CallFunc_Conv_BoolToFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength, CallFunc_Multiply_FloatFloat_ReturnValue) == 0x00002C, "Member 'WEAPON_MagPulse_C_UpdateWeaponEmissiveStrength::CallFunc_Multiply_FloatFloat_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.TryCreateLoopingChargeEffect
// 0x0030 (0x0030 - 0x0000)
struct WEAPON_MagPulse_C_TryCreateLoopingChargeEffect final
{
public:
	class APAWN_SystemShockCharacter_C*           CallFunc_GetOwnerCharacter_Character;              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_Hacker_Implant_C*                 K2Node_DynamicCast_AsPAWN_Hacker_Implant;          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         CallFunc_GetWeaponMeshComponent_Result;            // 0x0018(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UNiagaraComponent*                      CallFunc_SpawnSystemAttached_ReturnValue;          // 0x0020(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue_1;                    // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Not_PreBool_ReturnValue;                  // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_TryCreateLoopingChargeEffect");
static_assert(sizeof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect) == 0x000030, "Wrong size on WEAPON_MagPulse_C_TryCreateLoopingChargeEffect");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect, CallFunc_GetOwnerCharacter_Character) == 0x000000, "Member 'WEAPON_MagPulse_C_TryCreateLoopingChargeEffect::CallFunc_GetOwnerCharacter_Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect, K2Node_DynamicCast_AsPAWN_Hacker_Implant) == 0x000008, "Member 'WEAPON_MagPulse_C_TryCreateLoopingChargeEffect::K2Node_DynamicCast_AsPAWN_Hacker_Implant' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect, K2Node_DynamicCast_bSuccess) == 0x000010, "Member 'WEAPON_MagPulse_C_TryCreateLoopingChargeEffect::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect, CallFunc_IsValid_ReturnValue) == 0x000011, "Member 'WEAPON_MagPulse_C_TryCreateLoopingChargeEffect::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect, CallFunc_GetWeaponMeshComponent_Result) == 0x000018, "Member 'WEAPON_MagPulse_C_TryCreateLoopingChargeEffect::CallFunc_GetWeaponMeshComponent_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect, CallFunc_SpawnSystemAttached_ReturnValue) == 0x000020, "Member 'WEAPON_MagPulse_C_TryCreateLoopingChargeEffect::CallFunc_SpawnSystemAttached_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect, CallFunc_IsValid_ReturnValue_1) == 0x000028, "Member 'WEAPON_MagPulse_C_TryCreateLoopingChargeEffect::CallFunc_IsValid_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateLoopingChargeEffect, CallFunc_Not_PreBool_ReturnValue) == 0x000029, "Member 'WEAPON_MagPulse_C_TryCreateLoopingChargeEffect::CallFunc_Not_PreBool_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.TryStopLoopingChargeEffect
// 0x0001 (0x0001 - 0x0000)
struct WEAPON_MagPulse_C_TryStopLoopingChargeEffect final
{
public:
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_TryStopLoopingChargeEffect) == 0x000001, "Wrong alignment on WEAPON_MagPulse_C_TryStopLoopingChargeEffect");
static_assert(sizeof(WEAPON_MagPulse_C_TryStopLoopingChargeEffect) == 0x000001, "Wrong size on WEAPON_MagPulse_C_TryStopLoopingChargeEffect");
static_assert(offsetof(WEAPON_MagPulse_C_TryStopLoopingChargeEffect, CallFunc_IsValid_ReturnValue) == 0x000000, "Member 'WEAPON_MagPulse_C_TryStopLoopingChargeEffect::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.TryCreateHandSparkEffect
// 0x0020 (0x0020 - 0x0000)
struct WEAPON_MagPulse_C_TryCreateHandSparkEffect final
{
public:
	class APAWN_SystemShockCharacter_C*           CallFunc_GetOwnerCharacter_Character;              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USkeletalMeshComponent*                 CallFunc_GetActionMeshComponent_SkeletalMeshComponent; // 0x0008(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UNiagaraComponent*                      CallFunc_SpawnSystemAttached_ReturnValue;          // 0x0010(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_TryCreateHandSparkEffect) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_TryCreateHandSparkEffect");
static_assert(sizeof(WEAPON_MagPulse_C_TryCreateHandSparkEffect) == 0x000020, "Wrong size on WEAPON_MagPulse_C_TryCreateHandSparkEffect");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateHandSparkEffect, CallFunc_GetOwnerCharacter_Character) == 0x000000, "Member 'WEAPON_MagPulse_C_TryCreateHandSparkEffect::CallFunc_GetOwnerCharacter_Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateHandSparkEffect, CallFunc_GetActionMeshComponent_SkeletalMeshComponent) == 0x000008, "Member 'WEAPON_MagPulse_C_TryCreateHandSparkEffect::CallFunc_GetActionMeshComponent_SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateHandSparkEffect, CallFunc_SpawnSystemAttached_ReturnValue) == 0x000010, "Member 'WEAPON_MagPulse_C_TryCreateHandSparkEffect::CallFunc_SpawnSystemAttached_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryCreateHandSparkEffect, CallFunc_IsValid_ReturnValue) == 0x000018, "Member 'WEAPON_MagPulse_C_TryCreateHandSparkEffect::CallFunc_IsValid_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.CycleCurrentMode
// 0x0002 (0x0002 - 0x0000)
struct WEAPON_MagPulse_C_CycleCurrentMode final
{
public:
	bool                                          Previous;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          Result;                                            // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_CycleCurrentMode) == 0x000001, "Wrong alignment on WEAPON_MagPulse_C_CycleCurrentMode");
static_assert(sizeof(WEAPON_MagPulse_C_CycleCurrentMode) == 0x000002, "Wrong size on WEAPON_MagPulse_C_CycleCurrentMode");
static_assert(offsetof(WEAPON_MagPulse_C_CycleCurrentMode, Previous) == 0x000000, "Member 'WEAPON_MagPulse_C_CycleCurrentMode::Previous' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CycleCurrentMode, Result) == 0x000001, "Member 'WEAPON_MagPulse_C_CycleCurrentMode::Result' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.CanRefillMagazine
// 0x0118 (0x0118 - 0x0000)
struct WEAPON_MagPulse_C_CanRefillMagazine final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_GetAmmoInMagazineAndChamber_Ammo;         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_HasSpareAmmo_Result;                      // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSTRUCT_WeaponMode                     CallFunc_GetCurrentMode_Mode;                      // 0x0010(0x0100)(HasGetValueTypeHash)
	int32                                         CallFunc_GetWeaponPropertyValueByType_Value;       // 0x0110(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Less_IntInt_ReturnValue;                  // 0x0114(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_CanRefillMagazine) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_CanRefillMagazine");
static_assert(sizeof(WEAPON_MagPulse_C_CanRefillMagazine) == 0x000118, "Wrong size on WEAPON_MagPulse_C_CanRefillMagazine");
static_assert(offsetof(WEAPON_MagPulse_C_CanRefillMagazine, Result) == 0x000000, "Member 'WEAPON_MagPulse_C_CanRefillMagazine::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanRefillMagazine, CallFunc_GetAmmoInMagazineAndChamber_Ammo) == 0x000004, "Member 'WEAPON_MagPulse_C_CanRefillMagazine::CallFunc_GetAmmoInMagazineAndChamber_Ammo' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanRefillMagazine, CallFunc_HasSpareAmmo_Result) == 0x000008, "Member 'WEAPON_MagPulse_C_CanRefillMagazine::CallFunc_HasSpareAmmo_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanRefillMagazine, CallFunc_GetCurrentMode_Mode) == 0x000010, "Member 'WEAPON_MagPulse_C_CanRefillMagazine::CallFunc_GetCurrentMode_Mode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanRefillMagazine, CallFunc_GetWeaponPropertyValueByType_Value) == 0x000110, "Member 'WEAPON_MagPulse_C_CanRefillMagazine::CallFunc_GetWeaponPropertyValueByType_Value' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanRefillMagazine, CallFunc_Less_IntInt_ReturnValue) == 0x000114, "Member 'WEAPON_MagPulse_C_CanRefillMagazine::CallFunc_Less_IntInt_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.QueueReloading
// 0x0020 (0x0020 - 0x0000)
struct WEAPON_MagPulse_C_QueueReloading final
{
public:
	bool                                          Temp_bool_Variable;                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APAWN_SystemShockCharacter_C*           CallFunc_GetOwnerCharacter_Character;              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_ByteByte_ReturnValue;             // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           K2Node_Select_Default;                             // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_QueueReloading) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_QueueReloading");
static_assert(sizeof(WEAPON_MagPulse_C_QueueReloading) == 0x000020, "Wrong size on WEAPON_MagPulse_C_QueueReloading");
static_assert(offsetof(WEAPON_MagPulse_C_QueueReloading, Temp_bool_Variable) == 0x000000, "Member 'WEAPON_MagPulse_C_QueueReloading::Temp_bool_Variable' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_QueueReloading, CallFunc_GetOwnerCharacter_Character) == 0x000008, "Member 'WEAPON_MagPulse_C_QueueReloading::CallFunc_GetOwnerCharacter_Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_QueueReloading, CallFunc_Greater_ByteByte_ReturnValue) == 0x000010, "Member 'WEAPON_MagPulse_C_QueueReloading::CallFunc_Greater_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_QueueReloading, K2Node_Select_Default) == 0x000018, "Member 'WEAPON_MagPulse_C_QueueReloading::K2Node_Select_Default' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.GetAmmoInChamber
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_GetAmmoInChamber final
{
public:
	int32                                         Ammo;                                              // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue;               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_GetAmmoInChamber) == 0x000004, "Wrong alignment on WEAPON_MagPulse_C_GetAmmoInChamber");
static_assert(sizeof(WEAPON_MagPulse_C_GetAmmoInChamber) == 0x000008, "Wrong size on WEAPON_MagPulse_C_GetAmmoInChamber");
static_assert(offsetof(WEAPON_MagPulse_C_GetAmmoInChamber, Ammo) == 0x000000, "Member 'WEAPON_MagPulse_C_GetAmmoInChamber::Ammo' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetAmmoInChamber, CallFunc_Conv_ByteToInt_ReturnValue) == 0x000004, "Member 'WEAPON_MagPulse_C_GetAmmoInChamber::CallFunc_Conv_ByteToInt_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.GetWeaponMode
// 0x0308 (0x0308 - 0x0000)
struct WEAPON_MagPulse_C_GetWeaponMode final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSTRUCT_WeaponMode                     Mode;                                              // 0x0008(0x0100)(Parm, OutParm, HasGetValueTypeHash)
	struct FSTRUCT_WeaponMode                     CallFunc_GetWeaponMode_Mode;                       // 0x0108(0x0100)(HasGetValueTypeHash)
	struct FSTRUCT_WeaponMode                     CallFunc_GetChargedMode_Result;                    // 0x0208(0x0100)(HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_GetWeaponMode) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_GetWeaponMode");
static_assert(sizeof(WEAPON_MagPulse_C_GetWeaponMode) == 0x000308, "Wrong size on WEAPON_MagPulse_C_GetWeaponMode");
static_assert(offsetof(WEAPON_MagPulse_C_GetWeaponMode, Index_0) == 0x000000, "Member 'WEAPON_MagPulse_C_GetWeaponMode::Index_0' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetWeaponMode, Mode) == 0x000008, "Member 'WEAPON_MagPulse_C_GetWeaponMode::Mode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetWeaponMode, CallFunc_GetWeaponMode_Mode) == 0x000108, "Member 'WEAPON_MagPulse_C_GetWeaponMode::CallFunc_GetWeaponMode_Mode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetWeaponMode, CallFunc_GetChargedMode_Result) == 0x000208, "Member 'WEAPON_MagPulse_C_GetWeaponMode::CallFunc_GetChargedMode_Result' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.CanEmptyAmmoInMagazineOrChamber
// 0x000C (0x000C - 0x0000)
struct WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_GetAmmoInMagazine_Ammo;                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_HasAmmoInMagazineOrChamber_Result;        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Greater_IntInt_ReturnValue;               // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_EqualEqual_ByteByte_ReturnValue;          // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber) == 0x000004, "Wrong alignment on WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber");
static_assert(sizeof(WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber) == 0x00000C, "Wrong size on WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber");
static_assert(offsetof(WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber, Result) == 0x000000, "Member 'WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber, CallFunc_GetAmmoInMagazine_Ammo) == 0x000004, "Member 'WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber::CallFunc_GetAmmoInMagazine_Ammo' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber, CallFunc_HasAmmoInMagazineOrChamber_Result) == 0x000008, "Member 'WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber::CallFunc_HasAmmoInMagazineOrChamber_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber, CallFunc_Greater_IntInt_ReturnValue) == 0x000009, "Member 'WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber::CallFunc_Greater_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber, CallFunc_EqualEqual_ByteByte_ReturnValue) == 0x00000A, "Member 'WEAPON_MagPulse_C_CanEmptyAmmoInMagazineOrChamber::CallFunc_EqualEqual_ByteByte_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.ReceiveAnimationMessage
// 0x0018 (0x0018 - 0x0000)
struct WEAPON_MagPulse_C_ReceiveAnimationMessage final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_ReceiveAnimationMessage_Result;           // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_EqualEqual_StrStr_ReturnValue;            // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_ReceiveAnimationMessage) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_ReceiveAnimationMessage");
static_assert(sizeof(WEAPON_MagPulse_C_ReceiveAnimationMessage) == 0x000018, "Wrong size on WEAPON_MagPulse_C_ReceiveAnimationMessage");
static_assert(offsetof(WEAPON_MagPulse_C_ReceiveAnimationMessage, Message) == 0x000000, "Member 'WEAPON_MagPulse_C_ReceiveAnimationMessage::Message' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ReceiveAnimationMessage, Result) == 0x000010, "Member 'WEAPON_MagPulse_C_ReceiveAnimationMessage::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ReceiveAnimationMessage, CallFunc_ReceiveAnimationMessage_Result) == 0x000011, "Member 'WEAPON_MagPulse_C_ReceiveAnimationMessage::CallFunc_ReceiveAnimationMessage_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ReceiveAnimationMessage, CallFunc_EqualEqual_StrStr_ReturnValue) == 0x000012, "Member 'WEAPON_MagPulse_C_ReceiveAnimationMessage::CallFunc_EqualEqual_StrStr_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.UpdateMaterial
// 0x0060 (0x0060 - 0x0000)
struct WEAPON_MagPulse_C_UpdateMaterial final
{
public:
	bool                                          Glitch;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         CallFunc_GetWeaponMeshComponent_Result;            // 0x0008(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_ByteToFloat_ReturnValue;             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         CallFunc_GetWeaponMeshComponent_Result_1;          // 0x0018(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMeshComponent*                         CallFunc_GetWeaponMeshComponent_Result_2;          // 0x0020(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMeshComponent*                         CallFunc_GetWeaponMeshComponent_Result_3;          // 0x0028(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMeshComponent*                         CallFunc_GetWeaponMeshComponent_Result_4;          // 0x0030(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMeshComponent*                         CallFunc_GetWeaponMeshComponent_Result_5;          // 0x0038(0x0008)(ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_GetAmmoInMagazineAndChamber_Ammo;         // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_IsValid_ReturnValue;                      // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_LessEqual_IntInt_ReturnValue;             // 0x0045(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallFunc_Conv_BoolToFloat_ReturnValue;             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_GetAmmoInMagazineAndChamber_Ammo_1;       // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue;              // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_GetTimeSeconds_ReturnValue;               // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue_1;            // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_UpdateMaterial) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_UpdateMaterial");
static_assert(sizeof(WEAPON_MagPulse_C_UpdateMaterial) == 0x000060, "Wrong size on WEAPON_MagPulse_C_UpdateMaterial");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, Glitch) == 0x000000, "Member 'WEAPON_MagPulse_C_UpdateMaterial::Glitch' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetWeaponMeshComponent_Result) == 0x000008, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetWeaponMeshComponent_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_Conv_ByteToFloat_ReturnValue) == 0x000010, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_Conv_ByteToFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetWeaponMeshComponent_Result_1) == 0x000018, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetWeaponMeshComponent_Result_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetWeaponMeshComponent_Result_2) == 0x000020, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetWeaponMeshComponent_Result_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetWeaponMeshComponent_Result_3) == 0x000028, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetWeaponMeshComponent_Result_3' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetWeaponMeshComponent_Result_4) == 0x000030, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetWeaponMeshComponent_Result_4' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetWeaponMeshComponent_Result_5) == 0x000038, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetWeaponMeshComponent_Result_5' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetAmmoInMagazineAndChamber_Ammo) == 0x000040, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetAmmoInMagazineAndChamber_Ammo' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_IsValid_ReturnValue) == 0x000044, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_IsValid_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_LessEqual_IntInt_ReturnValue) == 0x000045, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_LessEqual_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_Conv_BoolToFloat_ReturnValue) == 0x000048, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_Conv_BoolToFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetAmmoInMagazineAndChamber_Ammo_1) == 0x00004C, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetAmmoInMagazineAndChamber_Ammo_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_Conv_IntToFloat_ReturnValue) == 0x000050, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_Conv_IntToFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_GetTimeSeconds_ReturnValue) == 0x000054, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_GetTimeSeconds_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_UpdateMaterial, CallFunc_Conv_IntToFloat_ReturnValue_1) == 0x000058, "Member 'WEAPON_MagPulse_C_UpdateMaterial::CallFunc_Conv_IntToFloat_ReturnValue_1' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.FireProjectile
// 0x0030 (0x0030 - 0x0000)
struct WEAPON_MagPulse_C_FireProjectile final
{
public:
	class AActor*                                 FiredProjectile;                                   // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                Direction;                                         // 0x0008(0x000C)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 CallFunc_FireProjectile_FiredProjectile;           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_FireProjectile_Direction;                 // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         CallFunc_BMin_ReturnValue;                         // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_FireProjectile) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_FireProjectile");
static_assert(sizeof(WEAPON_MagPulse_C_FireProjectile) == 0x000030, "Wrong size on WEAPON_MagPulse_C_FireProjectile");
static_assert(offsetof(WEAPON_MagPulse_C_FireProjectile, FiredProjectile) == 0x000000, "Member 'WEAPON_MagPulse_C_FireProjectile::FiredProjectile' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_FireProjectile, Direction) == 0x000008, "Member 'WEAPON_MagPulse_C_FireProjectile::Direction' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_FireProjectile, CallFunc_FireProjectile_FiredProjectile) == 0x000018, "Member 'WEAPON_MagPulse_C_FireProjectile::CallFunc_FireProjectile_FiredProjectile' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_FireProjectile, CallFunc_FireProjectile_Direction) == 0x000020, "Member 'WEAPON_MagPulse_C_FireProjectile::CallFunc_FireProjectile_Direction' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_FireProjectile, CallFunc_BMin_ReturnValue) == 0x00002C, "Member 'WEAPON_MagPulse_C_FireProjectile::CallFunc_BMin_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.GetDischargeMontage
// 0x0018 (0x0018 - 0x0000)
struct WEAPON_MagPulse_C_GetDischargeMontage final
{
public:
	class UAnimMontage*                           DischargeAnimation;                                // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_GetAmmoInMagazineAndChamber_Ammo;         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue;               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_IntInt_ReturnValue;               // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_GetDischargeMontage) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_GetDischargeMontage");
static_assert(sizeof(WEAPON_MagPulse_C_GetDischargeMontage) == 0x000018, "Wrong size on WEAPON_MagPulse_C_GetDischargeMontage");
static_assert(offsetof(WEAPON_MagPulse_C_GetDischargeMontage, DischargeAnimation) == 0x000000, "Member 'WEAPON_MagPulse_C_GetDischargeMontage::DischargeAnimation' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetDischargeMontage, CallFunc_GetAmmoInMagazineAndChamber_Ammo) == 0x000008, "Member 'WEAPON_MagPulse_C_GetDischargeMontage::CallFunc_GetAmmoInMagazineAndChamber_Ammo' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetDischargeMontage, CallFunc_Conv_ByteToInt_ReturnValue) == 0x00000C, "Member 'WEAPON_MagPulse_C_GetDischargeMontage::CallFunc_Conv_ByteToInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_GetDischargeMontage, CallFunc_Greater_IntInt_ReturnValue) == 0x000010, "Member 'WEAPON_MagPulse_C_GetDischargeMontage::CallFunc_Greater_IntInt_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.GetProjectileClass
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_GetProjectileClass final
{
public:
	class UClass*                                 Result;                                            // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_GetProjectileClass) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_GetProjectileClass");
static_assert(sizeof(WEAPON_MagPulse_C_GetProjectileClass) == 0x000008, "Wrong size on WEAPON_MagPulse_C_GetProjectileClass");
static_assert(offsetof(WEAPON_MagPulse_C_GetProjectileClass, Result) == 0x000000, "Member 'WEAPON_MagPulse_C_GetProjectileClass::Result' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.InitializeProjectileDamageSettings
// 0x0670 (0x0670 - 0x0000)
struct WEAPON_MagPulse_C_InitializeProjectileDamageSettings final
{
public:
	class ABulletProjectile_Base_C*               BulletProjectileActor;                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         EnergyRatio;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         EnergyToDrain;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         EnergyInReserves;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         EnergyCost;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         DefaultElectricDamage;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         ElectricDamage;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         DefaultMagneticDamage;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         MagneticDamage;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_SystemShockCharacter_C*           CharacterOwner;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FAttribModApplyData                    EnergyDrainApplyData;                              // 0x0030(0x00A0)(Edit, BlueprintVisible)
	struct FSTRUCT_WeaponMode                     DefaultChargedMode;                                // 0x00D0(0x0100)(Edit, BlueprintVisible, HasGetValueTypeHash)
	struct FSTRUCT_WeaponMode                     CurrentMode;                                       // 0x01D0(0x0100)(Edit, BlueprintVisible, HasGetValueTypeHash)
	int32                                         CallFunc_GetWeaponPropertyValueByType_Value;       // 0x02D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue;              // 0x02D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue_1;            // 0x02D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Lerp_ReturnValue;                         // 0x02DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FSTRUCT_WeaponMode                     CallFunc_GetWeaponModeDefaults_Mode;               // 0x02E0(0x0100)(HasGetValueTypeHash)
	int32                                         CallFunc_FTrunc_ReturnValue;                       // 0x03E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSTRUCT_WeaponMode                     CallFunc_GetChargedMode_Result;                    // 0x03E8(0x0100)(HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue_2;            // 0x04E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue_3;            // 0x04EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Lerp_ReturnValue_1;                       // 0x04F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue;               // 0x04F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_FTrunc_ReturnValue_1;                     // 0x04F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Multiply_IntInt_ReturnValue;              // 0x04FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_IntInt_ReturnValue;               // 0x0500(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallFunc_Conv_IntToFloat_ReturnValue_4;            // 0x0504(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Conv_IntToFloat_ReturnValue_5;            // 0x0508(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_Divide_FloatFloat_ReturnValue;            // 0x050C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_IntInt_ReturnValue_1;             // 0x0510(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_511[0x3];                                      // 0x0511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallFunc_Conv_IntToFloat_ReturnValue_6;            // 0x0514(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAttribMod*                             CallFunc_ApplyMod_ReturnValue;                     // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Less_IntInt_ReturnValue;                  // 0x0520(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_521[0x3];                                      // 0x0521(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CallFunc_GetAttribValue_ReturnValue;               // 0x0524(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_FTrunc_ReturnValue_2;                     // 0x0528(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_Min_ReturnValue;                          // 0x052C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APAWN_SystemShockCharacter_C*           CallFunc_GetOwnerCharacter_Character;              // 0x0530(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CallFunc_GetWeaponPropertyValueByType_Value_1;     // 0x0538(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttribModApplyData>            K2Node_MakeArray_Array;                            // 0x0540(0x0010)(ReferenceParm)
	int32                                         CallFunc_GetWeaponPropertyValueByType_Value_2;     // 0x0550(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABulletProjectile_MagPulse_C*           K2Node_DynamicCast_AsBullet_Projectile_Mag_Pulse;  // 0x0558(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_DynamicCast_bSuccess;                       // 0x0560(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_561[0x3];                                      // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue_1;             // 0x0564(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FSTRUCT_WeaponMode                     CallFunc_GetCurrentMode_Mode;                      // 0x0568(0x0100)(HasGetValueTypeHash)
	int32                                         CallFunc_Multiply_IntInt_ReturnValue_1;            // 0x0668(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_InitializeProjectileDamageSettings");
static_assert(sizeof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings) == 0x000670, "Wrong size on WEAPON_MagPulse_C_InitializeProjectileDamageSettings");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, BulletProjectileActor) == 0x000000, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::BulletProjectileActor' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, EnergyRatio) == 0x000008, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::EnergyRatio' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, EnergyToDrain) == 0x00000C, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::EnergyToDrain' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, EnergyInReserves) == 0x000010, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::EnergyInReserves' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, EnergyCost) == 0x000014, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::EnergyCost' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, DefaultElectricDamage) == 0x000018, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::DefaultElectricDamage' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, ElectricDamage) == 0x00001C, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::ElectricDamage' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, DefaultMagneticDamage) == 0x000020, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::DefaultMagneticDamage' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, MagneticDamage) == 0x000024, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::MagneticDamage' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CharacterOwner) == 0x000028, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CharacterOwner' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, EnergyDrainApplyData) == 0x000030, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::EnergyDrainApplyData' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, DefaultChargedMode) == 0x0000D0, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::DefaultChargedMode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CurrentMode) == 0x0001D0, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CurrentMode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_GetWeaponPropertyValueByType_Value) == 0x0002D0, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_GetWeaponPropertyValueByType_Value' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_IntToFloat_ReturnValue) == 0x0002D4, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_IntToFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_IntToFloat_ReturnValue_1) == 0x0002D8, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_IntToFloat_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Lerp_ReturnValue) == 0x0002DC, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Lerp_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_GetWeaponModeDefaults_Mode) == 0x0002E0, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_GetWeaponModeDefaults_Mode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_FTrunc_ReturnValue) == 0x0003E0, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_FTrunc_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_GetChargedMode_Result) == 0x0003E8, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_GetChargedMode_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_IntToFloat_ReturnValue_2) == 0x0004E8, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_IntToFloat_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_IntToFloat_ReturnValue_3) == 0x0004EC, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_IntToFloat_ReturnValue_3' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Lerp_ReturnValue_1) == 0x0004F0, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Lerp_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_ByteToInt_ReturnValue) == 0x0004F4, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_ByteToInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_FTrunc_ReturnValue_1) == 0x0004F8, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_FTrunc_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Multiply_IntInt_ReturnValue) == 0x0004FC, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Multiply_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Greater_IntInt_ReturnValue) == 0x000500, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Greater_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_IntToFloat_ReturnValue_4) == 0x000504, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_IntToFloat_ReturnValue_4' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_IntToFloat_ReturnValue_5) == 0x000508, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_IntToFloat_ReturnValue_5' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Divide_FloatFloat_ReturnValue) == 0x00050C, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Divide_FloatFloat_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Greater_IntInt_ReturnValue_1) == 0x000510, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Greater_IntInt_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_IntToFloat_ReturnValue_6) == 0x000514, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_IntToFloat_ReturnValue_6' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_ApplyMod_ReturnValue) == 0x000518, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_ApplyMod_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Less_IntInt_ReturnValue) == 0x000520, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Less_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_GetAttribValue_ReturnValue) == 0x000524, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_GetAttribValue_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_FTrunc_ReturnValue_2) == 0x000528, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_FTrunc_ReturnValue_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Min_ReturnValue) == 0x00052C, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Min_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_GetOwnerCharacter_Character) == 0x000530, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_GetOwnerCharacter_Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_GetWeaponPropertyValueByType_Value_1) == 0x000538, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_GetWeaponPropertyValueByType_Value_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, K2Node_MakeArray_Array) == 0x000540, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::K2Node_MakeArray_Array' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_GetWeaponPropertyValueByType_Value_2) == 0x000550, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_GetWeaponPropertyValueByType_Value_2' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, K2Node_DynamicCast_AsBullet_Projectile_Mag_Pulse) == 0x000558, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::K2Node_DynamicCast_AsBullet_Projectile_Mag_Pulse' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, K2Node_DynamicCast_bSuccess) == 0x000560, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::K2Node_DynamicCast_bSuccess' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Conv_ByteToInt_ReturnValue_1) == 0x000564, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Conv_ByteToInt_ReturnValue_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_GetCurrentMode_Mode) == 0x000568, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_GetCurrentMode_Mode' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_InitializeProjectileDamageSettings, CallFunc_Multiply_IntInt_ReturnValue_1) == 0x000668, "Member 'WEAPON_MagPulse_C_InitializeProjectileDamageSettings::CallFunc_Multiply_IntInt_ReturnValue_1' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.MoveAmmoFromChamberToMagazine
// 0x0008 (0x0008 - 0x0000)
struct WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine final
{
public:
	int32                                         CallFunc_Conv_ByteToInt_ReturnValue;               // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_EqualEqual_ByteByte_ReturnValue;          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine) == 0x000004, "Wrong alignment on WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine");
static_assert(sizeof(WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine) == 0x000008, "Wrong size on WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine");
static_assert(offsetof(WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine, CallFunc_Conv_ByteToInt_ReturnValue) == 0x000000, "Member 'WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine::CallFunc_Conv_ByteToInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine, CallFunc_EqualEqual_ByteByte_ReturnValue) == 0x000004, "Member 'WEAPON_MagPulse_C_MoveAmmoFromChamberToMagazine::CallFunc_EqualEqual_ByteByte_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.OnWeaponBecameActivatable
// 0x0010 (0x0010 - 0x0000)
struct WEAPON_MagPulse_C_OnWeaponBecameActivatable final
{
public:
	class APAWN_SystemShockCharacter_C*           Character;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ShowImmediately;                                   // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_EqualEqual_ByteByte_ReturnValue;          // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_OnWeaponBecameActivatable) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_OnWeaponBecameActivatable");
static_assert(sizeof(WEAPON_MagPulse_C_OnWeaponBecameActivatable) == 0x000010, "Wrong size on WEAPON_MagPulse_C_OnWeaponBecameActivatable");
static_assert(offsetof(WEAPON_MagPulse_C_OnWeaponBecameActivatable, Character) == 0x000000, "Member 'WEAPON_MagPulse_C_OnWeaponBecameActivatable::Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_OnWeaponBecameActivatable, ShowImmediately) == 0x000008, "Member 'WEAPON_MagPulse_C_OnWeaponBecameActivatable::ShowImmediately' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_OnWeaponBecameActivatable, CallFunc_EqualEqual_ByteByte_ReturnValue) == 0x000009, "Member 'WEAPON_MagPulse_C_OnWeaponBecameActivatable::CallFunc_EqualEqual_ByteByte_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.ApplyAccuracyChangeAndRecoil
// 0x001C (0x001C - 0x0000)
struct WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil final
{
public:
	bool                                          HasKickback_0;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilScale;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Temp_bool_Variable;                                // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Temp_float_Variable;                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         Temp_float_Variable_1;                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_ByteByte_ReturnValue;             // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         K2Node_Select_Default;                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil) == 0x000004, "Wrong alignment on WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil");
static_assert(sizeof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil) == 0x00001C, "Wrong size on WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil, HasKickback_0) == 0x000000, "Member 'WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil::HasKickback_0' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil, RecoilScale) == 0x000004, "Member 'WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil::RecoilScale' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil, Temp_bool_Variable) == 0x000008, "Member 'WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil::Temp_bool_Variable' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil, Temp_float_Variable) == 0x00000C, "Member 'WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil::Temp_float_Variable' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil, Temp_float_Variable_1) == 0x000010, "Member 'WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil::Temp_float_Variable_1' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil, CallFunc_Greater_ByteByte_ReturnValue) == 0x000014, "Member 'WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil::CallFunc_Greater_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil, K2Node_Select_Default) == 0x000018, "Member 'WEAPON_MagPulse_C_ApplyAccuracyChangeAndRecoil::K2Node_Select_Default' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.PlayDischargeForceFeedback
// 0x0010 (0x0010 - 0x0000)
struct WEAPON_MagPulse_C_PlayDischargeForceFeedback final
{
public:
	bool                                          Temp_bool_Variable;                                // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Greater_ByteByte_ReturnValue;             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Less_ByteByte_ReturnValue;                // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   K2Node_Select_Default;                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(WEAPON_MagPulse_C_PlayDischargeForceFeedback) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_PlayDischargeForceFeedback");
static_assert(sizeof(WEAPON_MagPulse_C_PlayDischargeForceFeedback) == 0x000010, "Wrong size on WEAPON_MagPulse_C_PlayDischargeForceFeedback");
static_assert(offsetof(WEAPON_MagPulse_C_PlayDischargeForceFeedback, Temp_bool_Variable) == 0x000000, "Member 'WEAPON_MagPulse_C_PlayDischargeForceFeedback::Temp_bool_Variable' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_PlayDischargeForceFeedback, CallFunc_Greater_ByteByte_ReturnValue) == 0x000001, "Member 'WEAPON_MagPulse_C_PlayDischargeForceFeedback::CallFunc_Greater_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_PlayDischargeForceFeedback, CallFunc_Less_ByteByte_ReturnValue) == 0x000002, "Member 'WEAPON_MagPulse_C_PlayDischargeForceFeedback::CallFunc_Less_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_PlayDischargeForceFeedback, K2Node_Select_Default) == 0x000008, "Member 'WEAPON_MagPulse_C_PlayDischargeForceFeedback::K2Node_Select_Default' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.TryBeginReloading
// 0x0004 (0x0004 - 0x0000)
struct WEAPON_MagPulse_C_TryBeginReloading final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_IsEquipped_Result;                        // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_EqualEqual_ByteByte_ReturnValue;          // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_TryBeginReloading_Result;                 // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_TryBeginReloading) == 0x000001, "Wrong alignment on WEAPON_MagPulse_C_TryBeginReloading");
static_assert(sizeof(WEAPON_MagPulse_C_TryBeginReloading) == 0x000004, "Wrong size on WEAPON_MagPulse_C_TryBeginReloading");
static_assert(offsetof(WEAPON_MagPulse_C_TryBeginReloading, Result) == 0x000000, "Member 'WEAPON_MagPulse_C_TryBeginReloading::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryBeginReloading, CallFunc_IsEquipped_Result) == 0x000001, "Member 'WEAPON_MagPulse_C_TryBeginReloading::CallFunc_IsEquipped_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryBeginReloading, CallFunc_EqualEqual_ByteByte_ReturnValue) == 0x000002, "Member 'WEAPON_MagPulse_C_TryBeginReloading::CallFunc_EqualEqual_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_TryBeginReloading, CallFunc_TryBeginReloading_Result) == 0x000003, "Member 'WEAPON_MagPulse_C_TryBeginReloading::CallFunc_TryBeginReloading_Result' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.OnBecomeActivatable
// 0x000C (0x000C - 0x0000)
struct WEAPON_MagPulse_C_OnBecomeActivatable final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CallFunc_GetAmmoInMagazine_Ammo;                   // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_Greater_IntInt_ReturnValue;               // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_OnBecomeActivatable_Result;               // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_EqualEqual_ByteByte_ReturnValue;          // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_BooleanAND_ReturnValue;                   // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_OnBecomeActivatable) == 0x000004, "Wrong alignment on WEAPON_MagPulse_C_OnBecomeActivatable");
static_assert(sizeof(WEAPON_MagPulse_C_OnBecomeActivatable) == 0x00000C, "Wrong size on WEAPON_MagPulse_C_OnBecomeActivatable");
static_assert(offsetof(WEAPON_MagPulse_C_OnBecomeActivatable, Result) == 0x000000, "Member 'WEAPON_MagPulse_C_OnBecomeActivatable::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_OnBecomeActivatable, CallFunc_GetAmmoInMagazine_Ammo) == 0x000004, "Member 'WEAPON_MagPulse_C_OnBecomeActivatable::CallFunc_GetAmmoInMagazine_Ammo' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_OnBecomeActivatable, CallFunc_Greater_IntInt_ReturnValue) == 0x000008, "Member 'WEAPON_MagPulse_C_OnBecomeActivatable::CallFunc_Greater_IntInt_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_OnBecomeActivatable, CallFunc_OnBecomeActivatable_Result) == 0x000009, "Member 'WEAPON_MagPulse_C_OnBecomeActivatable::CallFunc_OnBecomeActivatable_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_OnBecomeActivatable, CallFunc_EqualEqual_ByteByte_ReturnValue) == 0x00000A, "Member 'WEAPON_MagPulse_C_OnBecomeActivatable::CallFunc_EqualEqual_ByteByte_ReturnValue' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_OnBecomeActivatable, CallFunc_BooleanAND_ReturnValue) == 0x00000B, "Member 'WEAPON_MagPulse_C_OnBecomeActivatable::CallFunc_BooleanAND_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.OnBecomeUnactivatable
// 0x0002 (0x0002 - 0x0000)
struct WEAPON_MagPulse_C_OnBecomeUnactivatable final
{
public:
	bool                                          Result;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_OnBecomeUnactivatable_Result;             // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_OnBecomeUnactivatable) == 0x000001, "Wrong alignment on WEAPON_MagPulse_C_OnBecomeUnactivatable");
static_assert(sizeof(WEAPON_MagPulse_C_OnBecomeUnactivatable) == 0x000002, "Wrong size on WEAPON_MagPulse_C_OnBecomeUnactivatable");
static_assert(offsetof(WEAPON_MagPulse_C_OnBecomeUnactivatable, Result) == 0x000000, "Member 'WEAPON_MagPulse_C_OnBecomeUnactivatable::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_OnBecomeUnactivatable, CallFunc_OnBecomeUnactivatable_Result) == 0x000001, "Member 'WEAPON_MagPulse_C_OnBecomeUnactivatable::CallFunc_OnBecomeUnactivatable_Result' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.CanActivate
// 0x0010 (0x0010 - 0x0000)
struct WEAPON_MagPulse_C_CanActivate final
{
public:
	class APAWN_SystemShockCharacter_C*           Character;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_CanActivate_Result;                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Greater_ByteByte_ReturnValue;             // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_CanActivate) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_CanActivate");
static_assert(sizeof(WEAPON_MagPulse_C_CanActivate) == 0x000010, "Wrong size on WEAPON_MagPulse_C_CanActivate");
static_assert(offsetof(WEAPON_MagPulse_C_CanActivate, Character) == 0x000000, "Member 'WEAPON_MagPulse_C_CanActivate::Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanActivate, Result) == 0x000008, "Member 'WEAPON_MagPulse_C_CanActivate::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanActivate, CallFunc_CanActivate_Result) == 0x000009, "Member 'WEAPON_MagPulse_C_CanActivate::CallFunc_CanActivate_Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_CanActivate, CallFunc_Greater_ByteByte_ReturnValue) == 0x00000A, "Member 'WEAPON_MagPulse_C_CanActivate::CallFunc_Greater_ByteByte_ReturnValue' has a wrong offset!");

// Function WEAPON_MagPulse.WEAPON_MagPulse_C.Activate
// 0x0010 (0x0010 - 0x0000)
struct WEAPON_MagPulse_C_Activate final
{
public:
	class APAWN_SystemShockCharacter_C*           Character;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Result;                                            // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          CallFunc_Activate_Result;                          // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor)
};
static_assert(alignof(WEAPON_MagPulse_C_Activate) == 0x000008, "Wrong alignment on WEAPON_MagPulse_C_Activate");
static_assert(sizeof(WEAPON_MagPulse_C_Activate) == 0x000010, "Wrong size on WEAPON_MagPulse_C_Activate");
static_assert(offsetof(WEAPON_MagPulse_C_Activate, Character) == 0x000000, "Member 'WEAPON_MagPulse_C_Activate::Character' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_Activate, Result) == 0x000008, "Member 'WEAPON_MagPulse_C_Activate::Result' has a wrong offset!");
static_assert(offsetof(WEAPON_MagPulse_C_Activate, CallFunc_Activate_Result) == 0x000009, "Member 'WEAPON_MagPulse_C_Activate::CallFunc_Activate_Result' has a wrong offset!");

}

