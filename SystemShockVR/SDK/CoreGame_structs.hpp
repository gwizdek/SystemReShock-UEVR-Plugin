#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreGame

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum CoreGame.EHeartBeatEvent
// NumValues: 0x0004
enum class EHeartBeatEvent : uint8
{
	None                                     = 0,
	Systole                                  = 1,
	Diastole                                 = 2,
	EHeartBeatEvent_MAX                      = 3,
};

// Enum CoreGame.EGridWallFlags
// NumValues: 0x0004
enum class EGridWallFlags : uint8
{
	None                                     = 0,
	Blocked                                  = 1,
	Breakable                                = 2,
	EGridWallFlags_MAX                       = 3,
};

// Enum CoreGame.EGridWallState
// NumValues: 0x0003
enum class EGridWallState : uint8
{
	Blocked                                  = 0,
	Breakable                                = 1,
	EGridWallState_MAX                       = 2,
};

// Enum CoreGame.EPolyhedronFaceType
// NumValues: 0x0003
enum class EPolyhedronFaceType : uint8
{
	Shared                                   = 0,
	Unshared                                 = 1,
	EPolyhedronFaceType_MAX                  = 2,
};

// Enum CoreGame.EWeightedFuncType
// NumValues: 0x0003
enum class EWeightedFuncType : uint8
{
	Linear                                   = 0,
	Smooth                                   = 1,
	EWeightedFuncType_MAX                    = 2,
};

// ScriptStruct CoreGame.ObjectClassCollection
// 0x0010 (0x0010 - 0x0000)
struct FObjectClassCollection final
{
public:
	TArray<TSoftClassPtr<class UClass>>           ObjectClasses;                                     // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectClassCollection) == 0x000008, "Wrong alignment on FObjectClassCollection");
static_assert(sizeof(FObjectClassCollection) == 0x000010, "Wrong size on FObjectClassCollection");
static_assert(offsetof(FObjectClassCollection, ObjectClasses) == 0x000000, "Member 'FObjectClassCollection::ObjectClasses' has a wrong offset!");

// ScriptStruct CoreGame.LatentObjectEventHandle
// 0x0010 (0x0010 - 0x0000)
struct FLatentObjectEventHandle final
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0000(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLatentObjectEventHandle) == 0x000008, "Wrong alignment on FLatentObjectEventHandle");
static_assert(sizeof(FLatentObjectEventHandle) == 0x000010, "Wrong size on FLatentObjectEventHandle");
static_assert(offsetof(FLatentObjectEventHandle, Event) == 0x000000, "Member 'FLatentObjectEventHandle::Event' has a wrong offset!");

// ScriptStruct CoreGame.LatentEventHandle
// 0x0010 (0x0010 - 0x0000)
struct FLatentEventHandle final
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0000(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLatentEventHandle) == 0x000008, "Wrong alignment on FLatentEventHandle");
static_assert(sizeof(FLatentEventHandle) == 0x000010, "Wrong size on FLatentEventHandle");
static_assert(offsetof(FLatentEventHandle, Event) == 0x000000, "Member 'FLatentEventHandle::Event' has a wrong offset!");

// ScriptStruct CoreGame.EnumFlagsHandle
// 0x0010 (0x0010 - 0x0000)
struct FEnumFlagsHandle final
{
public:
	class UEnum*                                  Enum;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnumeratorFlags;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnumFlagsHandle) == 0x000008, "Wrong alignment on FEnumFlagsHandle");
static_assert(sizeof(FEnumFlagsHandle) == 0x000010, "Wrong size on FEnumFlagsHandle");
static_assert(offsetof(FEnumFlagsHandle, Enum) == 0x000000, "Member 'FEnumFlagsHandle::Enum' has a wrong offset!");
static_assert(offsetof(FEnumFlagsHandle, EnumeratorFlags) == 0x000008, "Member 'FEnumFlagsHandle::EnumeratorFlags' has a wrong offset!");

// ScriptStruct CoreGame.EnumHandle
// 0x0010 (0x0010 - 0x0000)
struct FEnumHandle final
{
public:
	class UEnum*                                  Enum;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnumeratorIndex;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnumHandle) == 0x000008, "Wrong alignment on FEnumHandle");
static_assert(sizeof(FEnumHandle) == 0x000010, "Wrong size on FEnumHandle");
static_assert(offsetof(FEnumHandle, Enum) == 0x000000, "Member 'FEnumHandle::Enum' has a wrong offset!");
static_assert(offsetof(FEnumHandle, EnumeratorIndex) == 0x000008, "Member 'FEnumHandle::EnumeratorIndex' has a wrong offset!");

// ScriptStruct CoreGame.IntRectangle
// 0x0010 (0x0010 - 0x0000)
struct FIntRectangle final
{
public:
	struct FIntPoint                              Min;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntPoint                              Max;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntRectangle) == 0x000004, "Wrong alignment on FIntRectangle");
static_assert(sizeof(FIntRectangle) == 0x000010, "Wrong size on FIntRectangle");
static_assert(offsetof(FIntRectangle, Min) == 0x000000, "Member 'FIntRectangle::Min' has a wrong offset!");
static_assert(offsetof(FIntRectangle, Max) == 0x000008, "Member 'FIntRectangle::Max' has a wrong offset!");

// ScriptStruct CoreGame.GridTraceHitResult
// 0x001C (0x001C - 0x0000)
struct FGridTraceHitResult final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Normal;                                            // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntRectangle                          WallCellPair;                                      // 0x000C(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGridTraceHitResult) == 0x000004, "Wrong alignment on FGridTraceHitResult");
static_assert(sizeof(FGridTraceHitResult) == 0x00001C, "Wrong size on FGridTraceHitResult");
static_assert(offsetof(FGridTraceHitResult, Distance) == 0x000000, "Member 'FGridTraceHitResult::Distance' has a wrong offset!");
static_assert(offsetof(FGridTraceHitResult, Normal) == 0x000004, "Member 'FGridTraceHitResult::Normal' has a wrong offset!");
static_assert(offsetof(FGridTraceHitResult, WallCellPair) == 0x00000C, "Member 'FGridTraceHitResult::WallCellPair' has a wrong offset!");

// ScriptStruct CoreGame.TriangleGraphNode
// 0x0018 (0x0018 - 0x0000)
struct FTriangleGraphNode final
{
public:
	int32                                         TriangleIndexA;                                    // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleIndexB;                                    // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleIndexC;                                    // 0x0008(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SectionIndexA;                                     // 0x000C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SectionIndexB;                                     // 0x000D(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SectionIndexC;                                     // 0x000E(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bClipped : 1;                                      // 0x000F(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVisited : 1;                                      // 0x000F(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	int32                                         IslandIndex;                                       // 0x0010(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TetrahedronIndex;                                  // 0x0014(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTriangleGraphNode) == 0x000004, "Wrong alignment on FTriangleGraphNode");
static_assert(sizeof(FTriangleGraphNode) == 0x000018, "Wrong size on FTriangleGraphNode");
static_assert(offsetof(FTriangleGraphNode, TriangleIndexA) == 0x000000, "Member 'FTriangleGraphNode::TriangleIndexA' has a wrong offset!");
static_assert(offsetof(FTriangleGraphNode, TriangleIndexB) == 0x000004, "Member 'FTriangleGraphNode::TriangleIndexB' has a wrong offset!");
static_assert(offsetof(FTriangleGraphNode, TriangleIndexC) == 0x000008, "Member 'FTriangleGraphNode::TriangleIndexC' has a wrong offset!");
static_assert(offsetof(FTriangleGraphNode, SectionIndexA) == 0x00000C, "Member 'FTriangleGraphNode::SectionIndexA' has a wrong offset!");
static_assert(offsetof(FTriangleGraphNode, SectionIndexB) == 0x00000D, "Member 'FTriangleGraphNode::SectionIndexB' has a wrong offset!");
static_assert(offsetof(FTriangleGraphNode, SectionIndexC) == 0x00000E, "Member 'FTriangleGraphNode::SectionIndexC' has a wrong offset!");
static_assert(offsetof(FTriangleGraphNode, IslandIndex) == 0x000010, "Member 'FTriangleGraphNode::IslandIndex' has a wrong offset!");
static_assert(offsetof(FTriangleGraphNode, TetrahedronIndex) == 0x000014, "Member 'FTriangleGraphNode::TetrahedronIndex' has a wrong offset!");

// ScriptStruct CoreGame.MeshTriangleSubGraph
// 0x0010 (0x0010 - 0x0000)
struct FMeshTriangleSubGraph final
{
public:
	TArray<struct FTriangleGraphNode>             Nodes;                                             // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshTriangleSubGraph) == 0x000008, "Wrong alignment on FMeshTriangleSubGraph");
static_assert(sizeof(FMeshTriangleSubGraph) == 0x000010, "Wrong size on FMeshTriangleSubGraph");
static_assert(offsetof(FMeshTriangleSubGraph, Nodes) == 0x000000, "Member 'FMeshTriangleSubGraph::Nodes' has a wrong offset!");

// ScriptStruct CoreGame.TetrahedronNode
// 0x0038 (0x0038 - 0x0000)
struct FTetrahedronNode final
{
public:
	int32                                         VertexIndices[0x4];                                // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VertexSectionIndices[0x4];                         // 0x0010(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleIndices[0x4];                              // 0x0014(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TriangleSectionIndices[0x4];                       // 0x0024(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TetrahedronIndices[0x4];                           // 0x0028(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTetrahedronNode) == 0x000004, "Wrong alignment on FTetrahedronNode");
static_assert(sizeof(FTetrahedronNode) == 0x000038, "Wrong size on FTetrahedronNode");
static_assert(offsetof(FTetrahedronNode, VertexIndices) == 0x000000, "Member 'FTetrahedronNode::VertexIndices' has a wrong offset!");
static_assert(offsetof(FTetrahedronNode, VertexSectionIndices) == 0x000010, "Member 'FTetrahedronNode::VertexSectionIndices' has a wrong offset!");
static_assert(offsetof(FTetrahedronNode, TriangleIndices) == 0x000014, "Member 'FTetrahedronNode::TriangleIndices' has a wrong offset!");
static_assert(offsetof(FTetrahedronNode, TriangleSectionIndices) == 0x000024, "Member 'FTetrahedronNode::TriangleSectionIndices' has a wrong offset!");
static_assert(offsetof(FTetrahedronNode, TetrahedronIndices) == 0x000028, "Member 'FTetrahedronNode::TetrahedronIndices' has a wrong offset!");

// ScriptStruct CoreGame.SkinnedDepthVertex
// 0x0028 (0x0028 - 0x0000)
struct FSkinnedDepthVertex final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DepthRatio;                                        // 0x000C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Bones[0xC];                                        // 0x0010(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weights[0xC];                                      // 0x001C(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkinnedDepthVertex) == 0x000004, "Wrong alignment on FSkinnedDepthVertex");
static_assert(sizeof(FSkinnedDepthVertex) == 0x000028, "Wrong size on FSkinnedDepthVertex");
static_assert(offsetof(FSkinnedDepthVertex, Location) == 0x000000, "Member 'FSkinnedDepthVertex::Location' has a wrong offset!");
static_assert(offsetof(FSkinnedDepthVertex, DepthRatio) == 0x00000C, "Member 'FSkinnedDepthVertex::DepthRatio' has a wrong offset!");
static_assert(offsetof(FSkinnedDepthVertex, Bones) == 0x000010, "Member 'FSkinnedDepthVertex::Bones' has a wrong offset!");
static_assert(offsetof(FSkinnedDepthVertex, Weights) == 0x00001C, "Member 'FSkinnedDepthVertex::Weights' has a wrong offset!");

// ScriptStruct CoreGame.MeshTriangleGraphIsland
// 0x0028 (0x0028 - 0x0000)
struct FMeshTriangleGraphIsland final
{
public:
	uint8                                         bVisited : 1;                                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWatertight : 1;                                   // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         SectionIndex;                                      // 0x0001(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TriangleIndex;                                     // 0x0004(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTetrahedronNode>               TetrahedronNodes;                                  // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FSkinnedDepthVertex>            TetrahedronVertices;                               // 0x0018(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshTriangleGraphIsland) == 0x000008, "Wrong alignment on FMeshTriangleGraphIsland");
static_assert(sizeof(FMeshTriangleGraphIsland) == 0x000028, "Wrong size on FMeshTriangleGraphIsland");
static_assert(offsetof(FMeshTriangleGraphIsland, SectionIndex) == 0x000001, "Member 'FMeshTriangleGraphIsland::SectionIndex' has a wrong offset!");
static_assert(offsetof(FMeshTriangleGraphIsland, TriangleIndex) == 0x000004, "Member 'FMeshTriangleGraphIsland::TriangleIndex' has a wrong offset!");
static_assert(offsetof(FMeshTriangleGraphIsland, TetrahedronNodes) == 0x000008, "Member 'FMeshTriangleGraphIsland::TetrahedronNodes' has a wrong offset!");
static_assert(offsetof(FMeshTriangleGraphIsland, TetrahedronVertices) == 0x000018, "Member 'FMeshTriangleGraphIsland::TetrahedronVertices' has a wrong offset!");

// ScriptStruct CoreGame.MeshTriangleGraph
// 0x0020 (0x0020 - 0x0000)
struct FMeshTriangleGraph final
{
public:
	TArray<struct FMeshTriangleSubGraph>          SubGraphs;                                         // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FMeshTriangleGraphIsland>       Islands;                                           // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshTriangleGraph) == 0x000008, "Wrong alignment on FMeshTriangleGraph");
static_assert(sizeof(FMeshTriangleGraph) == 0x000020, "Wrong size on FMeshTriangleGraph");
static_assert(offsetof(FMeshTriangleGraph, SubGraphs) == 0x000000, "Member 'FMeshTriangleGraph::SubGraphs' has a wrong offset!");
static_assert(offsetof(FMeshTriangleGraph, Islands) == 0x000010, "Member 'FMeshTriangleGraph::Islands' has a wrong offset!");

// ScriptStruct CoreGame.PolyhedronEdge
// 0x0008 (0x0008 - 0x0000)
struct FPolyhedronEdge final
{
public:
	int32                                         FaceArrayIndex;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        EdgeArrayIndex;                                    // 0x0004(0x0002)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPolyhedronFaceType                           FaceType;                                          // 0x0006(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPolyhedronEdge) == 0x000004, "Wrong alignment on FPolyhedronEdge");
static_assert(sizeof(FPolyhedronEdge) == 0x000008, "Wrong size on FPolyhedronEdge");
static_assert(offsetof(FPolyhedronEdge, FaceArrayIndex) == 0x000000, "Member 'FPolyhedronEdge::FaceArrayIndex' has a wrong offset!");
static_assert(offsetof(FPolyhedronEdge, EdgeArrayIndex) == 0x000004, "Member 'FPolyhedronEdge::EdgeArrayIndex' has a wrong offset!");
static_assert(offsetof(FPolyhedronEdge, FaceType) == 0x000006, "Member 'FPolyhedronEdge::FaceType' has a wrong offset!");

// ScriptStruct CoreGame.PolyhedronFace
// 0x0020 (0x0020 - 0x0000)
struct FPolyhedronFace
{
public:
	struct FVector                                Normal;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 VertexIndices;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPolyhedronFace) == 0x000008, "Wrong alignment on FPolyhedronFace");
static_assert(sizeof(FPolyhedronFace) == 0x000020, "Wrong size on FPolyhedronFace");
static_assert(offsetof(FPolyhedronFace, Normal) == 0x000000, "Member 'FPolyhedronFace::Normal' has a wrong offset!");
static_assert(offsetof(FPolyhedronFace, VertexIndices) == 0x000010, "Member 'FPolyhedronFace::VertexIndices' has a wrong offset!");

// ScriptStruct CoreGame.UnsharedPolyhedronFace
// 0x0018 (0x0038 - 0x0020)
struct FUnsharedPolyhedronFace final : public FPolyhedronFace
{
public:
	int32                                         PolyhedronIndex;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPolyhedronEdge>                OppositeEdges;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnsharedPolyhedronFace) == 0x000008, "Wrong alignment on FUnsharedPolyhedronFace");
static_assert(sizeof(FUnsharedPolyhedronFace) == 0x000038, "Wrong size on FUnsharedPolyhedronFace");
static_assert(offsetof(FUnsharedPolyhedronFace, PolyhedronIndex) == 0x000020, "Member 'FUnsharedPolyhedronFace::PolyhedronIndex' has a wrong offset!");
static_assert(offsetof(FUnsharedPolyhedronFace, OppositeEdges) == 0x000028, "Member 'FUnsharedPolyhedronFace::OppositeEdges' has a wrong offset!");

// ScriptStruct CoreGame.SharedPolyhedronFace
// 0x0028 (0x0048 - 0x0020)
struct FSharedPolyhedronFace final : public FPolyhedronFace
{
public:
	int32                                         PolyhedronIndices[0x2];                            // 0x0020(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPolyhedronEdge>                OppositeEdgesA;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FPolyhedronEdge>                OppositeEdgesB;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSharedPolyhedronFace) == 0x000008, "Wrong alignment on FSharedPolyhedronFace");
static_assert(sizeof(FSharedPolyhedronFace) == 0x000048, "Wrong size on FSharedPolyhedronFace");
static_assert(offsetof(FSharedPolyhedronFace, PolyhedronIndices) == 0x000020, "Member 'FSharedPolyhedronFace::PolyhedronIndices' has a wrong offset!");
static_assert(offsetof(FSharedPolyhedronFace, OppositeEdgesA) == 0x000028, "Member 'FSharedPolyhedronFace::OppositeEdgesA' has a wrong offset!");
static_assert(offsetof(FSharedPolyhedronFace, OppositeEdgesB) == 0x000038, "Member 'FSharedPolyhedronFace::OppositeEdgesB' has a wrong offset!");

// ScriptStruct CoreGame.Polyhedron
// 0x0050 (0x0050 - 0x0000)
struct FPolyhedron final
{
public:
	struct FBox                                   Bounds;                                            // 0x0000(0x001C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 VertexIndices;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 SharedFaceIndices;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<int32>                                 UnsharedFaceIndices;                               // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPolyhedron) == 0x000008, "Wrong alignment on FPolyhedron");
static_assert(sizeof(FPolyhedron) == 0x000050, "Wrong size on FPolyhedron");
static_assert(offsetof(FPolyhedron, Bounds) == 0x000000, "Member 'FPolyhedron::Bounds' has a wrong offset!");
static_assert(offsetof(FPolyhedron, VertexIndices) == 0x000020, "Member 'FPolyhedron::VertexIndices' has a wrong offset!");
static_assert(offsetof(FPolyhedron, SharedFaceIndices) == 0x000030, "Member 'FPolyhedron::SharedFaceIndices' has a wrong offset!");
static_assert(offsetof(FPolyhedron, UnsharedFaceIndices) == 0x000040, "Member 'FPolyhedron::UnsharedFaceIndices' has a wrong offset!");

// ScriptStruct CoreGame.PolyhedralMesh
// 0x0048 (0x0048 - 0x0000)
struct FPolyhedralMesh final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Vertices;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSharedPolyhedronFace>          SharedFaces;                                       // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUnsharedPolyhedronFace>        UnsharedFaces;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPolyhedron>                    Polyhedra;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPolyhedralMesh) == 0x000008, "Wrong alignment on FPolyhedralMesh");
static_assert(sizeof(FPolyhedralMesh) == 0x000048, "Wrong size on FPolyhedralMesh");
static_assert(offsetof(FPolyhedralMesh, Vertices) == 0x000008, "Member 'FPolyhedralMesh::Vertices' has a wrong offset!");
static_assert(offsetof(FPolyhedralMesh, SharedFaces) == 0x000018, "Member 'FPolyhedralMesh::SharedFaces' has a wrong offset!");
static_assert(offsetof(FPolyhedralMesh, UnsharedFaces) == 0x000028, "Member 'FPolyhedralMesh::UnsharedFaces' has a wrong offset!");
static_assert(offsetof(FPolyhedralMesh, Polyhedra) == 0x000038, "Member 'FPolyhedralMesh::Polyhedra' has a wrong offset!");

}

