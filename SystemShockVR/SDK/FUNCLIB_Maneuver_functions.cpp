#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FUNCLIB_Maneuver

#include "Basic.hpp"

#include "FUNCLIB_Maneuver_classes.hpp"
#include "FUNCLIB_Maneuver_parameters.hpp"


namespace SDK
{

// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.GetSphereVertices
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NumberOfPoints                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Forward                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Vertices                                               (Parm, OutParm)

void UFUNCLIB_Maneuver_C::GetSphereVertices(int32 NumberOfPoints, const struct FVector& Forward, class UObject* __WorldContext, TArray<struct FVector>* Vertices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "GetSphereVertices");

	Params::FUNCLIB_Maneuver_C_GetSphereVertices Parms{};

	Parms.NumberOfPoints = NumberOfPoints;
	Parms.Forward = std::move(Forward);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Vertices != nullptr)
		*Vertices = std::move(Parms.Vertices);
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.AmountOutsideRange
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Min                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Max                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Maneuver_C::AmountOutsideRange(float Value, float Min, float Max, class UObject* __WorldContext, float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "AmountOutsideRange");

	Params::FUNCLIB_Maneuver_C_AmountOutsideRange Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.CullDirectionsByAngle
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  Directions                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector                          SourceDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxAngle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  RemainingDirections                                    (Parm, OutParm)

void UFUNCLIB_Maneuver_C::CullDirectionsByAngle(TArray<struct FVector>& Directions, const struct FVector& SourceDirection, float MaxAngle, class UObject* __WorldContext, TArray<struct FVector>* RemainingDirections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "CullDirectionsByAngle");

	Params::FUNCLIB_Maneuver_C_CullDirectionsByAngle Parms{};

	Parms.Directions = std::move(Directions);
	Parms.SourceDirection = std::move(SourceDirection);
	Parms.MaxAngle = MaxAngle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Directions = std::move(Parms.Directions);

	if (RemainingDirections != nullptr)
		*RemainingDirections = std::move(Parms.RemainingDirections);
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.GetDirectionSphereTrace
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TestDirection                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    Hit                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UFUNCLIB_Maneuver_C::GetDirectionSphereTrace(class AActor* Actor, const struct FVector& TestDirection, float Distance, class UObject* __WorldContext, struct FHitResult* OutHit, bool* Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "GetDirectionSphereTrace");

	Params::FUNCLIB_Maneuver_C_GetDirectionSphereTrace Parms{};

	Parms.Actor = Actor;
	Parms.TestDirection = std::move(TestDirection);
	Parms.Distance = Distance;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (Hit != nullptr)
		*Hit = Parms.Hit;
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.GetWeightSucceededMax
// (Static, Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WeightSucceededMax                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Maneuver_C::GetWeightSucceededMax(class UObject* __WorldContext, float* WeightSucceededMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "GetWeightSucceededMax");

	Params::FUNCLIB_Maneuver_C_GetWeightSucceededMax Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (WeightSucceededMax != nullptr)
		*WeightSucceededMax = Parms.WeightSucceededMax;
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.GetWeightSucceededMin
// (Static, Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WeightSucceededMin                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Maneuver_C::GetWeightSucceededMin(class UObject* __WorldContext, float* WeightSucceededMin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "GetWeightSucceededMin");

	Params::FUNCLIB_Maneuver_C_GetWeightSucceededMin Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (WeightSucceededMin != nullptr)
		*WeightSucceededMin = Parms.WeightSucceededMin;
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.GetWeightFailedMax
// (Static, Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WeightFailedMax                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Maneuver_C::GetWeightFailedMax(class UObject* __WorldContext, float* WeightFailedMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "GetWeightFailedMax");

	Params::FUNCLIB_Maneuver_C_GetWeightFailedMax Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (WeightFailedMax != nullptr)
		*WeightFailedMax = Parms.WeightFailedMax;
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.GetWeightFailedMin
// (Static, Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WeightFailedMin                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Maneuver_C::GetWeightFailedMin(class UObject* __WorldContext, float* WeightFailedMin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "GetWeightFailedMin");

	Params::FUNCLIB_Maneuver_C_GetWeightFailedMin Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (WeightFailedMin != nullptr)
		*WeightFailedMin = Parms.WeightFailedMin;
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.CombineWeights
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<float>                           WeightsA                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<float>                           WeightsB                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<float>                           NewWeights                                             (Parm, OutParm)

void UFUNCLIB_Maneuver_C::CombineWeights(TArray<float>& WeightsA, TArray<float>& WeightsB, class UObject* __WorldContext, TArray<float>* NewWeights)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "CombineWeights");

	Params::FUNCLIB_Maneuver_C_CombineWeights Parms{};

	Parms.WeightsA = std::move(WeightsA);
	Parms.WeightsB = std::move(WeightsB);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	WeightsA = std::move(Parms.WeightsA);
	WeightsB = std::move(Parms.WeightsB);

	if (NewWeights != nullptr)
		*NewWeights = std::move(Parms.NewWeights);
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.GetPredictedTargetLocation
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UOBJ_EnemyTarget_C*               Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TimeInTheFuture                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          PredictedLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Maneuver_C::GetPredictedTargetLocation(class UOBJ_EnemyTarget_C* Target, float TimeInTheFuture, class UObject* __WorldContext, struct FVector* PredictedLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "GetPredictedTargetLocation");

	Params::FUNCLIB_Maneuver_C_GetPredictedTargetLocation Parms{};

	Parms.Target = Target;
	Parms.TimeInTheFuture = TimeInTheFuture;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (PredictedLocation != nullptr)
		*PredictedLocation = std::move(Parms.PredictedLocation);
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.CreateNavTarget
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UOBJ_EnemyTarget_C*               Target                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)

void UFUNCLIB_Maneuver_C::CreateNavTarget(class APAWN_Enemy_C* Enemy, const struct FVector& Location, class UObject* __WorldContext, class UOBJ_EnemyTarget_C** Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "CreateNavTarget");

	Params::FUNCLIB_Maneuver_C_CreateNavTarget Parms{};

	Parms.Enemy = Enemy;
	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Target != nullptr)
		*Target = Parms.Target;
}


// Function FUNCLIB_Maneuver.FUNCLIB_Maneuver_C.GetPredictedActorLocation
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Offset                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TimeInFuture                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Maneuver_C::GetPredictedActorLocation(class AActor* Actor, const struct FVector& Offset, float TimeInFuture, class UObject* __WorldContext, struct FVector* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Maneuver_C", "GetPredictedActorLocation");

	Params::FUNCLIB_Maneuver_C_GetPredictedActorLocation Parms{};

	Parms.Actor = Actor;
	Parms.Offset = std::move(Offset);
	Parms.TimeInFuture = TimeInFuture;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}

}

