#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GI_SinglePlayer

#include "Basic.hpp"

#include "GI_SinglePlayer_classes.hpp"
#include "GI_SinglePlayer_parameters.hpp"


namespace SDK
{

// Function GI_SinglePlayer.GI_SinglePlayer_C.OnSecurityLevelChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewSecurityLevel                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnSecurityLevelChanged__DelegateSignature(int32 NewSecurityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnSecurityLevelChanged__DelegateSignature");

	Params::GI_SinglePlayer_C_OnSecurityLevelChanged__DelegateSignature Parms{};

	Parms.NewSecurityLevel = NewSecurityLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnStoryQuestChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             StoryQuestName                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::OnStoryQuestChanged__DelegateSignature(class FName StoryQuestName, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnStoryQuestChanged__DelegateSignature");

	Params::GI_SinglePlayer_C_OnStoryQuestChanged__DelegateSignature Parms{};

	Parms.StoryQuestName = StoryQuestName;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFinishedLoadingStreamLevel__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnFinishedLoadingStreamLevel__DelegateSignature(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFinishedLoadingStreamLevel__DelegateSignature");

	Params::GI_SinglePlayer_C_OnFinishedLoadingStreamLevel__DelegateSignature Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnStartUnloadingStreamLevel__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnStartUnloadingStreamLevel__DelegateSignature(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnStartUnloadingStreamLevel__DelegateSignature");

	Params::GI_SinglePlayer_C_OnStartUnloadingStreamLevel__DelegateSignature Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFinishedUnloadingStreamLevel__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnFinishedUnloadingStreamLevel__DelegateSignature(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFinishedUnloadingStreamLevel__DelegateSignature");

	Params::GI_SinglePlayer_C_OnFinishedUnloadingStreamLevel__DelegateSignature Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFinishedLoadingLevelCollection__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnFinishedLoadingLevelCollection__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFinishedLoadingLevelCollection__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFinishedUnloadingLevelCollection__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnFinishedUnloadingLevelCollection__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFinishedUnloadingLevelCollection__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnComputerNodesChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NodesRemaining                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnComputerNodesChanged__DelegateSignature(int32 NodesRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnComputerNodesChanged__DelegateSignature");

	Params::GI_SinglePlayer_C_OnComputerNodesChanged__DelegateSignature Parms{};

	Parms.NodesRemaining = NodesRemaining;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnStartLoadingLevelCollection__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnStartLoadingLevelCollection__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnStartLoadingLevelCollection__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnStartUnloadingLevelCollection__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnStartUnloadingLevelCollection__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnStartUnloadingLevelCollection__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnPeriodicGameCountdownEvent__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnPeriodicGameCountdownEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnPeriodicGameCountdownEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnTutorialCompleted__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             TutorialName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnTutorialCompleted__DelegateSignature(class FName TutorialName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnTutorialCompleted__DelegateSignature");

	Params::GI_SinglePlayer_C_OnTutorialCompleted__DelegateSignature Parms{};

	Parms.TutorialName = TutorialName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnPublicAddressStateChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundCue*                        SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSoftObjectPtr<class UTexture2D>        PortraitTexture                                        (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// int32                                   RowCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ColCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   FrameRate                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnPublicAddressStateChanged__DelegateSignature(class USoundCue* SoundCue, TSoftObjectPtr<class UTexture2D> PortraitTexture, int32 RowCount, int32 ColCount, int32 FrameRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnPublicAddressStateChanged__DelegateSignature");

	Params::GI_SinglePlayer_C_OnPublicAddressStateChanged__DelegateSignature Parms{};

	Parms.SoundCue = SoundCue;
	Parms.PortraitTexture = PortraitTexture;
	Parms.RowCount = RowCount;
	Parms.ColCount = ColCount;
	Parms.FrameRate = FrameRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnStoryQuestNotification__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             QuestName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             NotificationText                                       (BlueprintVisible, BlueprintReadOnly, Parm)
// float                                   NotificationDelay                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnStoryQuestNotification__DelegateSignature(class FName QuestName, const class FText& NotificationText, float NotificationDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnStoryQuestNotification__DelegateSignature");

	Params::GI_SinglePlayer_C_OnStoryQuestNotification__DelegateSignature Parms{};

	Parms.QuestName = QuestName;
	Parms.NotificationText = std::move(NotificationText);
	Parms.NotificationDelay = NotificationDelay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnPendingLostItemsChanged__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnPendingLostItemsChanged__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnPendingLostItemsChanged__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnControllerConnectionStateChange__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ControllerConnectedState                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::OnControllerConnectionStateChange__DelegateSignature(bool ControllerConnectedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnControllerConnectionStateChange__DelegateSignature");

	Params::GI_SinglePlayer_C_OnControllerConnectionStateChange__DelegateSignature Parms{};

	Parms.ControllerConnectedState = ControllerConnectedState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ExecuteUbergraph_GI_SinglePlayer
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::ExecuteUbergraph_GI_SinglePlayer(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ExecuteUbergraph_GI_SinglePlayer");

	Params::GI_SinglePlayer_C_ExecuteUbergraph_GI_SinglePlayer Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnOnlineConnectionStatusChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsConnected                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::OnOnlineConnectionStatusChange(bool bIsConnected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnOnlineConnectionStatusChange");

	Params::GI_SinglePlayer_C_OnOnlineConnectionStatusChange Parms{};

	Parms.bIsConnected = bIsConnected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnControllerConnectionChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsConnected                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnControllerConnectionChange(bool bIsConnected, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnControllerConnectionChange");

	Params::GI_SinglePlayer_C_OnControllerConnectionChange Parms{};

	Parms.bIsConnected = bIsConnected;
	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFinishedLoadingLevel
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           MapName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnFinishedLoadingLevel(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFinishedLoadingLevel");

	Params::GI_SinglePlayer_C_OnFinishedLoadingLevel Parms{};

	Parms.MapName = std::move(MapName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFinishedLoadingGame
// (Event, Public, BlueprintEvent)

void UGI_SinglePlayer_C::OnFinishedLoadingGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFinishedLoadingGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnStartedLoadingGame
// (Event, Public, BlueprintEvent)

void UGI_SinglePlayer_C::OnStartedLoadingGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnStartedLoadingGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.EVENT_OnFinishedUnloadingLevelCollectionWithLoadingScreen
// (BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::EVENT_OnFinishedUnloadingLevelCollectionWithLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "EVENT_OnFinishedUnloadingLevelCollectionWithLoadingScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UnloadCurrentThenLoadLevelCollectionWithLoadingScreen
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UnloadCurrentThenLoadLevelCollectionWithLoadingScreen(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UnloadCurrentThenLoadLevelCollectionWithLoadingScreen");

	Params::GI_SinglePlayer_C_UnloadCurrentThenLoadLevelCollectionWithLoadingScreen Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.StartLoadingLevelCollectionWithLoadingScreen
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::StartLoadingLevelCollectionWithLoadingScreen(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "StartLoadingLevelCollectionWithLoadingScreen");

	Params::GI_SinglePlayer_C_StartLoadingLevelCollectionWithLoadingScreen Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnTick");

	Params::GI_SinglePlayer_C_OnTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ReceiveShutdown
// (Event, Public, BlueprintEvent)

void UGI_SinglePlayer_C::ReceiveShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ReceiveShutdown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.EVENT_OnFinishedLoadingLevelCollectionWithLoadingScreen
// (BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::EVENT_OnFinishedLoadingLevelCollectionWithLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "EVENT_OnFinishedLoadingLevelCollectionWithLoadingScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ReceiveInit
// (Event, Public, BlueprintEvent)

void UGI_SinglePlayer_C::ReceiveInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ReceiveInit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.INTERNAL_UnloadNextLevelForCollection
// (BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::INTERNAL_UnloadNextLevelForCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "INTERNAL_UnloadNextLevelForCollection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.INTERNAL_LoadNextLevelForCollection
// (BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::INTERNAL_LoadNextLevelForCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "INTERNAL_LoadNextLevelForCollection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.StartUnloadingStreamingLevelCollection
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              LevelCollection                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// TArray<class FName>                     LevelsToKeepLoaded                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGI_SinglePlayer_C::StartUnloadingStreamingLevelCollection(const struct FDataTableRowHandle& LevelCollection, const TArray<class FName>& LevelsToKeepLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "StartUnloadingStreamingLevelCollection");

	Params::GI_SinglePlayer_C_StartUnloadingStreamingLevelCollection Parms{};

	Parms.LevelCollection = std::move(LevelCollection);
	Parms.LevelsToKeepLoaded = std::move(LevelsToKeepLoaded);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.StartLoadingStreamingLevelCollection
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              LevelCollection                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    BlockOnLoad                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::StartLoadingStreamingLevelCollection(const struct FDataTableRowHandle& LevelCollection, bool BlockOnLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "StartLoadingStreamingLevelCollection");

	Params::GI_SinglePlayer_C_StartLoadingStreamingLevelCollection Parms{};

	Parms.LevelCollection = std::move(LevelCollection);
	Parms.BlockOnLoad = BlockOnLoad;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySoundFromVoxelComponent
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// float                                   FadeInDuration                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UVoxelAudioComponent*             AudioComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncPlaySoundFromVoxelComponent(TSoftObjectPtr<class USoundCue> SoundCue, const float FadeInDuration, float StartTime, class UVoxelAudioComponent* AudioComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySoundFromVoxelComponent");

	Params::GI_SinglePlayer_C_AsyncPlaySoundFromVoxelComponent Parms{};

	Parms.SoundCue = SoundCue;
	Parms.FadeInDuration = FadeInDuration;
	Parms.StartTime = StartTime;
	Parms.AudioComponent = AudioComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncLoadPublicAddressCue
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// float                                   ElapsedTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncLoadPublicAddressCue(TSoftObjectPtr<class USoundCue> SoundCue, float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncLoadPublicAddressCue");

	Params::GI_SinglePlayer_C_AsyncLoadPublicAddressCue Parms{};

	Parms.SoundCue = SoundCue;
	Parms.ElapsedTime = ElapsedTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySystem
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UFXSystemAsset>    System                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// struct FSTRUCT_AsyncParticleParams      SystemParams                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncPlaySystem(const TSoftObjectPtr<class UFXSystemAsset>& System, const struct FSTRUCT_AsyncParticleParams& SystemParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySystem");

	Params::GI_SinglePlayer_C_AsyncPlaySystem Parms{};

	Parms.System = System;
	Parms.SystemParams = std::move(SystemParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySound
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FSTRUCT_AsyncSoundParams         SoundParams                                            (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncPlaySound(TSoftObjectPtr<class USoundCue> SoundCue, const struct FSTRUCT_AsyncSoundParams& SoundParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySound");

	Params::GI_SinglePlayer_C_AsyncPlaySound Parms{};

	Parms.SoundCue = SoundCue;
	Parms.SoundParams = std::move(SoundParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncStopSystemAttachments
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncStopSystemAttachments(class USceneComponent* SceneComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncStopSystemAttachments");

	Params::GI_SinglePlayer_C_AsyncStopSystemAttachments Parms{};

	Parms.SceneComponent = SceneComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncStopSystemOnComponents
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UFXSystemComponent*>       SystemComponents                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UGI_SinglePlayer_C::AsyncStopSystemOnComponents(const TArray<class UFXSystemComponent*>& SystemComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncStopSystemOnComponents");

	Params::GI_SinglePlayer_C_AsyncStopSystemOnComponents Parms{};

	Parms.SystemComponents = std::move(SystemComponents);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncStopSystemOnComponent
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFXSystemComponent*               SystemComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncStopSystemOnComponent(class UFXSystemComponent* SystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncStopSystemOnComponent");

	Params::GI_SinglePlayer_C_AsyncStopSystemOnComponent Parms{};

	Parms.SystemComponent = SystemComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySoundFromComponents
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// TArray<class UAudioComponent*>          AudioComponents                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UGI_SinglePlayer_C::AsyncPlaySoundFromComponents(TSoftObjectPtr<class USoundCue> SoundCue, const TArray<class UAudioComponent*>& AudioComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySoundFromComponents");

	Params::GI_SinglePlayer_C_AsyncPlaySoundFromComponents Parms{};

	Parms.SoundCue = SoundCue;
	Parms.AudioComponents = std::move(AudioComponents);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySystemFromComponents
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UNiagaraSystem>    System                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// TArray<class UNiagaraComponent*>        SystemComponents                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UGI_SinglePlayer_C::AsyncPlaySystemFromComponents(TSoftObjectPtr<class UNiagaraSystem> System, const TArray<class UNiagaraComponent*>& SystemComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySystemFromComponents");

	Params::GI_SinglePlayer_C_AsyncPlaySystemFromComponents Parms{};

	Parms.System = System;
	Parms.SystemComponents = std::move(SystemComponents);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySystemFromComponent
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UFXSystemAsset>    System                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UFXSystemComponent*               SystemComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncPlaySystemFromComponent(TSoftObjectPtr<class UFXSystemAsset> System, class UFXSystemComponent* SystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySystemFromComponent");

	Params::GI_SinglePlayer_C_AsyncPlaySystemFromComponent Parms{};

	Parms.System = System;
	Parms.SystemComponent = SystemComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySoundFromComponent
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// float                                   FadeInDuration                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent*                  AudioComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncPlaySoundFromComponent(TSoftObjectPtr<class USoundCue> SoundCue, const float FadeInDuration, float StartTime, class UAudioComponent* AudioComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySoundFromComponent");

	Params::GI_SinglePlayer_C_AsyncPlaySoundFromComponent Parms{};

	Parms.SoundCue = SoundCue;
	Parms.FadeInDuration = FadeInDuration;
	Parms.StartTime = StartTime;
	Parms.AudioComponent = AudioComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySystemAttached
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UFXSystemAsset>    System                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class USceneComponent*                  AttachToComponent                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          RelativeLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         RelativeRotation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FSTRUCT_EffectParams             EffectsParameters                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FLatentObjectEventHandle         OnSpawnEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)

void UGI_SinglePlayer_C::AsyncPlaySystemAttached(TSoftObjectPtr<class UFXSystemAsset> System, class USceneComponent* AttachToComponent, class FName SocketName, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, const struct FSTRUCT_EffectParams& EffectsParameters, const struct FLatentObjectEventHandle& OnSpawnEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySystemAttached");

	Params::GI_SinglePlayer_C_AsyncPlaySystemAttached Parms{};

	Parms.System = System;
	Parms.AttachToComponent = AttachToComponent;
	Parms.SocketName = SocketName;
	Parms.RelativeLocation = std::move(RelativeLocation);
	Parms.RelativeRotation = std::move(RelativeRotation);
	Parms.EffectsParameters = std::move(EffectsParameters);
	Parms.OnSpawnEvent = std::move(OnSpawnEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySystemAtTransform
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UFXSystemAsset>    System                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FTransform                       Transform                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::AsyncPlaySystemAtTransform(TSoftObjectPtr<class UFXSystemAsset> System, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySystemAtTransform");

	Params::GI_SinglePlayer_C_AsyncPlaySystemAtTransform Parms{};

	Parms.System = System;
	Parms.Transform = std::move(Transform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySoundAttached
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class USceneComponent*                  AttachToComponent                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          RelativeLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         RelativeRotation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FSTRUCT_EffectParams             SoundParameters                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncPlaySoundAttached(TSoftObjectPtr<class USoundCue> SoundCue, class USceneComponent* AttachToComponent, class FName SocketName, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, const struct FSTRUCT_EffectParams& SoundParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySoundAttached");

	Params::GI_SinglePlayer_C_AsyncPlaySoundAttached Parms{};

	Parms.SoundCue = SoundCue;
	Parms.AttachToComponent = AttachToComponent;
	Parms.SocketName = SocketName;
	Parms.RelativeLocation = std::move(RelativeLocation);
	Parms.RelativeRotation = std::move(RelativeRotation);
	Parms.SoundParameters = std::move(SoundParameters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySoundAtLocation
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncPlaySoundAtLocation(TSoftObjectPtr<class USoundCue> SoundCue, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySoundAtLocation");

	Params::GI_SinglePlayer_C_AsyncPlaySoundAtLocation Parms{};

	Parms.SoundCue = SoundCue;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncPlaySound2D
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncPlaySound2D(TSoftObjectPtr<class USoundCue> SoundCue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncPlaySound2D");

	Params::GI_SinglePlayer_C_AsyncPlaySound2D Parms{};

	Parms.SoundCue = SoundCue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AsyncCompleteAchievement
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FDataTableRowHandle              AchievementHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// int32                                   UserTag                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AsyncCompleteAchievement(class APlayerController* PlayerController, const struct FDataTableRowHandle& AchievementHandle, int32 UserTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AsyncCompleteAchievement");

	Params::GI_SinglePlayer_C_AsyncCompleteAchievement Parms{};

	Parms.PlayerController = PlayerController;
	Parms.AchievementHandle = std::move(AchievementHandle);
	Parms.UserTag = UserTag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_5F20C05541B420AAFDF306B06AF3128C
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_5F20C05541B420AAFDF306B06AF3128C(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_5F20C05541B420AAFDF306B06AF3128C");

	Params::GI_SinglePlayer_C_OnLoaded_5F20C05541B420AAFDF306B06AF3128C Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_8813AF2B47A0C9D07AFC5599A36960DC
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_8813AF2B47A0C9D07AFC5599A36960DC(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_8813AF2B47A0C9D07AFC5599A36960DC");

	Params::GI_SinglePlayer_C_OnLoaded_8813AF2B47A0C9D07AFC5599A36960DC Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_C37B164D45E88D137228229CBD66276C
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_C37B164D45E88D137228229CBD66276C(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_C37B164D45E88D137228229CBD66276C");

	Params::GI_SinglePlayer_C_OnLoaded_C37B164D45E88D137228229CBD66276C Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_902273224FDEF301060954979477BC10
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_902273224FDEF301060954979477BC10(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_902273224FDEF301060954979477BC10");

	Params::GI_SinglePlayer_C_OnLoaded_902273224FDEF301060954979477BC10 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_27DE819F4EE56836C47D57B5FC573DF3
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_27DE819F4EE56836C47D57B5FC573DF3(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_27DE819F4EE56836C47D57B5FC573DF3");

	Params::GI_SinglePlayer_C_OnLoaded_27DE819F4EE56836C47D57B5FC573DF3 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_0AE72DE7432C87D6E53955A12395D8C0
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_0AE72DE7432C87D6E53955A12395D8C0(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_0AE72DE7432C87D6E53955A12395D8C0");

	Params::GI_SinglePlayer_C_OnLoaded_0AE72DE7432C87D6E53955A12395D8C0 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_A8C87E1843AC479AC213708C6EA1A5CC
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_A8C87E1843AC479AC213708C6EA1A5CC(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_A8C87E1843AC479AC213708C6EA1A5CC");

	Params::GI_SinglePlayer_C_OnLoaded_A8C87E1843AC479AC213708C6EA1A5CC Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_E3F818954DA5FE57518113AEA34DB5C9
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_E3F818954DA5FE57518113AEA34DB5C9(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_E3F818954DA5FE57518113AEA34DB5C9");

	Params::GI_SinglePlayer_C_OnLoaded_E3F818954DA5FE57518113AEA34DB5C9 Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLoaded_AD81EB1046C74F24ACB5A9951ACF845E
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Loaded                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnLoaded_AD81EB1046C74F24ACB5A9951ACF845E(class UObject* Loaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLoaded_AD81EB1046C74F24ACB5A9951ACF845E");

	Params::GI_SinglePlayer_C_OnLoaded_AD81EB1046C74F24ACB5A9951ACF845E Parms{};

	Parms.Loaded = Loaded;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnSuccess_1E3D796F4FD7EC1D6937C7BD8033813A
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WrittenAchievementName                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WrittenProgress                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   WrittenUserTag                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnSuccess_1E3D796F4FD7EC1D6937C7BD8033813A(class FName WrittenAchievementName, float WrittenProgress, int32 WrittenUserTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnSuccess_1E3D796F4FD7EC1D6937C7BD8033813A");

	Params::GI_SinglePlayer_C_OnSuccess_1E3D796F4FD7EC1D6937C7BD8033813A Parms{};

	Parms.WrittenAchievementName = WrittenAchievementName;
	Parms.WrittenProgress = WrittenProgress;
	Parms.WrittenUserTag = WrittenUserTag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFailure_1E3D796F4FD7EC1D6937C7BD8033813A
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             WrittenAchievementName                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WrittenProgress                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   WrittenUserTag                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnFailure_1E3D796F4FD7EC1D6937C7BD8033813A(class FName WrittenAchievementName, float WrittenProgress, int32 WrittenUserTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFailure_1E3D796F4FD7EC1D6937C7BD8033813A");

	Params::GI_SinglePlayer_C_OnFailure_1E3D796F4FD7EC1D6937C7BD8033813A Parms{};

	Parms.WrittenAchievementName = WrittenAchievementName;
	Parms.WrittenProgress = WrittenProgress;
	Parms.WrittenUserTag = WrittenUserTag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.LowerSecurityLevel
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SubtractAmount                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::LowerSecurityLevel(int32 SubtractAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "LowerSecurityLevel");

	Params::GI_SinglePlayer_C_LowerSecurityLevel Parms{};

	Parms.SubtractAmount = SubtractAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasCompletedStoryQuest
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             QuestName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Completed                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasCompletedStoryQuest(class FName QuestName, bool* Completed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasCompletedStoryQuest");

	Params::GI_SinglePlayer_C_HasCompletedStoryQuest Parms{};

	Parms.QuestName = QuestName;

	UObject::ProcessEvent(Func, &Parms);

	if (Completed != nullptr)
		*Completed = Parms.Completed;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetStoryQuestCompletionTimestamp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             QuestName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Timestamp                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetStoryQuestCompletionTimestamp(class FName QuestName, float* Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetStoryQuestCompletionTimestamp");

	Params::GI_SinglePlayer_C_GetStoryQuestCompletionTimestamp Parms{};

	Parms.QuestName = QuestName;

	UObject::ProcessEvent(Func, &Parms);

	if (Timestamp != nullptr)
		*Timestamp = Parms.Timestamp;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetCompletedStoryQuest
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             QuestName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FString                           LogString                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetCompletedStoryQuest(class FName QuestName, bool Value, class FString* LogString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetCompletedStoryQuest");

	Params::GI_SinglePlayer_C_SetCompletedStoryQuest Parms{};

	Parms.QuestName = QuestName;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);

	if (LogString != nullptr)
		*LogString = std::move(Parms.LogString);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetSecurityLevel
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewSecurityLevel                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetSecurityLevel(int32 NewSecurityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetSecurityLevel");

	Params::GI_SinglePlayer_C_SetSecurityLevel Parms{};

	Parms.NewSecurityLevel = NewSecurityLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsLoadingScreenVisible
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsLoadingScreenVisible(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsLoadingScreenVisible");

	Params::GI_SinglePlayer_C_IsLoadingScreenVisible Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasAssignedCurrentLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasAssignedCurrentLevel(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasAssignedCurrentLevel");

	Params::GI_SinglePlayer_C_HasAssignedCurrentLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasAssignedPreviousLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasAssignedPreviousLevel(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasAssignedPreviousLevel");

	Params::GI_SinglePlayer_C_HasAssignedPreviousLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetCurrentLevelName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetCurrentLevelName(class FName* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetCurrentLevelName");

	Params::GI_SinglePlayer_C_GetCurrentLevelName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetPreviousLevelName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetPreviousLevelName(class FName* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetPreviousLevelName");

	Params::GI_SinglePlayer_C_GetPreviousLevelName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetLevelCollectionFromPrimaryLevelName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             PrimaryLevelName                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FDataTableRowHandle              Result                                                 (Parm, OutParm, NoDestructor)

void UGI_SinglePlayer_C::GetLevelCollectionFromPrimaryLevelName(class FName PrimaryLevelName, struct FDataTableRowHandle* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetLevelCollectionFromPrimaryLevelName");

	Params::GI_SinglePlayer_C_GetLevelCollectionFromPrimaryLevelName Parms{};

	Parms.PrimaryLevelName = PrimaryLevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetPrimaryStreamingLevel
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ULevelStreaming*                  Level                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetPrimaryStreamingLevel(class ULevelStreaming** Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetPrimaryStreamingLevel");

	Params::GI_SinglePlayer_C_GetPrimaryStreamingLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Level != nullptr)
		*Level = Parms.Level;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetSharedLevelNamesForMapMove
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle              TargetLevelCollection                                  (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// TArray<class FName>                     SharedLevelNames                                       (Parm, OutParm)

void UGI_SinglePlayer_C::GetSharedLevelNamesForMapMove(const struct FDataTableRowHandle& TargetLevelCollection, TArray<class FName>* SharedLevelNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetSharedLevelNamesForMapMove");

	Params::GI_SinglePlayer_C_GetSharedLevelNamesForMapMove Parms{};

	Parms.TargetLevelCollection = std::move(TargetLevelCollection);

	UObject::ProcessEvent(Func, &Parms);

	if (SharedLevelNames != nullptr)
		*SharedLevelNames = std::move(Parms.SharedLevelNames);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetLevelAtmosphereSettings
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_LevelAtmosphereSettings  Settings                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetLevelAtmosphereSettings(class FName LevelName, struct FSTRUCT_LevelAtmosphereSettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetLevelAtmosphereSettings");

	Params::GI_SinglePlayer_C_GetLevelAtmosphereSettings Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Settings != nullptr)
		*Settings = std::move(Parms.Settings);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.CanRespawnOnLevel
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::CanRespawnOnLevel(class FName LevelName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "CanRespawnOnLevel");

	Params::GI_SinglePlayer_C_CanRespawnOnLevel Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasActivatedAnyRespawnChambers
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasActivatedAnyRespawnChambers(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasActivatedAnyRespawnChambers");

	Params::GI_SinglePlayer_C_HasActivatedAnyRespawnChambers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsRespawnChamberActiveForLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsRespawnChamberActiveForLevel(class FName LevelName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsRespawnChamberActiveForLevel");

	Params::GI_SinglePlayer_C_IsRespawnChamberActiveForLevel Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetHackerGender
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// ENUM_HackerGender                       Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetHackerGender(ENUM_HackerGender* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetHackerGender");

	Params::GI_SinglePlayer_C_GetHackerGender Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetLevelInfo
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_LevelInfo                LevelInfo                                              (Parm, OutParm, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::GetLevelInfo(class FName LevelName, struct FSTRUCT_LevelInfo* LevelInfo, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetLevelInfo");

	Params::GI_SinglePlayer_C_GetLevelInfo Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (LevelInfo != nullptr)
		*LevelInfo = std::move(Parms.LevelInfo);

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetSecurityForLevel
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetSecurityForLevel(class FName LevelName, int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetSecurityForLevel");

	Params::GI_SinglePlayer_C_GetSecurityForLevel Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetSecurityForCurrentLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetSecurityForCurrentLevel(int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetSecurityForCurrentLevel");

	Params::GI_SinglePlayer_C_GetSecurityForCurrentLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.StashTransferItemsFromBag
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInventoryBag_C*                  OriginBag                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::StashTransferItemsFromBag(class UInventoryBag_C* OriginBag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "StashTransferItemsFromBag");

	Params::GI_SinglePlayer_C_StashTransferItemsFromBag Parms{};

	Parms.OriginBag = OriginBag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TransferStashedItemsToBag
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInventoryBag_C*                  TargetBag                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::TransferStashedItemsToBag(class UInventoryBag_C* TargetBag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TransferStashedItemsToBag");

	Params::GI_SinglePlayer_C_TransferStashedItemsToBag Parms{};

	Parms.TargetBag = TargetBag;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetComputerNodesForLevel
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Level                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RemainingNodes                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetComputerNodesForLevel(class FName Level, int32* RemainingNodes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetComputerNodesForLevel");

	Params::GI_SinglePlayer_C_GetComputerNodesForLevel Parms{};

	Parms.Level = Level;

	UObject::ProcessEvent(Func, &Parms);

	if (RemainingNodes != nullptr)
		*RemainingNodes = Parms.RemainingNodes;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetComputerNodesForCurrentLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   RemainingNodes                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetComputerNodesForCurrentLevel(int32* RemainingNodes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetComputerNodesForCurrentLevel");

	Params::GI_SinglePlayer_C_GetComputerNodesForCurrentLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (RemainingNodes != nullptr)
		*RemainingNodes = Parms.RemainingNodes;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetCurrentComputerNodes
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetCurrentComputerNodes(int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetCurrentComputerNodes");

	Params::GI_SinglePlayer_C_SetCurrentComputerNodes Parms{};

	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetLevelNames
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     Levels                                                 (Parm, OutParm)

void UGI_SinglePlayer_C::GetLevelNames(TArray<class FName>* Levels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetLevelNames");

	Params::GI_SinglePlayer_C_GetLevelNames Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Levels != nullptr)
		*Levels = std::move(Parms.Levels);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetVisitedLevels
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     VisitedLevels_0                                        (Parm, OutParm)

void UGI_SinglePlayer_C::GetVisitedLevels(TArray<class FName>* VisitedLevels_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetVisitedLevels");

	Params::GI_SinglePlayer_C_GetVisitedLevels Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (VisitedLevels_0 != nullptr)
		*VisitedLevels_0 = std::move(Parms.VisitedLevels_0);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetAutoSaveName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString                           Result                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetAutoSaveName(class FString* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetAutoSaveName");

	Params::GI_SinglePlayer_C_GetAutoSaveName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SaveGameInternal
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SaveName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::SaveGameInternal(const class FString& SaveName, int32 UserIndex, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SaveGameInternal");

	Params::GI_SinglePlayer_C_SaveGameInternal Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AutoSaveWithDelay
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DelayTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AutoSaveWithDelay(float DelayTime, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AutoSaveWithDelay");

	Params::GI_SinglePlayer_C_AutoSaveWithDelay Parms{};

	Parms.DelayTime = DelayTime;
	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ConditionalAutoSave
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::ConditionalAutoSave(int32 UserIndex, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ConditionalAutoSave");

	Params::GI_SinglePlayer_C_ConditionalAutoSave Parms{};

	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AutoSave
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AutoSave(int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AutoSave");

	Params::GI_SinglePlayer_C_AutoSave Parms{};

	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AutoLoad
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AutoLoad(int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AutoLoad");

	Params::GI_SinglePlayer_C_AutoLoad Parms{};

	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.QuickSave
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::QuickSave(int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "QuickSave");

	Params::GI_SinglePlayer_C_QuickSave Parms{};

	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.QuickLoad
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::QuickLoad(int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "QuickLoad");

	Params::GI_SinglePlayer_C_QuickLoad Parms{};

	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ManualLoad
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SaveName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::ManualLoad(const class FString& SaveName, int32 UserIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ManualLoad");

	Params::GI_SinglePlayer_C_ManualLoad Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnPreUnloadLevelByName
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnPreUnloadLevelByName(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnPreUnloadLevelByName");

	Params::GI_SinglePlayer_C_OnPreUnloadLevelByName Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnPostLoadCurrentLevel
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnPostLoadCurrentLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnPostLoadCurrentLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasVisitedLevel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasVisitedLevel(class FName LevelName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasVisitedLevel");

	Params::GI_SinglePlayer_C_HasVisitedLevel Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetVisitedLevelIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetVisitedLevelIndex(class FName LevelName, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetVisitedLevelIndex");

	Params::GI_SinglePlayer_C_GetVisitedLevelIndex Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetLevelNameByDeck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   DeckNumber                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Level                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetLevelNameByDeck(int32 DeckNumber, class FName* Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetLevelNameByDeck");

	Params::GI_SinglePlayer_C_GetLevelNameByDeck Parms{};

	Parms.DeckNumber = DeckNumber;

	UObject::ProcessEvent(Func, &Parms);

	if (Level != nullptr)
		*Level = Parms.Level;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RegisterReinforcementVolume
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AVOLUME_Reinforcements_C*         Volume                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RegisterReinforcementVolume(class AVOLUME_Reinforcements_C* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RegisterReinforcementVolume");

	Params::GI_SinglePlayer_C_RegisterReinforcementVolume Parms{};

	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UnregisterReinforcementVolume
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AVOLUME_Reinforcements_C*         Volume                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UnregisterReinforcementVolume(class AVOLUME_Reinforcements_C* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UnregisterReinforcementVolume");

	Params::GI_SinglePlayer_C_UnregisterReinforcementVolume Parms{};

	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RegisterEnemy
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RegisterEnemy(class APAWN_Enemy_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RegisterEnemy");

	Params::GI_SinglePlayer_C_RegisterEnemy Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UnregisterEnemy
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UnregisterEnemy(class APAWN_Enemy_C* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UnregisterEnemy");

	Params::GI_SinglePlayer_C_UnregisterEnemy Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ModifyEnemyPopulation
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           EnemyClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   PopulationChange                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::ModifyEnemyPopulation(class UClass* EnemyClass, int32 PopulationChange, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ModifyEnemyPopulation");

	Params::GI_SinglePlayer_C_ModifyEnemyPopulation Parms{};

	Parms.EnemyClass = EnemyClass;
	Parms.PopulationChange = PopulationChange;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetReinforcementVolumeBaseClasses
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AVOLUME_Reinforcements_C*         Volume                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<TSoftClassPtr<class UClass>>     BaseClasses                                            (Parm, OutParm)

void UGI_SinglePlayer_C::GetReinforcementVolumeBaseClasses(class AVOLUME_Reinforcements_C* Volume, TArray<TSoftClassPtr<class UClass>>* BaseClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetReinforcementVolumeBaseClasses");

	Params::GI_SinglePlayer_C_GetReinforcementVolumeBaseClasses Parms{};

	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);

	if (BaseClasses != nullptr)
		*BaseClasses = std::move(Parms.BaseClasses);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryPrintDebugReinforcementMessage
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Message                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::TryPrintDebugReinforcementMessage(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryPrintDebugReinforcementMessage");

	Params::GI_SinglePlayer_C_TryPrintDebugReinforcementMessage Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStartReinforcingWithSettings
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSTRUCT_EnemyReinforcementSettingsReinforcementSettings                                  (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// int32                                   PopulationCount                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartTimestamp                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::TryStartReinforcingWithSettings(const struct FSTRUCT_EnemyReinforcementSettings& ReinforcementSettings, int32 PopulationCount, float StartTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStartReinforcingWithSettings");

	Params::GI_SinglePlayer_C_TryStartReinforcingWithSettings Parms{};

	Parms.ReinforcementSettings = std::move(ReinforcementSettings);
	Parms.PopulationCount = PopulationCount;
	Parms.StartTimestamp = StartTimestamp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStartReinforcingOnQuestChanged
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             QuestName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::TryStartReinforcingOnQuestChanged(class FName QuestName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStartReinforcingOnQuestChanged");

	Params::GI_SinglePlayer_C_TryStartReinforcingOnQuestChanged Parms{};

	Parms.QuestName = QuestName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStartReinforcingOnLevelFinishedLoading
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::TryStartReinforcingOnLevelFinishedLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStartReinforcingOnLevelFinishedLoading");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStartRespawnTimerForFirstRespawnEvent
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::TryStartRespawnTimerForFirstRespawnEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStartRespawnTimerForFirstRespawnEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStartRespawnTimer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   RespawnDelay                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::TryStartRespawnTimer(float RespawnDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStartRespawnTimer");

	Params::GI_SinglePlayer_C_TryStartRespawnTimer Parms{};

	Parms.RespawnDelay = RespawnDelay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasStartedRespawningEnemyClass
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             EnemyClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasStartedRespawningEnemyClass(TSoftClassPtr<class UClass> EnemyClass, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasStartedRespawningEnemyClass");

	Params::GI_SinglePlayer_C_HasStartedRespawningEnemyClass Parms{};

	Parms.EnemyClass = EnemyClass;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetReinforcementSettingsFromClassName
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           EnemyClassName                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TSoftClassPtr<class UClass>             Class_0                                                (Parm, OutParm, HasGetValueTypeHash)
// struct FSTRUCT_EnemyReinforcementSettingsSettings                                               (Parm, OutParm, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetReinforcementSettingsFromClassName(const class FString& EnemyClassName, bool* Success, TSoftClassPtr<class UClass>* Class_0, struct FSTRUCT_EnemyReinforcementSettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetReinforcementSettingsFromClassName");

	Params::GI_SinglePlayer_C_GetReinforcementSettingsFromClassName Parms{};

	Parms.EnemyClassName = std::move(EnemyClassName);

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (Class_0 != nullptr)
		*Class_0 = Parms.Class_0;

	if (Settings != nullptr)
		*Settings = std::move(Parms.Settings);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetReinforcementSettingsFromClass
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           EnemyClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FSTRUCT_EnemyReinforcementSettingsSettings                                               (Parm, OutParm, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetReinforcementSettingsFromClass(class UClass* EnemyClass, bool* Success, struct FSTRUCT_EnemyReinforcementSettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetReinforcementSettingsFromClass");

	Params::GI_SinglePlayer_C_GetReinforcementSettingsFromClass Parms{};

	Parms.EnemyClass = EnemyClass;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (Settings != nullptr)
		*Settings = std::move(Parms.Settings);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetRespawnSettingsFromReinforcementSettings
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FSTRUCT_EnemyReinforcementSettingsReinforcementSettings                                  (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FSTRUCT_CurrentReinforcementSettingsRespawnSettings                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetRespawnSettingsFromReinforcementSettings(const struct FSTRUCT_EnemyReinforcementSettings& ReinforcementSettings, struct FSTRUCT_CurrentReinforcementSettings* RespawnSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetRespawnSettingsFromReinforcementSettings");

	Params::GI_SinglePlayer_C_GetRespawnSettingsFromReinforcementSettings Parms{};

	Parms.ReinforcementSettings = std::move(ReinforcementSettings);

	UObject::ProcessEvent(Func, &Parms);

	if (RespawnSettings != nullptr)
		*RespawnSettings = std::move(Parms.RespawnSettings);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetReinforceClassNameFromClass
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSoftClassPtr<class UClass>             Class_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class FString                           ClassName                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetReinforceClassNameFromClass(TSoftClassPtr<class UClass> Class_0, class FString* ClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetReinforceClassNameFromClass");

	Params::GI_SinglePlayer_C_GetReinforceClassNameFromClass Parms{};

	Parms.Class_0 = Class_0;

	UObject::ProcessEvent(Func, &Parms);

	if (ClassName != nullptr)
		*ClassName = std::move(Parms.ClassName);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnRespawnDelayElapsed
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnRespawnDelayElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnRespawnDelayElapsed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsStreamingLevels
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsStreamingLevels(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsStreamingLevels");

	Params::GI_SinglePlayer_C_IsStreamingLevels Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OpenPersistentMapByType
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_MapType                            LevelType                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OpenPersistentMapByType(ENUM_MapType LevelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OpenPersistentMapByType");

	Params::GI_SinglePlayer_C_OpenPersistentMapByType Parms{};

	Parms.LevelType = LevelType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnBeginLoadingLevelCollectionInternal
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnBeginLoadingLevelCollectionInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnBeginLoadingLevelCollectionInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFinishedLoadingLevelCollectionInternal
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnFinishedLoadingLevelCollectionInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFinishedLoadingLevelCollectionInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnBeginUnloadingLevelCollectionInternal
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnBeginUnloadingLevelCollectionInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnBeginUnloadingLevelCollectionInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetRespawnDataIndexForLevel
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   LevelDataIndex                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetRespawnDataIndexForLevel(class FName LevelName, int32* LevelDataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetRespawnDataIndexForLevel");

	Params::GI_SinglePlayer_C_GetRespawnDataIndexForLevel Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (LevelDataIndex != nullptr)
		*LevelDataIndex = Parms.LevelDataIndex;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SpawnEnemyReinforcementsByType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftClassPtr<class UClass>             EnemyClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// int32                                   SpawnCount                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RequireAmbush                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   CountSpawned                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SpawnEnemyReinforcementsByType(TSoftClassPtr<class UClass> EnemyClass, int32 SpawnCount, bool RequireAmbush, int32* CountSpawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SpawnEnemyReinforcementsByType");

	Params::GI_SinglePlayer_C_SpawnEnemyReinforcementsByType Parms{};

	Parms.EnemyClass = EnemyClass;
	Parms.SpawnCount = SpawnCount;
	Parms.RequireAmbush = RequireAmbush;

	UObject::ProcessEvent(Func, &Parms);

	if (CountSpawned != nullptr)
		*CountSpawned = Parms.CountSpawned;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RequestNewSpawnedEnemyID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewID                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RequestNewSpawnedEnemyID(int32* NewID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RequestNewSpawnedEnemyID");

	Params::GI_SinglePlayer_C_RequestNewSpawnedEnemyID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewID != nullptr)
		*NewID = Parms.NewID;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RequestNewSpawnedEnemyName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           EnemyClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             EnemyName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RequestNewSpawnedEnemyName(class UClass* EnemyClass, class FName* EnemyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RequestNewSpawnedEnemyName");

	Params::GI_SinglePlayer_C_RequestNewSpawnedEnemyName Parms{};

	Parms.EnemyClass = EnemyClass;

	UObject::ProcessEvent(Func, &Parms);

	if (EnemyName != nullptr)
		*EnemyName = Parms.EnemyName;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RegisterPatrolNode
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APatrolNode_C*                    PatrolNode                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RegisterPatrolNode(class APatrolNode_C* PatrolNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RegisterPatrolNode");

	Params::GI_SinglePlayer_C_RegisterPatrolNode Parms{};

	Parms.PatrolNode = PatrolNode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UnregisterPatrolNode
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APatrolNode_C*                    PatrolNode                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UnregisterPatrolNode(class APatrolNode_C* PatrolNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UnregisterPatrolNode");

	Params::GI_SinglePlayer_C_UnregisterPatrolNode Parms{};

	Parms.PatrolNode = PatrolNode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnFinishedUnloadingLevelCollectionInternal
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnFinishedUnloadingLevelCollectionInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnFinishedUnloadingLevelCollectionInternal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.InitMusicSystemSettings
// (Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPDA_MusicSystemSettings_C*       MusicSystemSettings                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::InitMusicSystemSettings(class UPDA_MusicSystemSettings_C* MusicSystemSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "InitMusicSystemSettings");

	Params::GI_SinglePlayer_C_InitMusicSystemSettings Parms{};

	Parms.MusicSystemSettings = MusicSystemSettings;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.PlayStoryMusic
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSTRUCT_MusicParams              MusicParams                                            (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UBP_MusicCue_C*                   MusicCue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::PlayStoryMusic(const struct FSTRUCT_MusicParams& MusicParams, class UBP_MusicCue_C** MusicCue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "PlayStoryMusic");

	Params::GI_SinglePlayer_C_PlayStoryMusic Parms{};

	Parms.MusicParams = std::move(MusicParams);

	UObject::ProcessEvent(Func, &Parms);

	if (MusicCue != nullptr)
		*MusicCue = Parms.MusicCue;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.StopStoryMusic
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::StopStoryMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "StopStoryMusic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.PlayMusicInternal
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSTRUCT_MusicParams              NewMusicParams                                         (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UBP_MusicCue_C*                   MusicCue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::PlayMusicInternal(const struct FSTRUCT_MusicParams& NewMusicParams, class UBP_MusicCue_C** MusicCue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "PlayMusicInternal");

	Params::GI_SinglePlayer_C_PlayMusicInternal Parms{};

	Parms.NewMusicParams = std::move(NewMusicParams);

	UObject::ProcessEvent(Func, &Parms);

	if (MusicCue != nullptr)
		*MusicCue = Parms.MusicCue;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryInterruptCurrentMusic
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           NewMusicClass                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryInterruptCurrentMusic(class UClass* NewMusicClass, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryInterruptCurrentMusic");

	Params::GI_SinglePlayer_C_TryInterruptCurrentMusic Parms{};

	Parms.NewMusicClass = NewMusicClass;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryUpdateExplorationMusic
// (Protected, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::TryUpdateExplorationMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryUpdateExplorationMusic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnMusicStateUpdated
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSTRUCT_MusicParams              ExplicitMusicAssignment                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UBP_MusicCue_C*                   MusicCue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnMusicStateUpdated(const struct FSTRUCT_MusicParams& ExplicitMusicAssignment, class UBP_MusicCue_C** MusicCue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnMusicStateUpdated");

	Params::GI_SinglePlayer_C_OnMusicStateUpdated Parms{};

	Parms.ExplicitMusicAssignment = std::move(ExplicitMusicAssignment);

	UObject::ProcessEvent(Func, &Parms);

	if (MusicCue != nullptr)
		*MusicCue = Parms.MusicCue;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TickMusic
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::TickMusic(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TickMusic");

	Params::GI_SinglePlayer_C_TickMusic Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetGameplayMusicState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EGameplayState                          Gameplay_State                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetGameplayMusicState(EGameplayState Gameplay_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetGameplayMusicState");

	Params::GI_SinglePlayer_C_SetGameplayMusicState Parms{};

	Parms.Gameplay_State = Gameplay_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetInGameMusicState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EInGameState                            In_Game_State                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetInGameMusicState(EInGameState In_Game_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetInGameMusicState");

	Params::GI_SinglePlayer_C_SetInGameMusicState Parms{};

	Parms.In_Game_State = In_Game_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetAmbienceMusicState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ExplorationState                        NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetAmbienceMusicState(ExplorationState* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetAmbienceMusicState");

	Params::GI_SinglePlayer_C_GetAmbienceMusicState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetAmbienceMusicState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ExplorationState                        In_Game_State                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetAmbienceMusicState(ExplorationState In_Game_State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetAmbienceMusicState");

	Params::GI_SinglePlayer_C_SetAmbienceMusicState Parms{};

	Parms.In_Game_State = In_Game_State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.InitializeShockSettings
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACON_Hacker_C*                    HackerController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::InitializeShockSettings(class ACON_Hacker_C* HackerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "InitializeShockSettings");

	Params::GI_SinglePlayer_C_InitializeShockSettings Parms{};

	Parms.HackerController = HackerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetDefaultDifficultyValues
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_GameDifficulty                     Combat                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Mission                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Puzzle                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Cyber                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetDefaultDifficultyValues(ENUM_GameDifficulty Combat, ENUM_GameDifficulty Mission, ENUM_GameDifficulty Puzzle, ENUM_GameDifficulty Cyber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetDefaultDifficultyValues");

	Params::GI_SinglePlayer_C_SetDefaultDifficultyValues Parms{};

	Parms.Combat = Combat;
	Parms.Mission = Mission;
	Parms.Puzzle = Puzzle;
	Parms.Cyber = Cyber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetDifficultyValues
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_GameDifficulty                     Combat                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Mission                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Puzzle                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Cyber                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetDifficultyValues(ENUM_GameDifficulty Combat, ENUM_GameDifficulty Mission, ENUM_GameDifficulty Puzzle, ENUM_GameDifficulty Cyber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetDifficultyValues");

	Params::GI_SinglePlayer_C_SetDifficultyValues Parms{};

	Parms.Combat = Combat;
	Parms.Mission = Mission;
	Parms.Puzzle = Puzzle;
	Parms.Cyber = Cyber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetDifficultyValues
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_GameDifficulty                     Combat                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Mission                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Puzzle                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Cyber                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetDifficultyValues(ENUM_GameDifficulty* Combat, ENUM_GameDifficulty* Mission, ENUM_GameDifficulty* Puzzle, ENUM_GameDifficulty* Cyber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetDifficultyValues");

	Params::GI_SinglePlayer_C_GetDifficultyValues Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Combat != nullptr)
		*Combat = Parms.Combat;

	if (Mission != nullptr)
		*Mission = Parms.Mission;

	if (Puzzle != nullptr)
		*Puzzle = Parms.Puzzle;

	if (Cyber != nullptr)
		*Cyber = Parms.Cyber;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetDifficultyByType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// ENUM_GameDifficultyConfigCategory       Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_GameDifficulty                     Difficulty                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetDifficultyByType(ENUM_GameDifficultyConfigCategory Type, ENUM_GameDifficulty* Difficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetDifficultyByType");

	Params::GI_SinglePlayer_C_GetDifficultyByType Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);

	if (Difficulty != nullptr)
		*Difficulty = Parms.Difficulty;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetCombatDifficultySettings
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FSTRUCT_CombatDifficultySettings Settings                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetCombatDifficultySettings(struct FSTRUCT_CombatDifficultySettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetCombatDifficultySettings");

	Params::GI_SinglePlayer_C_GetCombatDifficultySettings Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Settings != nullptr)
		*Settings = std::move(Parms.Settings);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetMissionDifficultySettings
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FSTRUCT_MissionDifficultySettingsSettings                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetMissionDifficultySettings(struct FSTRUCT_MissionDifficultySettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetMissionDifficultySettings");

	Params::GI_SinglePlayer_C_GetMissionDifficultySettings Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Settings != nullptr)
		*Settings = std::move(Parms.Settings);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetVolume
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Volume                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_VolumeType                         Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetVolume(float Volume, ENUM_VolumeType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetVolume");

	Params::GI_SinglePlayer_C_SetVolume Parms{};

	Parms.Volume = Volume;
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetVolumeInternal
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Volume                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_VolumeType                         Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetVolumeInternal(float Volume, ENUM_VolumeType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetVolumeInternal");

	Params::GI_SinglePlayer_C_SetVolumeInternal Parms{};

	Parms.Volume = Volume;
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.LogSaveShockSettingsFailed
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::LogSaveShockSettingsFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "LogSaveShockSettingsFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.LoadShockSettings
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USAVE_Settings_C*                 Settings                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::LoadShockSettings(int32 UserIndex, class USAVE_Settings_C** Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "LoadShockSettings");

	Params::GI_SinglePlayer_C_LoadShockSettings Parms{};

	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Settings != nullptr)
		*Settings = Parms.Settings;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SaveShockSettings
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USAVE_Settings_C*                 Settings                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::SaveShockSettings(class USAVE_Settings_C* Settings, int32 UserIndex, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SaveShockSettings");

	Params::GI_SinglePlayer_C_SaveShockSettings Parms{};

	Parms.Settings = Settings;
	Parms.UserIndex = UserIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetMusicState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMenuState                              MenuState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EInGameState                            GameState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EGameplayState                          GameplayState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_MusicParams              ExplicitAudioAssignment                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UBP_MusicCue_C*                   MusicCue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetMusicState(EMenuState MenuState, EInGameState GameState, EGameplayState GameplayState, const struct FSTRUCT_MusicParams& ExplicitAudioAssignment, class UBP_MusicCue_C** MusicCue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetMusicState");

	Params::GI_SinglePlayer_C_SetMusicState Parms{};

	Parms.MenuState = MenuState;
	Parms.GameState = GameState;
	Parms.GameplayState = GameplayState;
	Parms.ExplicitAudioAssignment = std::move(ExplicitAudioAssignment);

	UObject::ProcessEvent(Func, &Parms);

	if (MusicCue != nullptr)
		*MusicCue = Parms.MusicCue;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.EVENT_OnMusicFinished
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_MusicCue_C*                   MusicCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::EVENT_OnMusicFinished(class UBP_MusicCue_C* MusicCue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "EVENT_OnMusicFinished");

	Params::GI_SinglePlayer_C_EVENT_OnMusicFinished Parms{};

	Parms.MusicCue = MusicCue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetMusicLevelOverride
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::SetMusicLevelOverride(class FName LevelName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetMusicLevelOverride");

	Params::GI_SinglePlayer_C_SetMusicLevelOverride Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsMusicInState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EMenuState                              MenuState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EInGameState                            GameState                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EGameplayState                          GameplayState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsMusicInState(EMenuState MenuState, EInGameState GameState, EGameplayState GameplayState, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsMusicInState");

	Params::GI_SinglePlayer_C_IsMusicInState Parms{};

	Parms.MenuState = MenuState;
	Parms.GameState = GameState;
	Parms.GameplayState = GameplayState;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ApplyDefaultUserSettings
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::ApplyDefaultUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ApplyDefaultUserSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryGenerateDestructCode
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryGenerateDestructCode(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryGenerateDestructCode");

	Params::GI_SinglePlayer_C_TryGenerateDestructCode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryGenerateStoryKeycodes
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryGenerateStoryKeycodes(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryGenerateStoryKeycodes");

	Params::GI_SinglePlayer_C_TryGenerateStoryKeycodes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetDestructionCode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Code                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetDestructionCode(int32* Code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetDestructionCode");

	Params::GI_SinglePlayer_C_GetDestructionCode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Code != nullptr)
		*Code = Parms.Code;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetDestructionCodeDigitForCurrentLevel
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetDestructionCodeDigitForCurrentLevel(int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetDestructionCodeDigitForCurrentLevel");

	Params::GI_SinglePlayer_C_GetDestructionCodeDigitForCurrentLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetDestructionCodeDigitByIndex
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Digit                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetDestructionCodeDigitByIndex(int32 Index_0, int32* Digit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetDestructionCodeDigitByIndex");

	Params::GI_SinglePlayer_C_GetDestructionCodeDigitByIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Digit != nullptr)
		*Digit = Parms.Digit;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RegisterGroupedTrap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATRAP_Trigger_C*                  Trap                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RegisterGroupedTrap(class ATRAP_Trigger_C* Trap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RegisterGroupedTrap");

	Params::GI_SinglePlayer_C_RegisterGroupedTrap Parms{};

	Parms.Trap = Trap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UnregisterGroupedTrap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATRAP_Trigger_C*                  Trap                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UnregisterGroupedTrap(class ATRAP_Trigger_C* Trap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UnregisterGroupedTrap");

	Params::GI_SinglePlayer_C_UnregisterGroupedTrap Parms{};

	Parms.Trap = Trap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.DismantleTrapsInGroup
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATRAP_Trigger_C*                  Trap                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::DismantleTrapsInGroup(class ATRAP_Trigger_C* Trap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "DismantleTrapsInGroup");

	Params::GI_SinglePlayer_C_DismantleTrapsInGroup Parms{};

	Parms.Trap = Trap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsPatrolPathInUse
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APatrolNode_C*                    PatrolNode                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsPatrolPathInUse(class APatrolNode_C* PatrolNode, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsPatrolPathInUse");

	Params::GI_SinglePlayer_C_IsPatrolPathInUse Parms{};

	Parms.PatrolNode = PatrolNode;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetUniqueRandomKeycode
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Tag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Keycode                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetUniqueRandomKeycode(class FName Tag, int32* Keycode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetUniqueRandomKeycode");

	Params::GI_SinglePlayer_C_GetUniqueRandomKeycode Parms{};

	Parms.Tag = Tag;

	UObject::ProcessEvent(Func, &Parms);

	if (Keycode != nullptr)
		*Keycode = Parms.Keycode;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnNewGameStarted
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UGI_SinglePlayer_C::OnNewGameStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnNewGameStarted");

	Params::GI_SinglePlayer_C_OnNewGameStarted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AddPickupToPendingLostList
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APICKUP_Base_C*                   Pickup                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AddPickupToPendingLostList(class APICKUP_Base_C* Pickup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AddPickupToPendingLostList");

	Params::GI_SinglePlayer_C_AddPickupToPendingLostList Parms{};

	Parms.Pickup = Pickup;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AddInventoryToPendingLostList
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCOMP_Inventory_C*                Inventory                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AddInventoryToPendingLostList(class UCOMP_Inventory_C* Inventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AddInventoryToPendingLostList");

	Params::GI_SinglePlayer_C_AddInventoryToPendingLostList Parms{};

	Parms.Inventory = Inventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryMergeLostItemsToBag
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInventoryBag_C*                  Bag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnlyPendingItems                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryMergeLostItemsToBag(class UInventoryBag_C* Bag, bool OnlyPendingItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryMergeLostItemsToBag");

	Params::GI_SinglePlayer_C_TryMergeLostItemsToBag Parms{};

	Parms.Bag = Bag;
	Parms.OnlyPendingItems = OnlyPendingItems;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.CopySharedItemsToBag
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInventoryBag_C*                  Bag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_SharedBagType                      Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::CopySharedItemsToBag(class UInventoryBag_C* Bag, ENUM_SharedBagType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "CopySharedItemsToBag");

	Params::GI_SinglePlayer_C_CopySharedItemsToBag Parms{};

	Parms.Bag = Bag;
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.CopySharedItemsFromBag
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInventoryBag_C*                  Bag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_SharedBagType                      Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::CopySharedItemsFromBag(class UInventoryBag_C* Bag, ENUM_SharedBagType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "CopySharedItemsFromBag");

	Params::GI_SinglePlayer_C_CopySharedItemsFromBag Parms{};

	Parms.Bag = Bag;
	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetSharedStorageLevelName
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetSharedStorageLevelName(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetSharedStorageLevelName");

	Params::GI_SinglePlayer_C_SetSharedStorageLevelName Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetSharedStorageLevelName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetSharedStorageLevelName(class FName* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetSharedStorageLevelName");

	Params::GI_SinglePlayer_C_GetSharedStorageLevelName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetItemGridRenderTarget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UITEM_Base_C*                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTextureRenderTarget2D*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetItemGridRenderTarget(class UITEM_Base_C* Item, class UTextureRenderTarget2D** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetItemGridRenderTarget");

	Params::GI_SinglePlayer_C_GetItemGridRenderTarget Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetItemHotbarRenderTarget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UITEM_Base_C*                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTextureRenderTarget2D*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetItemHotbarRenderTarget(class UITEM_Base_C* Item, class UTextureRenderTarget2D** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetItemHotbarRenderTarget");

	Params::GI_SinglePlayer_C_GetItemHotbarRenderTarget Parms{};

	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetItemHotbarRenderTargetForItemClass
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UClass*                           ItemClass                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTextureRenderTarget2D*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetItemHotbarRenderTargetForItemClass(class UClass* ItemClass, class UTextureRenderTarget2D** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetItemHotbarRenderTargetForItemClass");

	Params::GI_SinglePlayer_C_GetItemHotbarRenderTargetForItemClass Parms{};

	Parms.ItemClass = ItemClass;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetItemHotbarRenderTargetForPickupClass
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FObjectClassCollection           ClassCollection                                        (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UTextureRenderTarget2D*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetItemHotbarRenderTargetForPickupClass(const struct FObjectClassCollection& ClassCollection, class UTextureRenderTarget2D** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetItemHotbarRenderTargetForPickupClass");

	Params::GI_SinglePlayer_C_GetItemHotbarRenderTargetForPickupClass Parms{};

	Parms.ClassCollection = std::move(ClassCollection);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryCreateItemCaptureWorld
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::TryCreateItemCaptureWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryCreateItemCaptureWorld");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UpdateItemDetailsRenderTarget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UITEM_Base_C*                     Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Progress                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_ItemDetailsIconParams    CustomIconParams                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTextureRenderTarget2D*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_ItemDetailsIconParams    IconParams                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UpdateItemDetailsRenderTarget(class UITEM_Base_C* Item, float Progress, const struct FSTRUCT_ItemDetailsIconParams& CustomIconParams, class UTextureRenderTarget2D** Result, struct FSTRUCT_ItemDetailsIconParams* IconParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UpdateItemDetailsRenderTarget");

	Params::GI_SinglePlayer_C_UpdateItemDetailsRenderTarget Parms{};

	Parms.Item = Item;
	Parms.Progress = Progress;
	Parms.CustomIconParams = std::move(CustomIconParams);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (IconParams != nullptr)
		*IconParams = std::move(Parms.IconParams);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UpdateItemDetailsPickupActor
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FObjectClassCollection           IconClassCollection                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UpdateItemDetailsPickupActor(const struct FObjectClassCollection& IconClassCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UpdateItemDetailsPickupActor");

	Params::GI_SinglePlayer_C_UpdateItemDetailsPickupActor Parms{};

	Parms.IconClassCollection = std::move(IconClassCollection);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UpdateItemIconPickupActor
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FObjectClassCollection           IconClassCollection                                    (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    IsFullyLoaded                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::UpdateItemIconPickupActor(const struct FObjectClassCollection& IconClassCollection, bool* IsFullyLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UpdateItemIconPickupActor");

	Params::GI_SinglePlayer_C_UpdateItemIconPickupActor Parms{};

	Parms.IconClassCollection = std::move(IconClassCollection);

	UObject::ProcessEvent(Func, &Parms);

	if (IsFullyLoaded != nullptr)
		*IsFullyLoaded = Parms.IsFullyLoaded;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ClearLastItemIconPickupActor
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::ClearLastItemIconPickupActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ClearLastItemIconPickupActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AddPendingGridIconActor
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APICKUP_Base_C*                   PickupActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AddPendingGridIconActor(class APICKUP_Base_C* PickupActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AddPendingGridIconActor");

	Params::GI_SinglePlayer_C_AddPendingGridIconActor Parms{};

	Parms.PickupActor = PickupActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnUpdatePendingPickupIcons
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnUpdatePendingPickupIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnUpdatePendingPickupIcons");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsInMusicGameplayState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// EGameplayState                          GameplayState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsInMusicGameplayState(EGameplayState GameplayState, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsInMusicGameplayState");

	Params::GI_SinglePlayer_C_IsInMusicGameplayState Parms{};

	Parms.GameplayState = GameplayState;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryFadeInStoppedMusicByClass
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass*                           MusicCueClass                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryFadeInStoppedMusicByClass(class UClass* MusicCueClass, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryFadeInStoppedMusicByClass");

	Params::GI_SinglePlayer_C_TryFadeInStoppedMusicByClass Parms{};

	Parms.MusicCueClass = MusicCueClass;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ForceStopMusic
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::ForceStopMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ForceStopMusic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ResetSavedData
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::ResetSavedData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ResetSavedData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnLevelRegionDiscovered
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              RegionRowHandle                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void UGI_SinglePlayer_C::OnLevelRegionDiscovered(const struct FDataTableRowHandle& RegionRowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnLevelRegionDiscovered");

	Params::GI_SinglePlayer_C_OnLevelRegionDiscovered Parms{};

	Parms.RegionRowHandle = std::move(RegionRowHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.EVENT_OnIntensityDecayTimer
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::EVENT_OnIntensityDecayTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "EVENT_OnIntensityDecayTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnVoxelColumnsRevealed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   VoxelColumnCount                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnVoxelColumnsRevealed(int32 VoxelColumnCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnVoxelColumnsRevealed");

	Params::GI_SinglePlayer_C_OnVoxelColumnsRevealed Parms{};

	Parms.VoxelColumnCount = VoxelColumnCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetCurrentExploreIntensity
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Intensity                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetCurrentExploreIntensity(float Intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetCurrentExploreIntensity");

	Params::GI_SinglePlayer_C_SetCurrentExploreIntensity Parms{};

	Parms.Intensity = Intensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsTryingToPlaySystemOnComponentAsync
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UFXSystemComponent*               SystemComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsTryingToPlaySystemOnComponentAsync(class UFXSystemComponent* SystemComponent, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsTryingToPlaySystemOnComponentAsync");

	Params::GI_SinglePlayer_C_IsTryingToPlaySystemOnComponentAsync Parms{};

	Parms.SystemComponent = SystemComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsTryingToAttachToSceneComponentAsync
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsTryingToAttachToSceneComponentAsync(class USceneComponent* SceneComponent, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsTryingToAttachToSceneComponentAsync");

	Params::GI_SinglePlayer_C_IsTryingToAttachToSceneComponentAsync Parms{};

	Parms.SceneComponent = SceneComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryIncrementSystemComponentRefCount
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFXSystemComponent*               SystemComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryIncrementSystemComponentRefCount(class UFXSystemComponent* SystemComponent, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryIncrementSystemComponentRefCount");

	Params::GI_SinglePlayer_C_TryIncrementSystemComponentRefCount Parms{};

	Parms.SystemComponent = SystemComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryDecrementSystemComponentRefCount
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFXSystemComponent*               SystemComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryDecrementSystemComponentRefCount(class UFXSystemComponent* SystemComponent, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryDecrementSystemComponentRefCount");

	Params::GI_SinglePlayer_C_TryDecrementSystemComponentRefCount Parms{};

	Parms.SystemComponent = SystemComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryIncrementSceneComponentRefCount
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryIncrementSceneComponentRefCount(class USceneComponent* SceneComponent, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryIncrementSceneComponentRefCount");

	Params::GI_SinglePlayer_C_TryIncrementSceneComponentRefCount Parms{};

	Parms.SceneComponent = SceneComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryDecrementSceneComponentRefCount
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryDecrementSceneComponentRefCount(class USceneComponent* SceneComponent, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryDecrementSceneComponentRefCount");

	Params::GI_SinglePlayer_C_TryDecrementSceneComponentRefCount Parms{};

	Parms.SceneComponent = SceneComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.PlaySystemUsingAsyncParams
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFXSystemAsset*                   System                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_AsyncParticleParams      SystemParams                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UGI_SinglePlayer_C::PlaySystemUsingAsyncParams(class UFXSystemAsset* System, struct FSTRUCT_AsyncParticleParams& SystemParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "PlaySystemUsingAsyncParams");

	Params::GI_SinglePlayer_C_PlaySystemUsingAsyncParams Parms{};

	Parms.System = System;
	Parms.SystemParams = std::move(SystemParams);

	UObject::ProcessEvent(Func, &Parms);

	SystemParams = std::move(Parms.SystemParams);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AddAsyncSystemParamsToQueue
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UFXSystemAsset>    System                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FSTRUCT_AsyncParticleParams      SystemParams                                           (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AddAsyncSystemParamsToQueue(TSoftObjectPtr<class UFXSystemAsset> System, const struct FSTRUCT_AsyncParticleParams& SystemParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AddAsyncSystemParamsToQueue");

	Params::GI_SinglePlayer_C_AddAsyncSystemParamsToQueue Parms{};

	Parms.System = System;
	Parms.SystemParams = std::move(SystemParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RemoveAsyncSystemParamsFromQueue
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UFXSystemAsset>    System                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FSTRUCT_AsyncParticleParams      SystemParams                                           (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RemoveAsyncSystemParamsFromQueue(TSoftObjectPtr<class UFXSystemAsset> System, bool* Success, struct FSTRUCT_AsyncParticleParams* SystemParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RemoveAsyncSystemParamsFromQueue");

	Params::GI_SinglePlayer_C_RemoveAsyncSystemParamsFromQueue Parms{};

	Parms.System = System;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (SystemParams != nullptr)
		*SystemParams = std::move(Parms.SystemParams);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.PlaySoundUsingAsyncParams
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundCue*                        SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_AsyncSoundParams         SoundParams                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)

void UGI_SinglePlayer_C::PlaySoundUsingAsyncParams(class USoundCue* SoundCue, struct FSTRUCT_AsyncSoundParams& SoundParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "PlaySoundUsingAsyncParams");

	Params::GI_SinglePlayer_C_PlaySoundUsingAsyncParams Parms{};

	Parms.SoundCue = SoundCue;
	Parms.SoundParams = std::move(SoundParams);

	UObject::ProcessEvent(Func, &Parms);

	SoundParams = std::move(Parms.SoundParams);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AddAsyncSoundParamsToQueue
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FSTRUCT_AsyncSoundParams         SoundParams                                            (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AddAsyncSoundParamsToQueue(TSoftObjectPtr<class USoundCue> SoundCue, const struct FSTRUCT_AsyncSoundParams& SoundParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AddAsyncSoundParamsToQueue");

	Params::GI_SinglePlayer_C_AddAsyncSoundParamsToQueue Parms{};

	Parms.SoundCue = SoundCue;
	Parms.SoundParams = std::move(SoundParams);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RemoveAsyncSoundParamsFromQueue
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FSTRUCT_AsyncSoundParams         SoundParams                                            (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RemoveAsyncSoundParamsFromQueue(TSoftObjectPtr<class USoundCue> SoundCue, struct FSTRUCT_AsyncSoundParams* SoundParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RemoveAsyncSoundParamsFromQueue");

	Params::GI_SinglePlayer_C_RemoveAsyncSoundParamsFromQueue Parms{};

	Parms.SoundCue = SoundCue;

	UObject::ProcessEvent(Func, &Parms);

	if (SoundParams != nullptr)
		*SoundParams = std::move(Parms.SoundParams);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UpdateLevelAtmosphere
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_LevelAtmosphereSettings  SourceAtmosphereSettings                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSTRUCT_LevelAtmosphereSettings  TargetAtmosphereSettings                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UpdateLevelAtmosphere(float Progress, const struct FSTRUCT_LevelAtmosphereSettings& SourceAtmosphereSettings, const struct FSTRUCT_LevelAtmosphereSettings& TargetAtmosphereSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UpdateLevelAtmosphere");

	Params::GI_SinglePlayer_C_UpdateLevelAtmosphere Parms{};

	Parms.Progress = Progress;
	Parms.SourceAtmosphereSettings = std::move(SourceAtmosphereSettings);
	Parms.TargetAtmosphereSettings = std::move(TargetAtmosphereSettings);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UpdateLevelAtmosphereToCurrent
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::UpdateLevelAtmosphereToCurrent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UpdateLevelAtmosphereToCurrent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetRespawnChamberLevelFromDeckSymbol
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString                           DeckSymbol                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class FName                             LevelName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetRespawnChamberLevelFromDeckSymbol(const class FString& DeckSymbol, class FName* LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetRespawnChamberLevelFromDeckSymbol");

	Params::GI_SinglePlayer_C_GetRespawnChamberLevelFromDeckSymbol Parms{};

	Parms.DeckSymbol = std::move(DeckSymbol);

	UObject::ProcessEvent(Func, &Parms);

	if (LevelName != nullptr)
		*LevelName = Parms.LevelName;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetRespawnChamberLevelFromLevelName
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             QueryLevelName                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             RespawnLevelName                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetRespawnChamberLevelFromLevelName(class FName QueryLevelName, class FName* RespawnLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetRespawnChamberLevelFromLevelName");

	Params::GI_SinglePlayer_C_GetRespawnChamberLevelFromLevelName Parms{};

	Parms.QueryLevelName = QueryLevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (RespawnLevelName != nullptr)
		*RespawnLevelName = Parms.RespawnLevelName;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetBestRespawnChamberLevel
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             LevelName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetBestRespawnChamberLevel(class FName* LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetBestRespawnChamberLevel");

	Params::GI_SinglePlayer_C_GetBestRespawnChamberLevel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (LevelName != nullptr)
		*LevelName = Parms.LevelName;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ActivateRespawnChamberOnLevel
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::ActivateRespawnChamberOnLevel(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ActivateRespawnChamberOnLevel");

	Params::GI_SinglePlayer_C_ActivateRespawnChamberOnLevel Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.DeactivateRespawnChamberOnLevel
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::DeactivateRespawnChamberOnLevel(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "DeactivateRespawnChamberOnLevel");

	Params::GI_SinglePlayer_C_DeactivateRespawnChamberOnLevel Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryUpdateCurrentSubLevelName
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryUpdateCurrentSubLevelName(class FName LevelName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryUpdateCurrentSubLevelName");

	Params::GI_SinglePlayer_C_TryUpdateCurrentSubLevelName Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryCreateLevelLoadingScreenWidget
// (Protected, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::TryCreateLevelLoadingScreenWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryCreateLevelLoadingScreenWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryDestroyLevelLoadingScreenWidget
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::TryDestroyLevelLoadingScreenWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryDestroyLevelLoadingScreenWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ResetTransientData
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::ResetTransientData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ResetTransientData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RegisterLowFiBehaviorEnemy
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::RegisterLowFiBehaviorEnemy(class APAWN_Enemy_C* Enemy, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RegisterLowFiBehaviorEnemy");

	Params::GI_SinglePlayer_C_RegisterLowFiBehaviorEnemy Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UnregisterLowFiBehaviorEnemy
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::UnregisterLowFiBehaviorEnemy(class APAWN_Enemy_C* Enemy, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UnregisterLowFiBehaviorEnemy");

	Params::GI_SinglePlayer_C_UnregisterLowFiBehaviorEnemy Parms{};

	Parms.Enemy = Enemy;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryPrintDebugLowFiBehaviorMessage
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Message                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::TryPrintDebugLowFiBehaviorMessage(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryPrintDebugLowFiBehaviorMessage");

	Params::GI_SinglePlayer_C_TryPrintDebugLowFiBehaviorMessage Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryDrawLowFiBehaviorDebugBox
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          MovementVector                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::TryDrawLowFiBehaviorDebugBox(class APAWN_Enemy_C* Enemy, const struct FLinearColor& Color, const struct FVector& MovementVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryDrawLowFiBehaviorDebugBox");

	Params::GI_SinglePlayer_C_TryDrawLowFiBehaviorDebugBox Parms{};

	Parms.Enemy = Enemy;
	Parms.Color = std::move(Color);
	Parms.MovementVector = std::move(MovementVector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStartLowBehaviorTicks
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryStartLowBehaviorTicks(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStartLowBehaviorTicks");

	Params::GI_SinglePlayer_C_TryStartLowBehaviorTicks Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStopLowBehaviorTicks
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryStopLowBehaviorTicks(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStopLowBehaviorTicks");

	Params::GI_SinglePlayer_C_TryStopLowBehaviorTicks Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnTickNextLowFiBehaviorEnemy
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnTickNextLowFiBehaviorEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnTickNextLowFiBehaviorEnemy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.PerformLowFiBehaviorForEnemy
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    CurrentEnemy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TargetLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         TargetRotation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   ElapsedTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WaitTime                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AcceptanceRadius                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APAWN_Enemy_C*                    DeadEnemy                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::PerformLowFiBehaviorForEnemy(class APAWN_Enemy_C* CurrentEnemy, const struct FVector& TargetLocation, const struct FRotator& TargetRotation, float ElapsedTime, float WaitTime, float AcceptanceRadius, class APAWN_Enemy_C* DeadEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "PerformLowFiBehaviorForEnemy");

	Params::GI_SinglePlayer_C_PerformLowFiBehaviorForEnemy Parms{};

	Parms.CurrentEnemy = CurrentEnemy;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.TargetRotation = std::move(TargetRotation);
	Parms.ElapsedTime = ElapsedTime;
	Parms.WaitTime = WaitTime;
	Parms.AcceptanceRadius = AcceptanceRadius;
	Parms.DeadEnemy = DeadEnemy;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ValidateCurrentLowFiState
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::ValidateCurrentLowFiState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ValidateCurrentLowFiState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetCurrentExploreIntensity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Intensity                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetCurrentExploreIntensity(float* Intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetCurrentExploreIntensity");

	Params::GI_SinglePlayer_C_GetCurrentExploreIntensity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Intensity != nullptr)
		*Intensity = Parms.Intensity;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasCompletedAchievement
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             AchievementName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasCompletedAchievement(class FName AchievementName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasCompletedAchievement");

	Params::GI_SinglePlayer_C_HasCompletedAchievement Parms{};

	Parms.AchievementName = AchievementName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasCompletedAllAchievements
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             IgnoreAchievementName                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasCompletedAllAchievements(class FName IgnoreAchievementName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasCompletedAllAchievements");

	Params::GI_SinglePlayer_C_HasCompletedAllAchievements Parms{};

	Parms.IgnoreAchievementName = IgnoreAchievementName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetMaxCountForAchievement
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle              AchievementHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetMaxCountForAchievement(const struct FDataTableRowHandle& AchievementHandle, int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetMaxCountForAchievement");

	Params::GI_SinglePlayer_C_GetMaxCountForAchievement Parms{};

	Parms.AchievementHandle = std::move(AchievementHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetLinearAchievementProgress
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle              AchievementHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// int32                                   MaxCount                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CurrentCount                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             AchivementHandleName                                   (Parm, OutParm)

void UGI_SinglePlayer_C::GetLinearAchievementProgress(const struct FDataTableRowHandle& AchievementHandle, int32* MaxCount, int32* CurrentCount, class FText* AchivementHandleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetLinearAchievementProgress");

	Params::GI_SinglePlayer_C_GetLinearAchievementProgress Parms{};

	Parms.AchievementHandle = std::move(AchievementHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (MaxCount != nullptr)
		*MaxCount = Parms.MaxCount;

	if (CurrentCount != nullptr)
		*CurrentCount = Parms.CurrentCount;

	if (AchivementHandleName != nullptr)
		*AchivementHandleName = std::move(Parms.AchivementHandleName);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetCanModifyAchievements
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::SetCanModifyAchievements(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetCanModifyAchievements");

	Params::GI_SinglePlayer_C_SetCanModifyAchievements Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TrySynchronizeAchievements
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TrySynchronizeAchievements(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TrySynchronizeAchievements");

	Params::GI_SinglePlayer_C_TrySynchronizeAchievements Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryCompleteBinaryAchievement
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              AchievementHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryCompleteBinaryAchievement(const struct FDataTableRowHandle& AchievementHandle, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryCompleteBinaryAchievement");

	Params::GI_SinglePlayer_C_TryCompleteBinaryAchievement Parms{};

	Parms.AchievementHandle = std::move(AchievementHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryIncrementOrderedAchievement
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              AchievementHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryIncrementOrderedAchievement(const struct FDataTableRowHandle& AchievementHandle, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryIncrementOrderedAchievement");

	Params::GI_SinglePlayer_C_TryIncrementOrderedAchievement Parms{};

	Parms.AchievementHandle = std::move(AchievementHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasCompletedGameEvent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle              GameEventHandle                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasCompletedGameEvent(const struct FDataTableRowHandle& GameEventHandle, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasCompletedGameEvent");

	Params::GI_SinglePlayer_C_HasCompletedGameEvent Parms{};

	Parms.GameEventHandle = std::move(GameEventHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryCompleteGameEvents
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FDataTableRowHandle>      GameEvents                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGI_SinglePlayer_C::TryCompleteGameEvents(TArray<struct FDataTableRowHandle>& GameEvents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryCompleteGameEvents");

	Params::GI_SinglePlayer_C_TryCompleteGameEvents Parms{};

	Parms.GameEvents = std::move(GameEvents);

	UObject::ProcessEvent(Func, &Parms);

	GameEvents = std::move(Parms.GameEvents);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetGameEventState
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              GameEventHandle                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    State                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::SetGameEventState(const struct FDataTableRowHandle& GameEventHandle, bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetGameEventState");

	Params::GI_SinglePlayer_C_SetGameEventState Parms{};

	Parms.GameEventHandle = std::move(GameEventHandle);
	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ToggleGameEventState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              GameEventHandle                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void UGI_SinglePlayer_C::ToggleGameEventState(const struct FDataTableRowHandle& GameEventHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ToggleGameEventState");

	Params::GI_SinglePlayer_C_ToggleGameEventState Parms{};

	Parms.GameEventHandle = std::move(GameEventHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryIncrementUnorderedAchievement
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              AchievementHandle                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// class UClass*                           SourceClass                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryIncrementUnorderedAchievement(const struct FDataTableRowHandle& AchievementHandle, class UClass* SourceClass, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryIncrementUnorderedAchievement");

	Params::GI_SinglePlayer_C_TryIncrementUnorderedAchievement Parms{};

	Parms.AchievementHandle = std::move(AchievementHandle);
	Parms.SourceClass = SourceClass;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsGameCountdownCritical
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsGameCountdownCritical(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsGameCountdownCritical");

	Params::GI_SinglePlayer_C_IsGameCountdownCritical Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.InitializeGameCountdownTimer
// (Public, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::InitializeGameCountdownTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "InitializeGameCountdownTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryResumeGameCountdownTimer
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NotifyPeriodicUpdate                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryResumeGameCountdownTimer(bool NotifyPeriodicUpdate, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryResumeGameCountdownTimer");

	Params::GI_SinglePlayer_C_TryResumeGameCountdownTimer Parms{};

	Parms.NotifyPeriodicUpdate = NotifyPeriodicUpdate;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStopGameCountdownTimer
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryStopGameCountdownTimer(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStopGameCountdownTimer");

	Params::GI_SinglePlayer_C_TryStopGameCountdownTimer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ForceResumeGameCountdownTimer
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NotifyPeriodicUpdate                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::ForceResumeGameCountdownTimer(bool NotifyPeriodicUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ForceResumeGameCountdownTimer");

	Params::GI_SinglePlayer_C_ForceResumeGameCountdownTimer Parms{};

	Parms.NotifyPeriodicUpdate = NotifyPeriodicUpdate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetGameCountdownSecondsRemaining
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetGameCountdownSecondsRemaining(float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetGameCountdownSecondsRemaining");

	Params::GI_SinglePlayer_C_GetGameCountdownSecondsRemaining Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnGameCountdownFinished
// (Protected, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnGameCountdownFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnGameCountdownFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.EVENT_OnPeriodicGameCountdownUpdate
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::EVENT_OnPeriodicGameCountdownUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "EVENT_OnPeriodicGameCountdownUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetKeycode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Tag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetKeycode(class FName Tag, int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetKeycode");

	Params::GI_SinglePlayer_C_GetKeycode Parms{};

	Parms.Tag = Tag;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetUniqueRandomPuzzleName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDataTable*                       DataTable                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ContextActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetUniqueRandomPuzzleName(class UDataTable* DataTable, class AActor* ContextActor, class FName* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetUniqueRandomPuzzleName");

	Params::GI_SinglePlayer_C_GetUniqueRandomPuzzleName Parms{};

	Parms.DataTable = DataTable;
	Parms.ContextActor = ContextActor;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.HasCompletedTutorial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             TutorialName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::HasCompletedTutorial(class FName TutorialName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "HasCompletedTutorial");

	Params::GI_SinglePlayer_C_HasCompletedTutorial Parms{};

	Parms.TutorialName = TutorialName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryCompleteTutorial
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             TutorialName                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryCompleteTutorial(class FName TutorialName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryCompleteTutorial");

	Params::GI_SinglePlayer_C_TryCompleteTutorial Parms{};

	Parms.TutorialName = TutorialName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsPublicAddressMessagePlaying
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::IsPublicAddressMessagePlaying(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsPublicAddressMessagePlaying");

	Params::GI_SinglePlayer_C_IsPublicAddressMessagePlaying Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetPublicAddressElapsedTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetPublicAddressElapsedTime(float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetPublicAddressElapsedTime");

	Params::GI_SinglePlayer_C_GetPublicAddressElapsedTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.CanPublicAddressReachLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          QueryLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   QueryRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::CanPublicAddressReachLocation(const struct FVector& QueryLocation, float QueryRadius, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "CanPublicAddressReachLocation");

	Params::GI_SinglePlayer_C_CanPublicAddressReachLocation Parms{};

	Parms.QueryLocation = std::move(QueryLocation);
	Parms.QueryRadius = QueryRadius;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.CanPlayPublicAddressMessage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle              MediaHandle                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::CanPlayPublicAddressMessage(const struct FDataTableRowHandle& MediaHandle, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "CanPlayPublicAddressMessage");

	Params::GI_SinglePlayer_C_CanPlayPublicAddressMessage Parms{};

	Parms.MediaHandle = std::move(MediaHandle);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ClearPublicAddressData
// (Protected, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::ClearPublicAddressData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ClearPublicAddressData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetPublicAddressMediaData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundCue>         SoundCue                                               (Parm, OutParm, HasGetValueTypeHash)
// struct FDataTableRowHandle              SpeakerHandle                                          (Parm, OutParm, NoDestructor)

void UGI_SinglePlayer_C::GetPublicAddressMediaData(TSoftObjectPtr<class USoundCue>* SoundCue, struct FDataTableRowHandle* SpeakerHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetPublicAddressMediaData");

	Params::GI_SinglePlayer_C_GetPublicAddressMediaData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SoundCue != nullptr)
		*SoundCue = Parms.SoundCue;

	if (SpeakerHandle != nullptr)
		*SpeakerHandle = std::move(Parms.SpeakerHandle);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryPlaySubtitlesForPublicAddressMessage
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryPlaySubtitlesForPublicAddressMessage(float StartTime, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryPlaySubtitlesForPublicAddressMessage");

	Params::GI_SinglePlayer_C_TryPlaySubtitlesForPublicAddressMessage Parms{};

	Parms.StartTime = StartTime;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryHideSubtitlesForPublicAddressMessage
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryHideSubtitlesForPublicAddressMessage(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryHideSubtitlesForPublicAddressMessage");

	Params::GI_SinglePlayer_C_TryHideSubtitlesForPublicAddressMessage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnPublicAddressSoundCueLoaded
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundCue*                        SoundCue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ElapsedTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::OnPublicAddressSoundCueLoaded(class USoundCue* SoundCue, float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnPublicAddressSoundCueLoaded");

	Params::GI_SinglePlayer_C_OnPublicAddressSoundCueLoaded Parms{};

	Parms.SoundCue = SoundCue;
	Parms.ElapsedTime = ElapsedTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.ForceResumePublicAddressMessage
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ElapsedTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::ForceResumePublicAddressMessage(float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "ForceResumePublicAddressMessage");

	Params::GI_SinglePlayer_C_ForceResumePublicAddressMessage Parms{};

	Parms.ElapsedTime = ElapsedTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryResumePublicAddressMessage
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryResumePublicAddressMessage(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryResumePublicAddressMessage");

	Params::GI_SinglePlayer_C_TryResumePublicAddressMessage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryPlayPublicAddressMessage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              MediaHandle                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryPlayPublicAddressMessage(const struct FDataTableRowHandle& MediaHandle, const struct FVector& Location, float Radius, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryPlayPublicAddressMessage");

	Params::GI_SinglePlayer_C_TryPlayPublicAddressMessage Parms{};

	Parms.MediaHandle = std::move(MediaHandle);
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryPlayPublicAddressMessageAtTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDataTableRowHandle              MediaHandle                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryPlayPublicAddressMessageAtTime(const struct FDataTableRowHandle& MediaHandle, const struct FVector& Location, float Radius, float StartTime, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryPlayPublicAddressMessageAtTime");

	Params::GI_SinglePlayer_C_TryPlayPublicAddressMessageAtTime Parms{};

	Parms.MediaHandle = std::move(MediaHandle);
	Parms.Location = std::move(Location);
	Parms.Radius = Radius;
	Parms.StartTime = StartTime;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStopPublicAddressMessage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    DoCallbacks                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryStopPublicAddressMessage(bool DoCallbacks, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStopPublicAddressMessage");

	Params::GI_SinglePlayer_C_TryStopPublicAddressMessage Parms{};

	Parms.DoCallbacks = DoCallbacks;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.EVENT_OnPublicAddressMessageFinished
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::EVENT_OnPublicAddressMessageFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "EVENT_OnPublicAddressMessageFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStopPublicAddressTimer
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryStopPublicAddressTimer(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStopPublicAddressTimer");

	Params::GI_SinglePlayer_C_TryStopPublicAddressTimer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.EVENT_OnAutoSaveAfterDelay
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::EVENT_OnAutoSaveAfterDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "EVENT_OnAutoSaveAfterDelay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnTickNextCaptureComponent
// (Private, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnTickNextCaptureComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnTickNextCaptureComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStartTickingCaptureComponent
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneCaptureComponent2D*         CaptureComponent                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryStartTickingCaptureComponent(class USceneCaptureComponent2D* CaptureComponent, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStartTickingCaptureComponent");

	Params::GI_SinglePlayer_C_TryStartTickingCaptureComponent Parms{};

	Parms.CaptureComponent = CaptureComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStopTickingCaptureComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneCaptureComponent2D*         CaptureComponent                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::TryStopTickingCaptureComponent(class USceneCaptureComponent2D* CaptureComponent, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStopTickingCaptureComponent");

	Params::GI_SinglePlayer_C_TryStopTickingCaptureComponent Parms{};

	Parms.CaptureComponent = CaptureComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetCurrentMusicCue
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_MusicCue_C*                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetCurrentMusicCue(class UBP_MusicCue_C** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetCurrentMusicCue");

	Params::GI_SinglePlayer_C_GetCurrentMusicCue Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetDeckNumberByLevelName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             LevelName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetDeckNumberByLevelName(class FName LevelName, int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetDeckNumberByLevelName");

	Params::GI_SinglePlayer_C_GetDeckNumberByLevelName Parms{};

	Parms.LevelName = LevelName;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetLevelNameByDeckSymbol
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString                           DeckSymbol                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class FName                             LevelName                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetLevelNameByDeckSymbol(const class FString& DeckSymbol, class FName* LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetLevelNameByDeckSymbol");

	Params::GI_SinglePlayer_C_GetLevelNameByDeckSymbol Parms{};

	Parms.DeckSymbol = std::move(DeckSymbol);

	UObject::ProcessEvent(Func, &Parms);

	if (LevelName != nullptr)
		*LevelName = Parms.LevelName;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetTemporarilyDisabledTileIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMeshComponent*             TileComponent                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetTemporarilyDisabledTileIndex(class UStaticMeshComponent* TileComponent, int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetTemporarilyDisabledTileIndex");

	Params::GI_SinglePlayer_C_GetTemporarilyDisabledTileIndex Parms{};

	Parms.TileComponent = TileComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetCurrentlyDisabledTileComponents
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSet<class UStaticMeshComponent*>       Result                                                 (Parm, OutParm, ContainsInstancedReference)

void UGI_SinglePlayer_C::GetCurrentlyDisabledTileComponents(TSet<class UStaticMeshComponent*>* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetCurrentlyDisabledTileComponents");

	Params::GI_SinglePlayer_C_GetCurrentlyDisabledTileComponents Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.AddTemporarilyDisabledTileComponents
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UStaticMeshComponent*>     TileComponents                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// float                                   DisableDuration                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::AddTemporarilyDisabledTileComponents(TArray<class UStaticMeshComponent*>& TileComponents, float DisableDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "AddTemporarilyDisabledTileComponents");

	Params::GI_SinglePlayer_C_AddTemporarilyDisabledTileComponents Parms{};

	Parms.TileComponents = std::move(TileComponents);
	Parms.DisableDuration = DisableDuration;

	UObject::ProcessEvent(Func, &Parms);

	TileComponents = std::move(Parms.TileComponents);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetPermanentTileComponentEnableState
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UStaticMeshComponent*>     TileComponents                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    EnableState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::SetPermanentTileComponentEnableState(TArray<class UStaticMeshComponent*>& TileComponents, bool EnableState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetPermanentTileComponentEnableState");

	Params::GI_SinglePlayer_C_SetPermanentTileComponentEnableState Parms{};

	Parms.TileComponents = std::move(TileComponents);
	Parms.EnableState = EnableState;

	UObject::ProcessEvent(Func, &Parms);

	TileComponents = std::move(Parms.TileComponents);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UpdateTileComponentEnableStateInternal
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UStaticMeshComponent*>     TileComponents                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    EnableState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGI_SinglePlayer_C::UpdateTileComponentEnableStateInternal(TArray<class UStaticMeshComponent*>& TileComponents, bool EnableState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UpdateTileComponentEnableStateInternal");

	Params::GI_SinglePlayer_C_UpdateTileComponentEnableStateInternal Parms{};

	Parms.TileComponents = std::move(TileComponents);
	Parms.EnableState = EnableState;

	UObject::ProcessEvent(Func, &Parms);

	TileComponents = std::move(Parms.TileComponents);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnPerformTileEnableTick
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnPerformTileEnableTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnPerformTileEnableTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.TryStartTileEnableTick
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::TryStartTileEnableTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "TryStartTileEnableTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.RegisterActiveAlarmSpeaker
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AlarmSpeaker_Base_C*          AlarmSpeaker                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::RegisterActiveAlarmSpeaker(class ABP_AlarmSpeaker_Base_C* AlarmSpeaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "RegisterActiveAlarmSpeaker");

	Params::GI_SinglePlayer_C_RegisterActiveAlarmSpeaker Parms{};

	Parms.AlarmSpeaker = AlarmSpeaker;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.UnregisterActiveAlarmSpeaker
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AlarmSpeaker_Base_C*          AlarmSpeaker                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::UnregisterActiveAlarmSpeaker(class ABP_AlarmSpeaker_Base_C* AlarmSpeaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "UnregisterActiveAlarmSpeaker");

	Params::GI_SinglePlayer_C_UnregisterActiveAlarmSpeaker Parms{};

	Parms.AlarmSpeaker = AlarmSpeaker;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.OnPlayEmergencySound
// (Protected, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::OnPlayEmergencySound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "OnPlayEmergencySound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetBossEncounterTrap
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    EnemyPawn                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ATRAP_BossEncounter_C*            Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetBossEncounterTrap(class APAWN_Enemy_C* EnemyPawn, class ATRAP_BossEncounter_C** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetBossEncounterTrap");

	Params::GI_SinglePlayer_C_GetBossEncounterTrap Parms{};

	Parms.EnemyPawn = EnemyPawn;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetCurrentCombatIntensity
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Intensity                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetCurrentCombatIntensity(float Intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetCurrentCombatIntensity");

	Params::GI_SinglePlayer_C_SetCurrentCombatIntensity Parms{};

	Parms.Intensity = Intensity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetCurrentCombatIntensity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Intensity                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetCurrentCombatIntensity(float* Intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetCurrentCombatIntensity");

	Params::GI_SinglePlayer_C_GetCurrentCombatIntensity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Intensity != nullptr)
		*Intensity = Parms.Intensity;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.GetProgressRatioThroughGame
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::GetProgressRatioThroughGame(float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "GetProgressRatioThroughGame");

	Params::GI_SinglePlayer_C_GetProgressRatioThroughGame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.PrintAchievementProgress
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGI_SinglePlayer_C::PrintAchievementProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "PrintAchievementProgress");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.SetHackerGenderValue
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ENUM_HackerGender                       NewGender                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGI_SinglePlayer_C::SetHackerGenderValue(ENUM_HackerGender NewGender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "SetHackerGenderValue");

	Params::GI_SinglePlayer_C_SetHackerGenderValue Parms{};

	Parms.NewGender = NewGender;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GI_SinglePlayer.GI_SinglePlayer_C.IsInGame
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UGI_SinglePlayer_C::IsInGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GI_SinglePlayer_C", "IsInGame");

	Params::GI_SinglePlayer_C_IsInGame Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

