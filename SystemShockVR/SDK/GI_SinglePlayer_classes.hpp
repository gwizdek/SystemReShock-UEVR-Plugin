#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GI_SinglePlayer

#include "Basic.hpp"

#include "STRUCT_EnemyReinforcementVolumes_structs.hpp"
#include "StreamingSaveGameSystem_classes.hpp"
#include "Engine_structs.hpp"
#include "STRUCT_LevelRespawnData_structs.hpp"
#include "MenuState_structs.hpp"
#include "ENUM_GameDifficultyConfigCategory_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "InGameState_structs.hpp"
#include "STRUCT_AchievementClassData_structs.hpp"
#include "GameplayState_structs.hpp"
#include "ExplorationState_structs.hpp"
#include "CoreGame_structs.hpp"
#include "STRUCT_AsyncParticleParamArray_structs.hpp"
#include "STRUCT_AsyncSoundParamArray_structs.hpp"
#include "STRUCT_DisabledTileData_structs.hpp"
#include "ENUM_HackerGender_structs.hpp"
#include "ENUM_SharedBagType_structs.hpp"
#include "ENUM_GameDifficulty_structs.hpp"
#include "DLSSBlueprint_structs.hpp"
#include "ENUM_VolumeType_structs.hpp"
#include "ENUM_MapType_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass GI_SinglePlayer.GI_SinglePlayer_C
// 0x0B88 (0x0DB0 - 0x0228)
class UGI_SinglePlayer_C final : public USingleplayerGameInstance
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0228(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class FName                                   CurrentLevelName;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   PreviousLevelName;                                 // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   QueuedPrimaryLevelToLoad;                          // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FDataTableRowHandle                    CurrentLevelCollection;                            // 0x0248(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	FMulticastInlineDelegateProperty_             OnSecurityLevelChanged;                            // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FTimerHandle                           GameCountdownTimerHandle;                          // 0x0268(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	float                                         GameCountdownSecondsRemaining;                     // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         GameCountdownStartTimestamp;                       // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         GameCountdownPeriodicUpdateDuration;               // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LevelStreamingTimeDilation;                        // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UVoxelLevelManager*                     VoxelLevelManager;                                 // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSet<class FName>                             LevelRespawnChambers;                              // 0x0288(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TSet<class FName>                             CompletedTutorials;                                // 0x02D8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TSet<class FName>                             ChosenPuzzleNames;                                 // 0x0328(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TArray<class FName>                           VisitedLevels;                                     // 0x0378(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TMap<class FName, int32>                      LevelSecurity;                                     // 0x0388(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TMap<class FName, int32>                      LevelComputerNodes;                                // 0x03D8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TMap<class FName, float>                      StoryQuests;                                       // 0x0428(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	FMulticastInlineDelegateProperty_             OnStoryQuestChanged;                               // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnStoryQuestNotification;                          // 0x0488(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnTutorialCompleted;                               // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnFinishedLoadingStreamLevel;                      // 0x04A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnStartUnloadingStreamLevel;                       // 0x04B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnFinishedUnloadingStreamLevel;                    // 0x04C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          IsBlockingLoad;                                    // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          DisableStreaming;                                  // 0x04D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          HasSeenTitleScreen;                                // 0x04DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          ShouldClearLevelDataAfterLoad;                     // 0x04DB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4DC[0x4];                                      // 0x04DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           LevelNamesToLoad;                                  // 0x04E0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<class FName>                           LevelNamesToUnload;                                // 0x04F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	FMulticastInlineDelegateProperty_             OnStartLoadingLevelCollection;                     // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnStartUnloadingLevelCollection;                   // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnFinishedLoadingLevelCollection;                  // 0x0520(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnFinishedUnloadingLevelCollection;                // 0x0530(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<class UITEM_Base_C*>                   StashedTransferItems;                              // 0x0540(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	struct FVector                                LastLevelOffset;                                   // 0x0550(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnComputerNodesChanged;                            // 0x0560(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class FString                                 QuicksaveSaveName;                                 // 0x0570(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	class FString                                 AutosaveSaveName;                                  // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	class ULevelStreaming*                        CurrentLoadingLevel;                               // 0x0590(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<TSoftClassPtr<class UClass>, int32>      EnemyToVolumeIndexMap;                             // 0x0598(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<TSoftClassPtr<class UClass>, int32>      EnemyPopulations;                                  // 0x05E8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<struct FSTRUCT_EnemyReinforcementVolumes> EnemyReinforcementVolumeLists;                     // 0x0638(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<struct FSTRUCT_LevelRespawnData>       EnemyReinforcementDataPerLevel;                    // 0x0648(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	struct FTimerHandle                           NextRespawnTimerHandle;                            // 0x0658(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	int32                                         NextAvailablePatrolPathID;                         // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         LastSpawnedEnemyID;                                // 0x0664(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSet<int32>                                   FreePatrolPathSet;                                 // 0x0668(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TSet<int32>                                   UsedPatrolPathSet;                                 // 0x06B8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UBP_MusicCue_C*                         CurrentMusicCue;                                   // 0x0708(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UBP_MusicCue_C*>                 StoppedMusicCues;                                  // 0x0710(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class FName                                   MusicLevelOverride;                                // 0x0720(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EMenuState                                    MusicMenuState;                                    // 0x0728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EInGameState                                  MusicGameState;                                    // 0x0729(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EGameplayState                                MusicGameplayState;                                // 0x072A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ExplorationState                              MusicAmbienceState;                                // 0x072B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameSettingsSaveSlotName;                          // 0x0730(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash)
	class USAVE_Settings_C*                       ShockSettings;                                     // 0x0740(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<int32>                                 DestructionCodeDigits;                             // 0x0748(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	class UWIDGET_LoadingScreen_C*                LoadingScreen;                                     // 0x0758(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class ATRAP_Trigger_C*>                GroupedTrapActors;                                 // 0x0760(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	class UDataTable*                             KeycodeSettingsTable;                              // 0x0770(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSet<int32>                                   StoryKeycodes;                                     // 0x0778(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<class FName, int32>                      RandomTaggedKeycodes;                              // 0x07C8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TArray<class UITEM_Base_C*>                   PendingLostItems;                                  // 0x0818(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TArray<class UITEM_Base_C*>                   SharedLostItems;                                   // 0x0828(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TArray<class UITEM_Base_C*>                   SharedStorageItems;                                // 0x0838(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	class FName                                   SharedStorageLevelName;                            // 0x0848(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USceneCaptureComponent2D*               ItemIconCaptureComponent;                          // 0x0850(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USceneCaptureComponent2D*               ItemDetailsCaptureComponent;                       // 0x0858(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<struct FObjectClassCollection, class UTextureRenderTarget2D*> ItemGridRenderTargetMap;                           // 0x0860(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<struct FObjectClassCollection, class UTextureRenderTarget2D*> ItemHotbarRenderTargetMap;                         // 0x08B0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TMap<struct FIntPoint, class UTextureRenderTarget2D*> ItemDetailsRenderTargetMap;                        // 0x0900(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	class APICKUP_Base_C*                         LastItemIconPickupActor;                           // 0x0950(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class APICKUP_Base_C*                         LastItemDetailsPickupActor;                        // 0x0958(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TSet<struct FObjectClassCollection>           PendingGridIconRenders;                            // 0x0960(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TSet<struct FObjectClassCollection>           PendingHotbarIconRenders;                          // 0x09B0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<class APICKUP_Base_C*>                 PendingGridIconActors;                             // 0x0A00(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	struct FTimerHandle                           PendingIconTimerHandle;                            // 0x0A10(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	float                                         CurrentCombatIntensity;                            // 0x0A18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CurrentExplorationIntensity;                       // 0x0A1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         RegionDiscoverIntensityGain;                       // 0x0A20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         IntensityDecayAmount;                              // 0x0A24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         IntensityDecayTime;                                // 0x0A28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_A2C[0x4];                                      // 0x0A2C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           IntensityDecayTimerHandle;                         // 0x0A30(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TMap<class UFXSystemComponent*, int32>        AsyncSystemComponentRefCounts;                     // 0x0A38(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TMap<class USceneComponent*, int32>           AsyncSceneComponentRefCounts;                      // 0x0A88(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TMap<TSoftObjectPtr<class UFXSystemAsset>, struct FSTRUCT_AsyncParticleParamArray> QueuedAsyncSystems;                                // 0x0AD8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TMap<TSoftObjectPtr<class USoundCue>, struct FSTRUCT_AsyncSoundParamArray> QueuedAsyncSounds;                                 // 0x0B28(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          DebugReinforcements;                               // 0x0B78(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_B79[0x7];                                      // 0x0B79(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APAWN_Enemy_C*>                  LowFiBehaviorEnemies;                              // 0x0B80(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	int32                                         CurrentLowFiEnemyIndex;                            // 0x0B90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_B94[0x4];                                      // 0x0B94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LowFiBehaviorTimerHandle;                          // 0x0B98(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          DebugLowFiBehaviorEnemies;                         // 0x0BA0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_BA1[0x7];                                      // 0x0BA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DefaultCultureFontTable;                           // 0x0BA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          CanModifyAchievements;                             // 0x0BB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          HasSynchronizedAchievements;                       // 0x0BB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_BB2[0x6];                                      // 0x0BB2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableRowHandle                    CompletedAllAchievementHandle;                     // 0x0BB8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	TMap<class FName, int32>                      LinearAchievementMap;                              // 0x0BC8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TMap<class FName, struct FSTRUCT_AchievementClassData> UnorderedAchievementMap;                           // 0x0C18(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	class UOBJ_TileDescriptorManager_C*           TileDescriptorManager;                             // 0x0C68(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnPeriodicGameCountdownEvent;                      // 0x0C70(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	float                                         PublicAddressTimestamp;                            // 0x0C80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_C84[0x4];                                      // 0x0C84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             PublicAddressMediaTable;                           // 0x0C88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   PublicAddressRowName;                              // 0x0C90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnPublicAddressStateChanged;                       // 0x0C98(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FVector                                PublicAddressLocation;                             // 0x0CA8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         PublicAddressRadius;                               // 0x0CB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           PublicAddressTimerHandle;                          // 0x0CB8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class FText                                   SaveGameLoadFailureText;                           // 0x0CC0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance)
	struct FTimerHandle                           AutosaveTimerHandle;                               // 0x0CD8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class USceneCaptureComponent2D*>       TickingCaptureComponents;                          // 0x0CE0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	int32                                         LastTickedCaptureComponentIndex;                   // 0x0CF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_CF4[0x4];                                      // 0x0CF4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SceneCaptureTimerHandle;                           // 0x0CF8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TSet<class UStaticMeshComponent*>             PermDisabledTileComponents;                        // 0x0D00(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference)
	TArray<struct FSTRUCT_DisabledTileData>       TempDisabledTileComponents;                        // 0x0D50(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, ContainsInstancedReference)
	struct FTimerHandle                           TileComponentEnableTimerHandle;                    // 0x0D60(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnPendingLostItemsChanged;                         // 0x0D68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FTimerHandle                           AlarmLightTimerHandle;                             // 0x0D78(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_AlarmSpeaker_Base_C*>        ActiveAlarmSpeakers;                               // 0x0D80(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	class UUserWidget*                            CachedLoadingHUDWidget;                            // 0x0D90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	ENUM_HackerGender                             HackerGender;                                      // 0x0D98(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_D99[0x7];                                      // 0x0D99(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnControllerConnectionStateChange;                 // 0x0DA0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)

public:
	void OnSecurityLevelChanged__DelegateSignature(int32 NewSecurityLevel);
	void OnStoryQuestChanged__DelegateSignature(class FName StoryQuestName, bool Value);
	void OnFinishedLoadingStreamLevel__DelegateSignature(class FName LevelName);
	void OnStartUnloadingStreamLevel__DelegateSignature(class FName LevelName);
	void OnFinishedUnloadingStreamLevel__DelegateSignature(class FName LevelName);
	void OnFinishedLoadingLevelCollection__DelegateSignature();
	void OnFinishedUnloadingLevelCollection__DelegateSignature();
	void OnComputerNodesChanged__DelegateSignature(int32 NodesRemaining);
	void OnStartLoadingLevelCollection__DelegateSignature();
	void OnStartUnloadingLevelCollection__DelegateSignature();
	void OnPeriodicGameCountdownEvent__DelegateSignature();
	void OnTutorialCompleted__DelegateSignature(class FName TutorialName);
	void OnPublicAddressStateChanged__DelegateSignature(class USoundCue* SoundCue, TSoftObjectPtr<class UTexture2D> PortraitTexture, int32 RowCount, int32 ColCount, int32 FrameRate);
	void OnStoryQuestNotification__DelegateSignature(class FName QuestName, const class FText& NotificationText, float NotificationDelay);
	void OnPendingLostItemsChanged__DelegateSignature();
	void OnControllerConnectionStateChange__DelegateSignature(bool ControllerConnectedState);
	void ExecuteUbergraph_GI_SinglePlayer(int32 EntryPoint);
	void OnOnlineConnectionStatusChange(bool bIsConnected);
	void OnControllerConnectionChange(bool bIsConnected, int32 UserIndex);
	void OnFinishedLoadingLevel(const class FString& MapName);
	void OnFinishedLoadingGame();
	void OnStartedLoadingGame();
	void EVENT_OnFinishedUnloadingLevelCollectionWithLoadingScreen();
	void UnloadCurrentThenLoadLevelCollectionWithLoadingScreen(class FName LevelName);
	void StartLoadingLevelCollectionWithLoadingScreen(class FName LevelName);
	void OnTick(float DeltaSeconds);
	void ReceiveShutdown();
	void EVENT_OnFinishedLoadingLevelCollectionWithLoadingScreen();
	void ReceiveInit();
	void INTERNAL_UnloadNextLevelForCollection();
	void INTERNAL_LoadNextLevelForCollection();
	void StartUnloadingStreamingLevelCollection(const struct FDataTableRowHandle& LevelCollection, const TArray<class FName>& LevelsToKeepLoaded);
	void StartLoadingStreamingLevelCollection(const struct FDataTableRowHandle& LevelCollection, bool BlockOnLoad);
	void AsyncPlaySoundFromVoxelComponent(TSoftObjectPtr<class USoundCue> SoundCue, const float FadeInDuration, float StartTime, class UVoxelAudioComponent* AudioComponent);
	void AsyncLoadPublicAddressCue(TSoftObjectPtr<class USoundCue> SoundCue, float ElapsedTime);
	void AsyncPlaySystem(const TSoftObjectPtr<class UFXSystemAsset>& System, const struct FSTRUCT_AsyncParticleParams& SystemParams);
	void AsyncPlaySound(TSoftObjectPtr<class USoundCue> SoundCue, const struct FSTRUCT_AsyncSoundParams& SoundParams);
	void AsyncStopSystemAttachments(class USceneComponent* SceneComponent);
	void AsyncStopSystemOnComponents(const TArray<class UFXSystemComponent*>& SystemComponents);
	void AsyncStopSystemOnComponent(class UFXSystemComponent* SystemComponent);
	void AsyncPlaySoundFromComponents(TSoftObjectPtr<class USoundCue> SoundCue, const TArray<class UAudioComponent*>& AudioComponents);
	void AsyncPlaySystemFromComponents(TSoftObjectPtr<class UNiagaraSystem> System, const TArray<class UNiagaraComponent*>& SystemComponents);
	void AsyncPlaySystemFromComponent(TSoftObjectPtr<class UFXSystemAsset> System, class UFXSystemComponent* SystemComponent);
	void AsyncPlaySoundFromComponent(TSoftObjectPtr<class USoundCue> SoundCue, const float FadeInDuration, float StartTime, class UAudioComponent* AudioComponent);
	void AsyncPlaySystemAttached(TSoftObjectPtr<class UFXSystemAsset> System, class USceneComponent* AttachToComponent, class FName SocketName, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, const struct FSTRUCT_EffectParams& EffectsParameters, const struct FLatentObjectEventHandle& OnSpawnEvent);
	void AsyncPlaySystemAtTransform(TSoftObjectPtr<class UFXSystemAsset> System, const struct FTransform& Transform);
	void AsyncPlaySoundAttached(TSoftObjectPtr<class USoundCue> SoundCue, class USceneComponent* AttachToComponent, class FName SocketName, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation, const struct FSTRUCT_EffectParams& SoundParameters);
	void AsyncPlaySoundAtLocation(TSoftObjectPtr<class USoundCue> SoundCue, const struct FVector& Location);
	void AsyncPlaySound2D(TSoftObjectPtr<class USoundCue> SoundCue);
	void AsyncCompleteAchievement(class APlayerController* PlayerController, const struct FDataTableRowHandle& AchievementHandle, int32 UserTag);
	void OnLoaded_5F20C05541B420AAFDF306B06AF3128C(class UObject* Loaded);
	void OnLoaded_8813AF2B47A0C9D07AFC5599A36960DC(class UObject* Loaded);
	void OnLoaded_C37B164D45E88D137228229CBD66276C(class UObject* Loaded);
	void OnLoaded_902273224FDEF301060954979477BC10(class UObject* Loaded);
	void OnLoaded_27DE819F4EE56836C47D57B5FC573DF3(class UObject* Loaded);
	void OnLoaded_0AE72DE7432C87D6E53955A12395D8C0(class UObject* Loaded);
	void OnLoaded_A8C87E1843AC479AC213708C6EA1A5CC(class UObject* Loaded);
	void OnLoaded_E3F818954DA5FE57518113AEA34DB5C9(class UObject* Loaded);
	void OnLoaded_AD81EB1046C74F24ACB5A9951ACF845E(class UObject* Loaded);
	void OnSuccess_1E3D796F4FD7EC1D6937C7BD8033813A(class FName WrittenAchievementName, float WrittenProgress, int32 WrittenUserTag);
	void OnFailure_1E3D796F4FD7EC1D6937C7BD8033813A(class FName WrittenAchievementName, float WrittenProgress, int32 WrittenUserTag);
	void LowerSecurityLevel(int32 SubtractAmount);
	void HasCompletedStoryQuest(class FName QuestName, bool* Completed);
	void GetStoryQuestCompletionTimestamp(class FName QuestName, float* Timestamp);
	void SetCompletedStoryQuest(class FName QuestName, bool Value, class FString* LogString);
	void SetSecurityLevel(int32 NewSecurityLevel);
	void IsLoadingScreenVisible(bool* Result);
	void HasAssignedCurrentLevel(bool* Result);
	void HasAssignedPreviousLevel(bool* Result);
	void GetCurrentLevelName(class FName* Result);
	void GetPreviousLevelName(class FName* Result);
	void GetLevelCollectionFromPrimaryLevelName(class FName PrimaryLevelName, struct FDataTableRowHandle* Result);
	void GetPrimaryStreamingLevel(class ULevelStreaming** Level);
	void GetSharedLevelNamesForMapMove(const struct FDataTableRowHandle& TargetLevelCollection, TArray<class FName>* SharedLevelNames);
	void GetLevelAtmosphereSettings(class FName LevelName, struct FSTRUCT_LevelAtmosphereSettings* Settings);
	void CanRespawnOnLevel(class FName LevelName, bool* Result);
	void HasActivatedAnyRespawnChambers(bool* Result);
	void IsRespawnChamberActiveForLevel(class FName LevelName, bool* Result);
	void GetHackerGender(ENUM_HackerGender* Result);
	void GetLevelInfo(class FName LevelName, struct FSTRUCT_LevelInfo* LevelInfo, bool* Found);
	void GetSecurityForLevel(class FName LevelName, int32* Result);
	void GetSecurityForCurrentLevel(int32* Result);
	void StashTransferItemsFromBag(class UInventoryBag_C* OriginBag);
	void TransferStashedItemsToBag(class UInventoryBag_C* TargetBag);
	void GetComputerNodesForLevel(class FName Level, int32* RemainingNodes);
	void GetComputerNodesForCurrentLevel(int32* RemainingNodes);
	void SetCurrentComputerNodes(int32 NewCount);
	void GetLevelNames(TArray<class FName>* Levels);
	void GetVisitedLevels(TArray<class FName>* VisitedLevels_0);
	void GetAutoSaveName(class FString* Result);
	void SaveGameInternal(const class FString& SaveName, int32 UserIndex, bool* Result);
	void AutoSaveWithDelay(float DelayTime, int32 UserIndex);
	void ConditionalAutoSave(int32 UserIndex, bool* Result);
	void AutoSave(int32 UserIndex);
	void AutoLoad(int32 UserIndex);
	void QuickSave(int32 UserIndex);
	void QuickLoad(int32 UserIndex);
	void ManualLoad(const class FString& SaveName, int32 UserIndex);
	void OnPreUnloadLevelByName(class FName LevelName);
	void OnPostLoadCurrentLevel();
	void HasVisitedLevel(class FName LevelName, bool* Result);
	void GetVisitedLevelIndex(class FName LevelName, int32* Index_0);
	void GetLevelNameByDeck(int32 DeckNumber, class FName* Level);
	void RegisterReinforcementVolume(class AVOLUME_Reinforcements_C* Volume);
	void UnregisterReinforcementVolume(class AVOLUME_Reinforcements_C* Volume);
	void RegisterEnemy(class APAWN_Enemy_C* Enemy);
	void UnregisterEnemy(class APAWN_Enemy_C* Enemy);
	void ModifyEnemyPopulation(class UClass* EnemyClass, int32 PopulationChange, bool* Result);
	void GetReinforcementVolumeBaseClasses(class AVOLUME_Reinforcements_C* Volume, TArray<TSoftClassPtr<class UClass>>* BaseClasses);
	void TryPrintDebugReinforcementMessage(const class FString& Message);
	void TryStartReinforcingWithSettings(const struct FSTRUCT_EnemyReinforcementSettings& ReinforcementSettings, int32 PopulationCount, float StartTimestamp);
	void TryStartReinforcingOnQuestChanged(class FName QuestName);
	void TryStartReinforcingOnLevelFinishedLoading();
	void TryStartRespawnTimerForFirstRespawnEvent();
	void TryStartRespawnTimer(float RespawnDelay);
	void HasStartedRespawningEnemyClass(TSoftClassPtr<class UClass> EnemyClass, bool* Result);
	void GetReinforcementSettingsFromClassName(const class FString& EnemyClassName, bool* Success, TSoftClassPtr<class UClass>* Class_0, struct FSTRUCT_EnemyReinforcementSettings* Settings);
	void GetReinforcementSettingsFromClass(class UClass* EnemyClass, bool* Success, struct FSTRUCT_EnemyReinforcementSettings* Settings);
	void GetRespawnSettingsFromReinforcementSettings(const struct FSTRUCT_EnemyReinforcementSettings& ReinforcementSettings, struct FSTRUCT_CurrentReinforcementSettings* RespawnSettings);
	void GetReinforceClassNameFromClass(TSoftClassPtr<class UClass> Class_0, class FString* ClassName);
	void OnRespawnDelayElapsed();
	void IsStreamingLevels(bool* Result);
	void OpenPersistentMapByType(ENUM_MapType LevelType);
	void OnBeginLoadingLevelCollectionInternal();
	void OnFinishedLoadingLevelCollectionInternal();
	void OnBeginUnloadingLevelCollectionInternal();
	void GetRespawnDataIndexForLevel(class FName LevelName, int32* LevelDataIndex);
	void SpawnEnemyReinforcementsByType(TSoftClassPtr<class UClass> EnemyClass, int32 SpawnCount, bool RequireAmbush, int32* CountSpawned);
	void RequestNewSpawnedEnemyID(int32* NewID);
	void RequestNewSpawnedEnemyName(class UClass* EnemyClass, class FName* EnemyName);
	void RegisterPatrolNode(class APatrolNode_C* PatrolNode);
	void UnregisterPatrolNode(class APatrolNode_C* PatrolNode);
	void OnFinishedUnloadingLevelCollectionInternal();
	void InitMusicSystemSettings(class UPDA_MusicSystemSettings_C* MusicSystemSettings);
	void PlayStoryMusic(const struct FSTRUCT_MusicParams& MusicParams, class UBP_MusicCue_C** MusicCue);
	void StopStoryMusic();
	void PlayMusicInternal(const struct FSTRUCT_MusicParams& NewMusicParams, class UBP_MusicCue_C** MusicCue);
	void TryInterruptCurrentMusic(class UClass* NewMusicClass, bool* Result);
	void TryUpdateExplorationMusic();
	void OnMusicStateUpdated(const struct FSTRUCT_MusicParams& ExplicitMusicAssignment, class UBP_MusicCue_C** MusicCue);
	void TickMusic(float DeltaTime);
	void SetGameplayMusicState(EGameplayState Gameplay_State);
	void SetInGameMusicState(EInGameState In_Game_State);
	void GetAmbienceMusicState(ExplorationState* NewParam);
	void SetAmbienceMusicState(ExplorationState In_Game_State);
	void InitializeShockSettings(class ACON_Hacker_C* HackerController);
	void SetDefaultDifficultyValues(ENUM_GameDifficulty Combat, ENUM_GameDifficulty Mission, ENUM_GameDifficulty Puzzle, ENUM_GameDifficulty Cyber);
	void SetDifficultyValues(ENUM_GameDifficulty Combat, ENUM_GameDifficulty Mission, ENUM_GameDifficulty Puzzle, ENUM_GameDifficulty Cyber);
	void GetDifficultyValues(ENUM_GameDifficulty* Combat, ENUM_GameDifficulty* Mission, ENUM_GameDifficulty* Puzzle, ENUM_GameDifficulty* Cyber);
	void GetDifficultyByType(ENUM_GameDifficultyConfigCategory Type, ENUM_GameDifficulty* Difficulty);
	void GetCombatDifficultySettings(struct FSTRUCT_CombatDifficultySettings* Settings);
	void GetMissionDifficultySettings(struct FSTRUCT_MissionDifficultySettings* Settings);
	void SetVolume(float Volume, ENUM_VolumeType Type);
	void SetVolumeInternal(float Volume, ENUM_VolumeType Type);
	void LogSaveShockSettingsFailed();
	void LoadShockSettings(int32 UserIndex, class USAVE_Settings_C** Settings);
	void SaveShockSettings(class USAVE_Settings_C* Settings, int32 UserIndex, bool* Result);
	void SetMusicState(EMenuState MenuState, EInGameState GameState, EGameplayState GameplayState, const struct FSTRUCT_MusicParams& ExplicitAudioAssignment, class UBP_MusicCue_C** MusicCue);
	void EVENT_OnMusicFinished(class UBP_MusicCue_C* MusicCue);
	void SetMusicLevelOverride(class FName LevelName, bool* Result);
	void IsMusicInState(EMenuState MenuState, EInGameState GameState, EGameplayState GameplayState, bool* Result);
	void ApplyDefaultUserSettings();
	void TryGenerateDestructCode(bool* Result);
	void TryGenerateStoryKeycodes(bool* Result);
	void GetDestructionCode(int32* Code);
	void GetDestructionCodeDigitForCurrentLevel(int32* Result);
	void GetDestructionCodeDigitByIndex(int32 Index_0, int32* Digit);
	void RegisterGroupedTrap(class ATRAP_Trigger_C* Trap);
	void UnregisterGroupedTrap(class ATRAP_Trigger_C* Trap);
	void DismantleTrapsInGroup(class ATRAP_Trigger_C* Trap);
	void IsPatrolPathInUse(class APatrolNode_C* PatrolNode, bool* Result);
	void GetUniqueRandomKeycode(class FName Tag, int32* Keycode);
	bool OnNewGameStarted();
	void AddPickupToPendingLostList(class APICKUP_Base_C* Pickup);
	void AddInventoryToPendingLostList(class UCOMP_Inventory_C* Inventory);
	void TryMergeLostItemsToBag(class UInventoryBag_C* Bag, bool OnlyPendingItems);
	void CopySharedItemsToBag(class UInventoryBag_C* Bag, ENUM_SharedBagType Type);
	void CopySharedItemsFromBag(class UInventoryBag_C* Bag, ENUM_SharedBagType Type);
	void SetSharedStorageLevelName(class FName LevelName);
	void GetSharedStorageLevelName(class FName* Result);
	void GetItemGridRenderTarget(class UITEM_Base_C* Item, class UTextureRenderTarget2D** Result);
	void GetItemHotbarRenderTarget(class UITEM_Base_C* Item, class UTextureRenderTarget2D** Result);
	void GetItemHotbarRenderTargetForItemClass(class UClass* ItemClass, class UTextureRenderTarget2D** Result);
	void GetItemHotbarRenderTargetForPickupClass(const struct FObjectClassCollection& ClassCollection, class UTextureRenderTarget2D** Result);
	void TryCreateItemCaptureWorld();
	void UpdateItemDetailsRenderTarget(class UITEM_Base_C* Item, float Progress, const struct FSTRUCT_ItemDetailsIconParams& CustomIconParams, class UTextureRenderTarget2D** Result, struct FSTRUCT_ItemDetailsIconParams* IconParams);
	void UpdateItemDetailsPickupActor(const struct FObjectClassCollection& IconClassCollection);
	void UpdateItemIconPickupActor(const struct FObjectClassCollection& IconClassCollection, bool* IsFullyLoaded);
	void ClearLastItemIconPickupActor();
	void AddPendingGridIconActor(class APICKUP_Base_C* PickupActor);
	void OnUpdatePendingPickupIcons();
	void IsInMusicGameplayState(EGameplayState GameplayState, bool* Result);
	void TryFadeInStoppedMusicByClass(class UClass* MusicCueClass, bool* Result);
	void ForceStopMusic();
	void ResetSavedData();
	void OnLevelRegionDiscovered(const struct FDataTableRowHandle& RegionRowHandle);
	void EVENT_OnIntensityDecayTimer();
	void OnVoxelColumnsRevealed(int32 VoxelColumnCount);
	void SetCurrentExploreIntensity(float Intensity);
	void IsTryingToPlaySystemOnComponentAsync(class UFXSystemComponent* SystemComponent, bool* Result);
	void IsTryingToAttachToSceneComponentAsync(class USceneComponent* SceneComponent, bool* Result);
	void TryIncrementSystemComponentRefCount(class UFXSystemComponent* SystemComponent, bool* Result);
	void TryDecrementSystemComponentRefCount(class UFXSystemComponent* SystemComponent, bool* Result);
	void TryIncrementSceneComponentRefCount(class USceneComponent* SceneComponent, bool* Result);
	void TryDecrementSceneComponentRefCount(class USceneComponent* SceneComponent, bool* Result);
	void PlaySystemUsingAsyncParams(class UFXSystemAsset* System, struct FSTRUCT_AsyncParticleParams& SystemParams);
	void AddAsyncSystemParamsToQueue(TSoftObjectPtr<class UFXSystemAsset> System, const struct FSTRUCT_AsyncParticleParams& SystemParams);
	void RemoveAsyncSystemParamsFromQueue(TSoftObjectPtr<class UFXSystemAsset> System, bool* Success, struct FSTRUCT_AsyncParticleParams* SystemParams);
	void PlaySoundUsingAsyncParams(class USoundCue* SoundCue, struct FSTRUCT_AsyncSoundParams& SoundParams);
	void AddAsyncSoundParamsToQueue(TSoftObjectPtr<class USoundCue> SoundCue, const struct FSTRUCT_AsyncSoundParams& SoundParams);
	void RemoveAsyncSoundParamsFromQueue(TSoftObjectPtr<class USoundCue> SoundCue, struct FSTRUCT_AsyncSoundParams* SoundParams);
	void UpdateLevelAtmosphere(float Progress, const struct FSTRUCT_LevelAtmosphereSettings& SourceAtmosphereSettings, const struct FSTRUCT_LevelAtmosphereSettings& TargetAtmosphereSettings);
	void UpdateLevelAtmosphereToCurrent();
	void GetRespawnChamberLevelFromDeckSymbol(const class FString& DeckSymbol, class FName* LevelName);
	void GetRespawnChamberLevelFromLevelName(class FName QueryLevelName, class FName* RespawnLevelName);
	void GetBestRespawnChamberLevel(class FName* LevelName);
	void ActivateRespawnChamberOnLevel(class FName LevelName);
	void DeactivateRespawnChamberOnLevel(class FName LevelName);
	void TryUpdateCurrentSubLevelName(class FName LevelName, bool* Result);
	void TryCreateLevelLoadingScreenWidget();
	void TryDestroyLevelLoadingScreenWidget();
	void ResetTransientData();
	void RegisterLowFiBehaviorEnemy(class APAWN_Enemy_C* Enemy, bool* Result);
	void UnregisterLowFiBehaviorEnemy(class APAWN_Enemy_C* Enemy, bool* Result);
	void TryPrintDebugLowFiBehaviorMessage(const class FString& Message);
	void TryDrawLowFiBehaviorDebugBox(class APAWN_Enemy_C* Enemy, const struct FLinearColor& Color, const struct FVector& MovementVector);
	void TryStartLowBehaviorTicks(bool* Result);
	void TryStopLowBehaviorTicks(bool* Result);
	void OnTickNextLowFiBehaviorEnemy();
	void PerformLowFiBehaviorForEnemy(class APAWN_Enemy_C* CurrentEnemy, const struct FVector& TargetLocation, const struct FRotator& TargetRotation, float ElapsedTime, float WaitTime, float AcceptanceRadius, class APAWN_Enemy_C* DeadEnemy);
	void ValidateCurrentLowFiState();
	void GetCurrentExploreIntensity(float* Intensity);
	void HasCompletedAchievement(class FName AchievementName, bool* Result);
	void HasCompletedAllAchievements(class FName IgnoreAchievementName, bool* Result);
	void GetMaxCountForAchievement(const struct FDataTableRowHandle& AchievementHandle, int32* Result);
	void GetLinearAchievementProgress(const struct FDataTableRowHandle& AchievementHandle, int32* MaxCount, int32* CurrentCount, class FText* AchivementHandleName);
	void SetCanModifyAchievements(bool State);
	void TrySynchronizeAchievements(bool* Result);
	void TryCompleteBinaryAchievement(const struct FDataTableRowHandle& AchievementHandle, bool* Result);
	void TryIncrementOrderedAchievement(const struct FDataTableRowHandle& AchievementHandle, bool* Result);
	void HasCompletedGameEvent(const struct FDataTableRowHandle& GameEventHandle, bool* Result);
	void TryCompleteGameEvents(TArray<struct FDataTableRowHandle>& GameEvents);
	void SetGameEventState(const struct FDataTableRowHandle& GameEventHandle, bool State);
	void ToggleGameEventState(const struct FDataTableRowHandle& GameEventHandle);
	void TryIncrementUnorderedAchievement(const struct FDataTableRowHandle& AchievementHandle, class UClass* SourceClass, bool* Result);
	void IsGameCountdownCritical(bool* Result);
	void InitializeGameCountdownTimer();
	void TryResumeGameCountdownTimer(bool NotifyPeriodicUpdate, bool* Result);
	void TryStopGameCountdownTimer(bool* Result);
	void ForceResumeGameCountdownTimer(bool NotifyPeriodicUpdate);
	void GetGameCountdownSecondsRemaining(float* Result);
	void OnGameCountdownFinished();
	void EVENT_OnPeriodicGameCountdownUpdate();
	void GetKeycode(class FName Tag, int32* Result);
	void GetUniqueRandomPuzzleName(class UDataTable* DataTable, class AActor* ContextActor, class FName* Result);
	void HasCompletedTutorial(class FName TutorialName, bool* Result);
	void TryCompleteTutorial(class FName TutorialName, bool* Result);
	void IsPublicAddressMessagePlaying(bool* Result);
	void GetPublicAddressElapsedTime(float* Result);
	void CanPublicAddressReachLocation(const struct FVector& QueryLocation, float QueryRadius, bool* Result);
	void CanPlayPublicAddressMessage(const struct FDataTableRowHandle& MediaHandle, bool* Result);
	void ClearPublicAddressData();
	void GetPublicAddressMediaData(TSoftObjectPtr<class USoundCue>* SoundCue, struct FDataTableRowHandle* SpeakerHandle);
	void TryPlaySubtitlesForPublicAddressMessage(float StartTime, bool* Result);
	void TryHideSubtitlesForPublicAddressMessage(bool* Result);
	void OnPublicAddressSoundCueLoaded(class USoundCue* SoundCue, float ElapsedTime);
	void ForceResumePublicAddressMessage(float ElapsedTime);
	void TryResumePublicAddressMessage(bool* Result);
	void TryPlayPublicAddressMessage(const struct FDataTableRowHandle& MediaHandle, const struct FVector& Location, float Radius, bool* Result);
	void TryPlayPublicAddressMessageAtTime(const struct FDataTableRowHandle& MediaHandle, const struct FVector& Location, float Radius, float StartTime, bool* Result);
	void TryStopPublicAddressMessage(bool DoCallbacks, bool* Result);
	void EVENT_OnPublicAddressMessageFinished();
	void TryStopPublicAddressTimer(bool* Result);
	void EVENT_OnAutoSaveAfterDelay();
	void OnTickNextCaptureComponent();
	void TryStartTickingCaptureComponent(class USceneCaptureComponent2D* CaptureComponent, bool* Result);
	void TryStopTickingCaptureComponent(class USceneCaptureComponent2D* CaptureComponent, bool* Result);
	void GetCurrentMusicCue(class UBP_MusicCue_C** Result);
	void GetDeckNumberByLevelName(class FName LevelName, int32* Result);
	void GetLevelNameByDeckSymbol(const class FString& DeckSymbol, class FName* LevelName);
	void GetTemporarilyDisabledTileIndex(class UStaticMeshComponent* TileComponent, int32* Result);
	void GetCurrentlyDisabledTileComponents(TSet<class UStaticMeshComponent*>* Result);
	void AddTemporarilyDisabledTileComponents(TArray<class UStaticMeshComponent*>& TileComponents, float DisableDuration);
	void SetPermanentTileComponentEnableState(TArray<class UStaticMeshComponent*>& TileComponents, bool EnableState);
	void UpdateTileComponentEnableStateInternal(TArray<class UStaticMeshComponent*>& TileComponents, bool EnableState);
	void OnPerformTileEnableTick();
	void TryStartTileEnableTick();
	void RegisterActiveAlarmSpeaker(class ABP_AlarmSpeaker_Base_C* AlarmSpeaker);
	void UnregisterActiveAlarmSpeaker(class ABP_AlarmSpeaker_Base_C* AlarmSpeaker);
	void OnPlayEmergencySound();
	void GetBossEncounterTrap(class APAWN_Enemy_C* EnemyPawn, class ATRAP_BossEncounter_C** Result);
	void SetCurrentCombatIntensity(float Intensity);
	void GetCurrentCombatIntensity(float* Intensity);
	void GetProgressRatioThroughGame(float* Result);
	void PrintAchievementProgress();
	void SetHackerGenderValue(ENUM_HackerGender NewGender);

	bool IsInGame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"GI_SinglePlayer_C">();
	}
	static class UGI_SinglePlayer_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGI_SinglePlayer_C>();
	}
};
static_assert(alignof(UGI_SinglePlayer_C) == 0x000008, "Wrong alignment on UGI_SinglePlayer_C");
static_assert(sizeof(UGI_SinglePlayer_C) == 0x000DB0, "Wrong size on UGI_SinglePlayer_C");
static_assert(offsetof(UGI_SinglePlayer_C, UberGraphFrame) == 0x000228, "Member 'UGI_SinglePlayer_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CurrentLevelName) == 0x000230, "Member 'UGI_SinglePlayer_C::CurrentLevelName' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PreviousLevelName) == 0x000238, "Member 'UGI_SinglePlayer_C::PreviousLevelName' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, QueuedPrimaryLevelToLoad) == 0x000240, "Member 'UGI_SinglePlayer_C::QueuedPrimaryLevelToLoad' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CurrentLevelCollection) == 0x000248, "Member 'UGI_SinglePlayer_C::CurrentLevelCollection' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnSecurityLevelChanged) == 0x000258, "Member 'UGI_SinglePlayer_C::OnSecurityLevelChanged' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, GameCountdownTimerHandle) == 0x000268, "Member 'UGI_SinglePlayer_C::GameCountdownTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, GameCountdownSecondsRemaining) == 0x000270, "Member 'UGI_SinglePlayer_C::GameCountdownSecondsRemaining' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, GameCountdownStartTimestamp) == 0x000274, "Member 'UGI_SinglePlayer_C::GameCountdownStartTimestamp' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, GameCountdownPeriodicUpdateDuration) == 0x000278, "Member 'UGI_SinglePlayer_C::GameCountdownPeriodicUpdateDuration' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LevelStreamingTimeDilation) == 0x00027C, "Member 'UGI_SinglePlayer_C::LevelStreamingTimeDilation' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, VoxelLevelManager) == 0x000280, "Member 'UGI_SinglePlayer_C::VoxelLevelManager' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LevelRespawnChambers) == 0x000288, "Member 'UGI_SinglePlayer_C::LevelRespawnChambers' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CompletedTutorials) == 0x0002D8, "Member 'UGI_SinglePlayer_C::CompletedTutorials' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ChosenPuzzleNames) == 0x000328, "Member 'UGI_SinglePlayer_C::ChosenPuzzleNames' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, VisitedLevels) == 0x000378, "Member 'UGI_SinglePlayer_C::VisitedLevels' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LevelSecurity) == 0x000388, "Member 'UGI_SinglePlayer_C::LevelSecurity' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LevelComputerNodes) == 0x0003D8, "Member 'UGI_SinglePlayer_C::LevelComputerNodes' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, StoryQuests) == 0x000428, "Member 'UGI_SinglePlayer_C::StoryQuests' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnStoryQuestChanged) == 0x000478, "Member 'UGI_SinglePlayer_C::OnStoryQuestChanged' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnStoryQuestNotification) == 0x000488, "Member 'UGI_SinglePlayer_C::OnStoryQuestNotification' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnTutorialCompleted) == 0x000498, "Member 'UGI_SinglePlayer_C::OnTutorialCompleted' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnFinishedLoadingStreamLevel) == 0x0004A8, "Member 'UGI_SinglePlayer_C::OnFinishedLoadingStreamLevel' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnStartUnloadingStreamLevel) == 0x0004B8, "Member 'UGI_SinglePlayer_C::OnStartUnloadingStreamLevel' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnFinishedUnloadingStreamLevel) == 0x0004C8, "Member 'UGI_SinglePlayer_C::OnFinishedUnloadingStreamLevel' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, IsBlockingLoad) == 0x0004D8, "Member 'UGI_SinglePlayer_C::IsBlockingLoad' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, DisableStreaming) == 0x0004D9, "Member 'UGI_SinglePlayer_C::DisableStreaming' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, HasSeenTitleScreen) == 0x0004DA, "Member 'UGI_SinglePlayer_C::HasSeenTitleScreen' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ShouldClearLevelDataAfterLoad) == 0x0004DB, "Member 'UGI_SinglePlayer_C::ShouldClearLevelDataAfterLoad' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LevelNamesToLoad) == 0x0004E0, "Member 'UGI_SinglePlayer_C::LevelNamesToLoad' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LevelNamesToUnload) == 0x0004F0, "Member 'UGI_SinglePlayer_C::LevelNamesToUnload' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnStartLoadingLevelCollection) == 0x000500, "Member 'UGI_SinglePlayer_C::OnStartLoadingLevelCollection' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnStartUnloadingLevelCollection) == 0x000510, "Member 'UGI_SinglePlayer_C::OnStartUnloadingLevelCollection' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnFinishedLoadingLevelCollection) == 0x000520, "Member 'UGI_SinglePlayer_C::OnFinishedLoadingLevelCollection' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnFinishedUnloadingLevelCollection) == 0x000530, "Member 'UGI_SinglePlayer_C::OnFinishedUnloadingLevelCollection' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, StashedTransferItems) == 0x000540, "Member 'UGI_SinglePlayer_C::StashedTransferItems' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LastLevelOffset) == 0x000550, "Member 'UGI_SinglePlayer_C::LastLevelOffset' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnComputerNodesChanged) == 0x000560, "Member 'UGI_SinglePlayer_C::OnComputerNodesChanged' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, QuicksaveSaveName) == 0x000570, "Member 'UGI_SinglePlayer_C::QuicksaveSaveName' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, AutosaveSaveName) == 0x000580, "Member 'UGI_SinglePlayer_C::AutosaveSaveName' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CurrentLoadingLevel) == 0x000590, "Member 'UGI_SinglePlayer_C::CurrentLoadingLevel' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, EnemyToVolumeIndexMap) == 0x000598, "Member 'UGI_SinglePlayer_C::EnemyToVolumeIndexMap' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, EnemyPopulations) == 0x0005E8, "Member 'UGI_SinglePlayer_C::EnemyPopulations' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, EnemyReinforcementVolumeLists) == 0x000638, "Member 'UGI_SinglePlayer_C::EnemyReinforcementVolumeLists' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, EnemyReinforcementDataPerLevel) == 0x000648, "Member 'UGI_SinglePlayer_C::EnemyReinforcementDataPerLevel' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, NextRespawnTimerHandle) == 0x000658, "Member 'UGI_SinglePlayer_C::NextRespawnTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, NextAvailablePatrolPathID) == 0x000660, "Member 'UGI_SinglePlayer_C::NextAvailablePatrolPathID' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LastSpawnedEnemyID) == 0x000664, "Member 'UGI_SinglePlayer_C::LastSpawnedEnemyID' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, FreePatrolPathSet) == 0x000668, "Member 'UGI_SinglePlayer_C::FreePatrolPathSet' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, UsedPatrolPathSet) == 0x0006B8, "Member 'UGI_SinglePlayer_C::UsedPatrolPathSet' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CurrentMusicCue) == 0x000708, "Member 'UGI_SinglePlayer_C::CurrentMusicCue' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, StoppedMusicCues) == 0x000710, "Member 'UGI_SinglePlayer_C::StoppedMusicCues' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, MusicLevelOverride) == 0x000720, "Member 'UGI_SinglePlayer_C::MusicLevelOverride' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, MusicMenuState) == 0x000728, "Member 'UGI_SinglePlayer_C::MusicMenuState' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, MusicGameState) == 0x000729, "Member 'UGI_SinglePlayer_C::MusicGameState' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, MusicGameplayState) == 0x00072A, "Member 'UGI_SinglePlayer_C::MusicGameplayState' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, MusicAmbienceState) == 0x00072B, "Member 'UGI_SinglePlayer_C::MusicAmbienceState' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, GameSettingsSaveSlotName) == 0x000730, "Member 'UGI_SinglePlayer_C::GameSettingsSaveSlotName' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ShockSettings) == 0x000740, "Member 'UGI_SinglePlayer_C::ShockSettings' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, DestructionCodeDigits) == 0x000748, "Member 'UGI_SinglePlayer_C::DestructionCodeDigits' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LoadingScreen) == 0x000758, "Member 'UGI_SinglePlayer_C::LoadingScreen' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, GroupedTrapActors) == 0x000760, "Member 'UGI_SinglePlayer_C::GroupedTrapActors' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, KeycodeSettingsTable) == 0x000770, "Member 'UGI_SinglePlayer_C::KeycodeSettingsTable' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, StoryKeycodes) == 0x000778, "Member 'UGI_SinglePlayer_C::StoryKeycodes' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, RandomTaggedKeycodes) == 0x0007C8, "Member 'UGI_SinglePlayer_C::RandomTaggedKeycodes' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PendingLostItems) == 0x000818, "Member 'UGI_SinglePlayer_C::PendingLostItems' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, SharedLostItems) == 0x000828, "Member 'UGI_SinglePlayer_C::SharedLostItems' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, SharedStorageItems) == 0x000838, "Member 'UGI_SinglePlayer_C::SharedStorageItems' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, SharedStorageLevelName) == 0x000848, "Member 'UGI_SinglePlayer_C::SharedStorageLevelName' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ItemIconCaptureComponent) == 0x000850, "Member 'UGI_SinglePlayer_C::ItemIconCaptureComponent' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ItemDetailsCaptureComponent) == 0x000858, "Member 'UGI_SinglePlayer_C::ItemDetailsCaptureComponent' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ItemGridRenderTargetMap) == 0x000860, "Member 'UGI_SinglePlayer_C::ItemGridRenderTargetMap' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ItemHotbarRenderTargetMap) == 0x0008B0, "Member 'UGI_SinglePlayer_C::ItemHotbarRenderTargetMap' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ItemDetailsRenderTargetMap) == 0x000900, "Member 'UGI_SinglePlayer_C::ItemDetailsRenderTargetMap' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LastItemIconPickupActor) == 0x000950, "Member 'UGI_SinglePlayer_C::LastItemIconPickupActor' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LastItemDetailsPickupActor) == 0x000958, "Member 'UGI_SinglePlayer_C::LastItemDetailsPickupActor' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PendingGridIconRenders) == 0x000960, "Member 'UGI_SinglePlayer_C::PendingGridIconRenders' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PendingHotbarIconRenders) == 0x0009B0, "Member 'UGI_SinglePlayer_C::PendingHotbarIconRenders' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PendingGridIconActors) == 0x000A00, "Member 'UGI_SinglePlayer_C::PendingGridIconActors' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PendingIconTimerHandle) == 0x000A10, "Member 'UGI_SinglePlayer_C::PendingIconTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CurrentCombatIntensity) == 0x000A18, "Member 'UGI_SinglePlayer_C::CurrentCombatIntensity' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CurrentExplorationIntensity) == 0x000A1C, "Member 'UGI_SinglePlayer_C::CurrentExplorationIntensity' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, RegionDiscoverIntensityGain) == 0x000A20, "Member 'UGI_SinglePlayer_C::RegionDiscoverIntensityGain' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, IntensityDecayAmount) == 0x000A24, "Member 'UGI_SinglePlayer_C::IntensityDecayAmount' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, IntensityDecayTime) == 0x000A28, "Member 'UGI_SinglePlayer_C::IntensityDecayTime' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, IntensityDecayTimerHandle) == 0x000A30, "Member 'UGI_SinglePlayer_C::IntensityDecayTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, AsyncSystemComponentRefCounts) == 0x000A38, "Member 'UGI_SinglePlayer_C::AsyncSystemComponentRefCounts' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, AsyncSceneComponentRefCounts) == 0x000A88, "Member 'UGI_SinglePlayer_C::AsyncSceneComponentRefCounts' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, QueuedAsyncSystems) == 0x000AD8, "Member 'UGI_SinglePlayer_C::QueuedAsyncSystems' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, QueuedAsyncSounds) == 0x000B28, "Member 'UGI_SinglePlayer_C::QueuedAsyncSounds' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, DebugReinforcements) == 0x000B78, "Member 'UGI_SinglePlayer_C::DebugReinforcements' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LowFiBehaviorEnemies) == 0x000B80, "Member 'UGI_SinglePlayer_C::LowFiBehaviorEnemies' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CurrentLowFiEnemyIndex) == 0x000B90, "Member 'UGI_SinglePlayer_C::CurrentLowFiEnemyIndex' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LowFiBehaviorTimerHandle) == 0x000B98, "Member 'UGI_SinglePlayer_C::LowFiBehaviorTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, DebugLowFiBehaviorEnemies) == 0x000BA0, "Member 'UGI_SinglePlayer_C::DebugLowFiBehaviorEnemies' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, DefaultCultureFontTable) == 0x000BA8, "Member 'UGI_SinglePlayer_C::DefaultCultureFontTable' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CanModifyAchievements) == 0x000BB0, "Member 'UGI_SinglePlayer_C::CanModifyAchievements' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, HasSynchronizedAchievements) == 0x000BB1, "Member 'UGI_SinglePlayer_C::HasSynchronizedAchievements' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CompletedAllAchievementHandle) == 0x000BB8, "Member 'UGI_SinglePlayer_C::CompletedAllAchievementHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LinearAchievementMap) == 0x000BC8, "Member 'UGI_SinglePlayer_C::LinearAchievementMap' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, UnorderedAchievementMap) == 0x000C18, "Member 'UGI_SinglePlayer_C::UnorderedAchievementMap' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, TileDescriptorManager) == 0x000C68, "Member 'UGI_SinglePlayer_C::TileDescriptorManager' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnPeriodicGameCountdownEvent) == 0x000C70, "Member 'UGI_SinglePlayer_C::OnPeriodicGameCountdownEvent' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PublicAddressTimestamp) == 0x000C80, "Member 'UGI_SinglePlayer_C::PublicAddressTimestamp' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PublicAddressMediaTable) == 0x000C88, "Member 'UGI_SinglePlayer_C::PublicAddressMediaTable' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PublicAddressRowName) == 0x000C90, "Member 'UGI_SinglePlayer_C::PublicAddressRowName' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnPublicAddressStateChanged) == 0x000C98, "Member 'UGI_SinglePlayer_C::OnPublicAddressStateChanged' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PublicAddressLocation) == 0x000CA8, "Member 'UGI_SinglePlayer_C::PublicAddressLocation' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PublicAddressRadius) == 0x000CB4, "Member 'UGI_SinglePlayer_C::PublicAddressRadius' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PublicAddressTimerHandle) == 0x000CB8, "Member 'UGI_SinglePlayer_C::PublicAddressTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, SaveGameLoadFailureText) == 0x000CC0, "Member 'UGI_SinglePlayer_C::SaveGameLoadFailureText' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, AutosaveTimerHandle) == 0x000CD8, "Member 'UGI_SinglePlayer_C::AutosaveTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, TickingCaptureComponents) == 0x000CE0, "Member 'UGI_SinglePlayer_C::TickingCaptureComponents' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, LastTickedCaptureComponentIndex) == 0x000CF0, "Member 'UGI_SinglePlayer_C::LastTickedCaptureComponentIndex' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, SceneCaptureTimerHandle) == 0x000CF8, "Member 'UGI_SinglePlayer_C::SceneCaptureTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, PermDisabledTileComponents) == 0x000D00, "Member 'UGI_SinglePlayer_C::PermDisabledTileComponents' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, TempDisabledTileComponents) == 0x000D50, "Member 'UGI_SinglePlayer_C::TempDisabledTileComponents' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, TileComponentEnableTimerHandle) == 0x000D60, "Member 'UGI_SinglePlayer_C::TileComponentEnableTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnPendingLostItemsChanged) == 0x000D68, "Member 'UGI_SinglePlayer_C::OnPendingLostItemsChanged' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, AlarmLightTimerHandle) == 0x000D78, "Member 'UGI_SinglePlayer_C::AlarmLightTimerHandle' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, ActiveAlarmSpeakers) == 0x000D80, "Member 'UGI_SinglePlayer_C::ActiveAlarmSpeakers' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, CachedLoadingHUDWidget) == 0x000D90, "Member 'UGI_SinglePlayer_C::CachedLoadingHUDWidget' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, HackerGender) == 0x000D98, "Member 'UGI_SinglePlayer_C::HackerGender' has a wrong offset!");
static_assert(offsetof(UGI_SinglePlayer_C, OnControllerConnectionStateChange) == 0x000DA0, "Member 'UGI_SinglePlayer_C::OnControllerConnectionStateChange' has a wrong offset!");

}

