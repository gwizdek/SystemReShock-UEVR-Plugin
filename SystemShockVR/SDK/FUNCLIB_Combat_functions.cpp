#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FUNCLIB_Combat

#include "Basic.hpp"

#include "FUNCLIB_Combat_classes.hpp"
#include "FUNCLIB_Combat_parameters.hpp"


namespace SDK
{

// Function FUNCLIB_Combat.FUNCLIB_Combat_C.HasClearShotToTargetFromLocation
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          BarrelLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BulletRadius                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UFUNCLIB_Combat_C::HasClearShotToTargetFromLocation(class APAWN_Enemy_C* Enemy, const struct FVector& BarrelLocation, float BulletRadius, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "HasClearShotToTargetFromLocation");

	Params::FUNCLIB_Combat_C_HasClearShotToTargetFromLocation Parms{};

	Parms.Enemy = Enemy;
	Parms.BarrelLocation = std::move(BarrelLocation);
	Parms.BulletRadius = BulletRadius;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.HasClearShotToTargetFromSocket
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_Enemy_C*                    Enemy                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             BarrelSocket                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BulletRadius                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UFUNCLIB_Combat_C::HasClearShotToTargetFromSocket(class APAWN_Enemy_C* Enemy, class FName BarrelSocket, float BulletRadius, class UObject* __WorldContext, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "HasClearShotToTargetFromSocket");

	Params::FUNCLIB_Combat_C_HasClearShotToTargetFromSocket Parms{};

	Parms.Enemy = Enemy;
	Parms.BarrelSocket = BarrelSocket;
	Parms.BulletRadius = BulletRadius;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetEffectiveArmorRatioFromDamage
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FAttribDamageInstance            DamageInstance                                         (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlockRatio                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetEffectiveArmorRatioFromDamage(const struct FAttribDamageInstance& DamageInstance, class UObject* __WorldContext, float* BlockRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetEffectiveArmorRatioFromDamage");

	Params::FUNCLIB_Combat_C_GetEffectiveArmorRatioFromDamage Parms{};

	Parms.DamageInstance = std::move(DamageInstance);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (BlockRatio != nullptr)
		*BlockRatio = Parms.BlockRatio;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetMaxCombatTraceDistance
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetMaxCombatTraceDistance(class UObject* __WorldContext, float* Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetMaxCombatTraceDistance");

	Params::FUNCLIB_Combat_C_GetMaxCombatTraceDistance Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Distance != nullptr)
		*Distance = Parms.Distance;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetSkillTargetAimLocation
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APAWN_Enemy_C*                    SourcePawn                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Locations                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetSkillTargetAimLocation(class APAWN_Enemy_C* SourcePawn, class UObject* __WorldContext, struct FVector* Locations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetSkillTargetAimLocation");

	Params::FUNCLIB_Combat_C_GetSkillTargetAimLocation Parms{};

	Parms.SourcePawn = SourcePawn;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetScaledCombatDamage
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   BaseDamage                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsCyberspace                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DamageValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetScaledCombatDamage(int32 BaseDamage, bool IsCyberspace, class UObject* __WorldContext, int32* DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetScaledCombatDamage");

	Params::FUNCLIB_Combat_C_GetScaledCombatDamage Parms{};

	Parms.BaseDamage = BaseDamage;
	Parms.IsCyberspace = IsCyberspace;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DamageValue != nullptr)
		*DamageValue = Parms.DamageValue;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetScaledEnemyStatsDamage
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle              EnemyStatsRowHandle                                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// ENUM_EnemyAttackType                    AttackType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DamageValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetScaledEnemyStatsDamage(const struct FDataTableRowHandle& EnemyStatsRowHandle, ENUM_EnemyAttackType AttackType, class UObject* __WorldContext, int32* DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetScaledEnemyStatsDamage");

	Params::FUNCLIB_Combat_C_GetScaledEnemyStatsDamage Parms{};

	Parms.EnemyStatsRowHandle = std::move(EnemyStatsRowHandle);
	Parms.AttackType = AttackType;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DamageValue != nullptr)
		*DamageValue = Parms.DamageValue;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetScaledEnemyDamage
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APAWN_Enemy_C*                    Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ENUM_EnemyAttackType                    AttackType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DamageValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetScaledEnemyDamage(class APAWN_Enemy_C* Pawn, ENUM_EnemyAttackType AttackType, class UObject* __WorldContext, int32* DamageValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetScaledEnemyDamage");

	Params::FUNCLIB_Combat_C_GetScaledEnemyDamage Parms{};

	Parms.Pawn = Pawn;
	Parms.AttackType = AttackType;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DamageValue != nullptr)
		*DamageValue = Parms.DamageValue;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetSolidShieldPhysicalMaterial
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPhysicalMaterial*                Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetSolidShieldPhysicalMaterial(class UObject* __WorldContext, class UPhysicalMaterial** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetSolidShieldPhysicalMaterial");

	Params::FUNCLIB_Combat_C_GetSolidShieldPhysicalMaterial Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetPermeableShieldPhysicalMaterial
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPhysicalMaterial*                Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetPermeableShieldPhysicalMaterial(class UObject* __WorldContext, class UPhysicalMaterial** Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetPermeableShieldPhysicalMaterial");

	Params::FUNCLIB_Combat_C_GetPermeableShieldPhysicalMaterial Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetAccuracyAdjustedRandomTargetDirection
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BarrelLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TargetLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Accuracy                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        MinMaxSpreadRadius                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxRangeForSpreadCals                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          AdjustedTargetDirection                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetAccuracyAdjustedRandomTargetDirection(const struct FVector& BarrelLocation, const struct FVector& TargetLocation, float Accuracy, const struct FVector2D& MinMaxSpreadRadius, float MaxRangeForSpreadCals, class UObject* __WorldContext, struct FVector* AdjustedTargetDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetAccuracyAdjustedRandomTargetDirection");

	Params::FUNCLIB_Combat_C_GetAccuracyAdjustedRandomTargetDirection Parms{};

	Parms.BarrelLocation = std::move(BarrelLocation);
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.Accuracy = Accuracy;
	Parms.MinMaxSpreadRadius = std::move(MinMaxSpreadRadius);
	Parms.MaxRangeForSpreadCals = MaxRangeForSpreadCals;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AdjustedTargetDirection != nullptr)
		*AdjustedTargetDirection = std::move(Parms.AdjustedTargetDirection);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetRandomWeaponSpreadDirection
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BarrelDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   SpreadHalfAngle                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          SpreadDirection                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetRandomWeaponSpreadDirection(const struct FVector& BarrelDirection, float SpreadHalfAngle, class UObject* __WorldContext, struct FVector* SpreadDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetRandomWeaponSpreadDirection");

	Params::FUNCLIB_Combat_C_GetRandomWeaponSpreadDirection Parms{};

	Parms.BarrelDirection = std::move(BarrelDirection);
	Parms.SpreadHalfAngle = SpreadHalfAngle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SpreadDirection != nullptr)
		*SpreadDirection = std::move(Parms.SpreadDirection);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetExactWeaponSpreadDirection
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BarrelDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ActualDeviationAngle                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          SpreadDirection                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetExactWeaponSpreadDirection(const struct FVector& BarrelDirection, float ActualDeviationAngle, class UObject* __WorldContext, struct FVector* SpreadDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetExactWeaponSpreadDirection");

	Params::FUNCLIB_Combat_C_GetExactWeaponSpreadDirection Parms{};

	Parms.BarrelDirection = std::move(BarrelDirection);
	Parms.ActualDeviationAngle = ActualDeviationAngle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SpreadDirection != nullptr)
		*SpreadDirection = std::move(Parms.SpreadDirection);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetLaunchVelocityForProjectile
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   Speed                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          VectorToTarget                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Gravity                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Veclocity                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetLaunchVelocityForProjectile(float Speed, const struct FVector& VectorToTarget, float Gravity, class UObject* __WorldContext, struct FVector* Veclocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetLaunchVelocityForProjectile");

	Params::FUNCLIB_Combat_C_GetLaunchVelocityForProjectile Parms{};

	Parms.Speed = Speed;
	Parms.VectorToTarget = std::move(VectorToTarget);
	Parms.Gravity = Gravity;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Veclocity != nullptr)
		*Veclocity = std::move(Parms.Veclocity);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.ApplyExplosiveDamageAndImpulse
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BlastLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlastRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlastImpulse                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MinimumDamage                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaximumDamage                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ArmorPenetration                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           IgnoreActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IgnoreSameInstigator                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class UAttribMod*, struct FAttribDamageInstance>DamageInstances                                        (Parm, OutParm)

void UFUNCLIB_Combat_C::ApplyExplosiveDamageAndImpulse(const struct FVector& BlastLocation, float BlastRadius, float BlastImpulse, float MinimumDamage, float MaximumDamage, int32 ArmorPenetration, class AActor* IgnoreActor, bool IgnoreSameInstigator, class UObject* __WorldContext, TMap<class UAttribMod*, struct FAttribDamageInstance>* DamageInstances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "ApplyExplosiveDamageAndImpulse");

	Params::FUNCLIB_Combat_C_ApplyExplosiveDamageAndImpulse Parms{};

	Parms.BlastLocation = std::move(BlastLocation);
	Parms.BlastRadius = BlastRadius;
	Parms.BlastImpulse = BlastImpulse;
	Parms.MinimumDamage = MinimumDamage;
	Parms.MaximumDamage = MaximumDamage;
	Parms.ArmorPenetration = ArmorPenetration;
	Parms.IgnoreActor = IgnoreActor;
	Parms.IgnoreSameInstigator = IgnoreSameInstigator;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DamageInstances != nullptr)
		*DamageInstances = std::move(Parms.DamageInstances);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.ApplyRadialDamageAndImpulse
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BlastLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlastRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlastImpulse                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAttribDamageType*                DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MinimumDamage                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaximumDamage                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ArmorPenetration                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           IgnoreActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IgnoreSameInstigator                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TMap<class UAttribMod*, struct FAttribDamageInstance>DamageInstances                                        (Parm, OutParm)

void UFUNCLIB_Combat_C::ApplyRadialDamageAndImpulse(const struct FVector& BlastLocation, float BlastRadius, float BlastImpulse, class UAttribDamageType* DamageType, float MinimumDamage, float MaximumDamage, int32 ArmorPenetration, class AActor* IgnoreActor, bool IgnoreSameInstigator, class UObject* __WorldContext, TMap<class UAttribMod*, struct FAttribDamageInstance>* DamageInstances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "ApplyRadialDamageAndImpulse");

	Params::FUNCLIB_Combat_C_ApplyRadialDamageAndImpulse Parms{};

	Parms.BlastLocation = std::move(BlastLocation);
	Parms.BlastRadius = BlastRadius;
	Parms.BlastImpulse = BlastImpulse;
	Parms.DamageType = DamageType;
	Parms.MinimumDamage = MinimumDamage;
	Parms.MaximumDamage = MaximumDamage;
	Parms.ArmorPenetration = ArmorPenetration;
	Parms.IgnoreActor = IgnoreActor;
	Parms.IgnoreSameInstigator = IgnoreSameInstigator;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DamageInstances != nullptr)
		*DamageInstances = std::move(Parms.DamageInstances);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.ComputeExplosiveDamageAtDistance
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   DistanceFromEpicenter                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlastRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MinDamage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxDamage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Damage                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::ComputeExplosiveDamageAtDistance(float DistanceFromEpicenter, float BlastRadius, float MinDamage, float MaxDamage, class UObject* __WorldContext, float* Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "ComputeExplosiveDamageAtDistance");

	Params::FUNCLIB_Combat_C_ComputeExplosiveDamageAtDistance Parms{};

	Parms.DistanceFromEpicenter = DistanceFromEpicenter;
	Parms.BlastRadius = BlastRadius;
	Parms.MinDamage = MinDamage;
	Parms.MaxDamage = MaxDamage;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Damage != nullptr)
		*Damage = Parms.Damage;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.ComputeExplosiveImpulseAtDistance
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   DistanceFromEpicenter                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlastRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlastImpulse                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Impulse                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::ComputeExplosiveImpulseAtDistance(float DistanceFromEpicenter, float BlastRadius, float BlastImpulse, class UObject* __WorldContext, float* Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "ComputeExplosiveImpulseAtDistance");

	Params::FUNCLIB_Combat_C_ComputeExplosiveImpulseAtDistance Parms{};

	Parms.DistanceFromEpicenter = DistanceFromEpicenter;
	Parms.BlastRadius = BlastRadius;
	Parms.BlastImpulse = BlastImpulse;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Impulse != nullptr)
		*Impulse = Parms.Impulse;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetRequiredMuzzleSpeedForBullet
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          BarrelDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          VectorToTarget                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Gravity                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetRequiredMuzzleSpeedForBullet(const struct FVector& BarrelDirection, const struct FVector& VectorToTarget, float Gravity, class UObject* __WorldContext, float* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetRequiredMuzzleSpeedForBullet");

	Params::FUNCLIB_Combat_C_GetRequiredMuzzleSpeedForBullet Parms{};

	Parms.BarrelDirection = std::move(BarrelDirection);
	Parms.VectorToTarget = std::move(VectorToTarget);
	Parms.Gravity = Gravity;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.DamageCharacterShieldsAlongRay
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          TraceLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TraceDirection                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceDistance                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ProjectileRadius                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DamageValue                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   IgnoreActors                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class APAWN_SystemShockCharacter_C*     TraceHitCharacter                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSet<class APAWN_SystemShockCharacter_C*>InOutHitCharacters                                     (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    BlockingHit                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UFUNCLIB_Combat_C::DamageCharacterShieldsAlongRay(const struct FVector& TraceLocation, const struct FVector& TraceDirection, float TraceDistance, float ProjectileRadius, float DamageValue, TArray<class AActor*>& IgnoreActors, class APAWN_SystemShockCharacter_C* TraceHitCharacter, TSet<class APAWN_SystemShockCharacter_C*>& InOutHitCharacters, class UObject* __WorldContext, bool* BlockingHit, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "DamageCharacterShieldsAlongRay");

	Params::FUNCLIB_Combat_C_DamageCharacterShieldsAlongRay Parms{};

	Parms.TraceLocation = std::move(TraceLocation);
	Parms.TraceDirection = std::move(TraceDirection);
	Parms.TraceDistance = TraceDistance;
	Parms.ProjectileRadius = ProjectileRadius;
	Parms.DamageValue = DamageValue;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.TraceHitCharacter = TraceHitCharacter;
	Parms.InOutHitCharacters = std::move(InOutHitCharacters);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	IgnoreActors = std::move(Parms.IgnoreActors);
	InOutHitCharacters = std::move(Parms.InOutHitCharacters);

	if (BlockingHit != nullptr)
		*BlockingHit = Parms.BlockingHit;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetForceFeedbackExplosionAttenuation
// (Static, Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   BlastRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UForceFeedbackAttenuation*        Attenuation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetForceFeedbackExplosionAttenuation(float BlastRadius, class UObject* __WorldContext, class UForceFeedbackAttenuation** Attenuation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetForceFeedbackExplosionAttenuation");

	Params::FUNCLIB_Combat_C_GetForceFeedbackExplosionAttenuation Parms{};

	Parms.BlastRadius = BlastRadius;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Attenuation != nullptr)
		*Attenuation = Parms.Attenuation;
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetComponentOriginForExplosiveDamage
// (Static, Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Origin                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetComponentOriginForExplosiveDamage(class UPrimitiveComponent* PrimitiveComponent, class UObject* __WorldContext, struct FVector* Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetComponentOriginForExplosiveDamage");

	Params::FUNCLIB_Combat_C_GetComponentOriginForExplosiveDamage Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Origin != nullptr)
		*Origin = std::move(Parms.Origin);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.TryDamageSpecificCharacterShieldsAlongRay
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APAWN_SystemShockCharacter_C*     Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TraceLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TraceDirection                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceDistance                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ImpactRadius                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DamageValue                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APAWN_SystemShockCharacter_C*     TraceHitCharacter                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ShieldHit                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    BlockingHit                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       HitResult                                              (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UFUNCLIB_Combat_C::TryDamageSpecificCharacterShieldsAlongRay(class APAWN_SystemShockCharacter_C* Character, const struct FVector& TraceLocation, const struct FVector& TraceDirection, float TraceDistance, float ImpactRadius, float DamageValue, class APAWN_SystemShockCharacter_C* TraceHitCharacter, class UObject* __WorldContext, bool* ShieldHit, bool* BlockingHit, struct FHitResult* HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "TryDamageSpecificCharacterShieldsAlongRay");

	Params::FUNCLIB_Combat_C_TryDamageSpecificCharacterShieldsAlongRay Parms{};

	Parms.Character = Character;
	Parms.TraceLocation = std::move(TraceLocation);
	Parms.TraceDirection = std::move(TraceDirection);
	Parms.TraceDistance = TraceDistance;
	Parms.ImpactRadius = ImpactRadius;
	Parms.DamageValue = DamageValue;
	Parms.TraceHitCharacter = TraceHitCharacter;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ShieldHit != nullptr)
		*ShieldHit = Parms.ShieldHit;

	if (BlockingHit != nullptr)
		*BlockingHit = Parms.BlockingHit;

	if (HitResult != nullptr)
		*HitResult = std::move(Parms.HitResult);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.GetBestAimTargetLocation
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BarrelLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UOBJ_EnemyTarget_C*               Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          BestTargetLocation                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::GetBestAimTargetLocation(const struct FVector& BarrelLocation, class UOBJ_EnemyTarget_C* Target, class UObject* __WorldContext, struct FVector* BestTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "GetBestAimTargetLocation");

	Params::FUNCLIB_Combat_C_GetBestAimTargetLocation Parms{};

	Parms.BarrelLocation = std::move(BarrelLocation);
	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (BestTargetLocation != nullptr)
		*BestTargetLocation = std::move(Parms.BestTargetLocation);
}


// Function FUNCLIB_Combat.FUNCLIB_Combat_C.ClampDirectionInCone
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          TargetDirection                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ConeDirection                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ConeAngle                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ClampedDirection                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFUNCLIB_Combat_C::ClampDirectionInCone(const struct FVector& TargetDirection, const struct FVector& ConeDirection, float ConeAngle, class UObject* __WorldContext, struct FVector* ClampedDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FUNCLIB_Combat_C", "ClampDirectionInCone");

	Params::FUNCLIB_Combat_C_ClampDirectionInCone Parms{};

	Parms.TargetDirection = std::move(TargetDirection);
	Parms.ConeDirection = std::move(ConeDirection);
	Parms.ConeAngle = ConeAngle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ClampedDirection != nullptr)
		*ClampedDirection = std::move(Parms.ClampedDirection);
}

}

