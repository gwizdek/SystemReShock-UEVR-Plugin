#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AttributeSystem

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "AttributeSystem_structs.hpp"


namespace SDK
{

// Class AttributeSystem.AttribDamageType
// 0x0078 (0x00A8 - 0x0030)
class UAttribDamageType final : public UDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   ShortDisplayName;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAttributeDef>           ResistAttrib;                                      // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreShields;                                    // 0x00A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttribDamageType">();
	}
	static class UAttribDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttribDamageType>();
	}
};
static_assert(alignof(UAttribDamageType) == 0x000008, "Wrong alignment on UAttribDamageType");
static_assert(sizeof(UAttribDamageType) == 0x0000A8, "Wrong size on UAttribDamageType");
static_assert(offsetof(UAttribDamageType, DisplayName) == 0x000030, "Member 'UAttribDamageType::DisplayName' has a wrong offset!");
static_assert(offsetof(UAttribDamageType, ShortDisplayName) == 0x000048, "Member 'UAttribDamageType::ShortDisplayName' has a wrong offset!");
static_assert(offsetof(UAttribDamageType, Description) == 0x000060, "Member 'UAttribDamageType::Description' has a wrong offset!");
static_assert(offsetof(UAttribDamageType, ResistAttrib) == 0x000078, "Member 'UAttribDamageType::ResistAttrib' has a wrong offset!");
static_assert(offsetof(UAttribDamageType, bIgnoreShields) == 0x0000A0, "Member 'UAttribDamageType::bIgnoreShields' has a wrong offset!");

// Class AttributeSystem.AttribHandler
// 0x00B8 (0x00E0 - 0x0028)
class UAttribHandler final : public UObject
{
public:
	TArray<class UAttribInstance*>                ActiveInstances;                                   // 0x0028(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class UAttributeDef*, class UAttribInstance*> AttribInstanceMap;                                 // 0x0038(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	TMap<class UAttributeDef*, TDelegate<void()>> PendingAttribValueChangedBinds;                    // 0x0088(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAttribMod* ApplyMod(class AActor* SourceActor, const struct FAttribModApplyData& Data);
	TArray<class UAttribMod*> ApplyMods(class AActor* SourceActor, const TArray<struct FAttribModApplyData>& DataArray);
	void BeginPlay();
	void EndPlay();
	bool ExpireMod(class UAttribMod* Mod);
	int32 ExpireModsFromSourceActor(class AActor* SourceActor);
	int32 ExpireModsWithCategories(const TArray<class FName>& Categories);
	int32 ExpireModsWithCategory(class FName Category);
	class UAttribInstance* GetAttribInstance(class UAttributeDef* Attrib);
	float GetAttribValue(class UAttributeDef* Attrib);
	class UAttribInstance* GetOrCreateAttribInstance(class UAttributeDef* Attrib);
	void InitializeDefaultAttribs(const TArray<struct FDefaultAttribute>& Attribs, const TArray<struct FEnumHandle>& TierEnums);
	void InitializeDefaultAttribsWithOverrides(const TArray<struct FDefaultAttribute>& Attribs, const TArray<struct FDefaultAttribute>& AttribOverrides, const TArray<struct FEnumHandle>& TierEnums);
	void K2_OnBeginPlay();
	void K2_OnGetElapsedPlayTime(float* PlayTime);

	TArray<class UAttribMod*> GetActiveModsWithCategories(const TArray<class FName>& Categories, bool bExcludeExpiringMods) const;
	class UAttribMod* GetActiveModWithCategory(class FName Category, class AActor* SourceActor, bool bExcludeExpiringMods) const;
	class AActor* GetOwner() const;
	bool HasActiveModWithCategory(class FName Category, bool bExcludeExpiringMods) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttribHandler">();
	}
	static class UAttribHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttribHandler>();
	}
};
static_assert(alignof(UAttribHandler) == 0x000008, "Wrong alignment on UAttribHandler");
static_assert(sizeof(UAttribHandler) == 0x0000E0, "Wrong size on UAttribHandler");
static_assert(offsetof(UAttribHandler, ActiveInstances) == 0x000028, "Member 'UAttribHandler::ActiveInstances' has a wrong offset!");
static_assert(offsetof(UAttribHandler, AttribInstanceMap) == 0x000038, "Member 'UAttribHandler::AttribInstanceMap' has a wrong offset!");
static_assert(offsetof(UAttribHandler, PendingAttribValueChangedBinds) == 0x000088, "Member 'UAttribHandler::PendingAttribValueChangedBinds' has a wrong offset!");

// Class AttributeSystem.AttribInstance
// 0x0140 (0x0168 - 0x0028)
class UAttribInstance final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnAttribInstanceCreated;                           // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAttribValueChanged;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAttribBaseValueChanged;                          // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAttribValueDepleted;                             // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAttribValueMaxed;                                // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnModApplied;                                      // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnModExpired;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UAttributeDef*                          Attrib;                                            // 0x0098(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UAttribMod*>                     ActiveMods;                                        // 0x00A0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TArray<class UAttribMod*>                     DependentMods;                                     // 0x00B0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	class UAttribInstance*                        CachedMinAttribInstance;                           // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAttribInstance*                        CachedMaxAttribInstance;                           // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x98];                                      // 0x00D0(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExpireAllMods();
	int32 ExpireModsFromSourceActor(class AActor* SourceActor);
	int32 ExpireModsMatchingCategory(class FName Category);
	int32 ExpireModsWithCategories(const TArray<class FName>& Categories);
	struct FAttribModResult SetBaseValue(float Value);
	void SetLocked(bool bState);

	TArray<class UAttribMod*> GetActiveModsWithApplyType(EModApplyType ApplyType) const;
	TArray<class UAttribMod*> GetActiveModsWithCategories(const TArray<class FName>& Categories, bool bExcludeExpiringMods) const;
	class UAttribMod* GetActiveModWithCategory(class FName Category, class AActor* SourceActor, bool bExcludeExpiringMods) const;
	float GetAddBonusValue() const;
	class UAttributeDef* GetAttrib() const;
	class UAttribHandler* GetAttribHandler() const;
	float GetBaseValue() const;
	class UAttribInstance* GetMaxAttribInstance() const;
	float GetMaxValue() const;
	class UAttribInstance* GetMinAttribInstance() const;
	float GetMulBonusValue() const;
	float GetTimeSinceLastUpdate() const;
	float GetValue() const;
	bool HasActiveMods() const;
	bool HasActiveModWithCategory(class FName Category, bool bExcludeExpiringMods) const;
	bool IsLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttribInstance">();
	}
	static class UAttribInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttribInstance>();
	}
};
static_assert(alignof(UAttribInstance) == 0x000008, "Wrong alignment on UAttribInstance");
static_assert(sizeof(UAttribInstance) == 0x000168, "Wrong size on UAttribInstance");
static_assert(offsetof(UAttribInstance, OnAttribInstanceCreated) == 0x000028, "Member 'UAttribInstance::OnAttribInstanceCreated' has a wrong offset!");
static_assert(offsetof(UAttribInstance, OnAttribValueChanged) == 0x000038, "Member 'UAttribInstance::OnAttribValueChanged' has a wrong offset!");
static_assert(offsetof(UAttribInstance, OnAttribBaseValueChanged) == 0x000048, "Member 'UAttribInstance::OnAttribBaseValueChanged' has a wrong offset!");
static_assert(offsetof(UAttribInstance, OnAttribValueDepleted) == 0x000058, "Member 'UAttribInstance::OnAttribValueDepleted' has a wrong offset!");
static_assert(offsetof(UAttribInstance, OnAttribValueMaxed) == 0x000068, "Member 'UAttribInstance::OnAttribValueMaxed' has a wrong offset!");
static_assert(offsetof(UAttribInstance, OnModApplied) == 0x000078, "Member 'UAttribInstance::OnModApplied' has a wrong offset!");
static_assert(offsetof(UAttribInstance, OnModExpired) == 0x000088, "Member 'UAttribInstance::OnModExpired' has a wrong offset!");
static_assert(offsetof(UAttribInstance, Attrib) == 0x000098, "Member 'UAttribInstance::Attrib' has a wrong offset!");
static_assert(offsetof(UAttribInstance, ActiveMods) == 0x0000A0, "Member 'UAttribInstance::ActiveMods' has a wrong offset!");
static_assert(offsetof(UAttribInstance, DependentMods) == 0x0000B0, "Member 'UAttribInstance::DependentMods' has a wrong offset!");
static_assert(offsetof(UAttribInstance, CachedMinAttribInstance) == 0x0000C0, "Member 'UAttribInstance::CachedMinAttribInstance' has a wrong offset!");
static_assert(offsetof(UAttribInstance, CachedMaxAttribInstance) == 0x0000C8, "Member 'UAttribInstance::CachedMaxAttribInstance' has a wrong offset!");

// Class AttributeSystem.AttribManagerComponent
// 0x00F0 (0x01A0 - 0x00B0)
class UAttribManagerComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDamageReceived;                                  // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDamageDealt;                                     // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAttributeDef>           HealthAttrib;                                      // 0x00E0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAttributeDef>           ArmorAttrib;                                       // 0x0108(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAttributeDef>           ShieldAttrib;                                      // 0x0130(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDefaultAttribute>              DefaultAttribs;                                    // 0x0158(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAttribModApplyData>            DefaultMods;                                       // 0x0168(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bLogDamageDealt;                                   // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttribHandler*                         AttribHandler;                                     // 0x0180(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x18];                                     // 0x0188(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UAttribMod* ApplyCompoundMod(class AActor* SourceActor, const struct FAttribModApplyData& Data, const struct FAttribModApplyData& ApplyDataOnExpire);
	class UAttribMod* ApplyDamageMod(class AActor* SourceActor, const struct FAttribModApplyData& Data, struct FAttribDamageInstance* OutDamageInstance);
	class UAttribMod* ApplyMod(class AActor* SourceActor, const struct FAttribModApplyData& Data);
	TArray<class UAttribMod*> ApplyMods(class AActor* SourceActor, const TArray<struct FAttribModApplyData>& DataArray);
	void BindToAttribValueChanged(class UAttributeDef* Attrib, const TDelegate<void(float CurrValue, float LastValue)>& Delegate);
	void DestroyAttributeHandler();
	bool DestroyAttributeInstance(class UAttributeDef* Attrib);
	void DestroyAttributeInstances(const TArray<class UAttributeDef*>& KeepAttributes);
	bool ExpireMod(class UAttribMod* Mod);
	int32 ExpireModsFromSourceActor(class AActor* SourceActor);
	int32 ExpireModsWithCategories(const TArray<class FName>& Categories);
	int32 ExpireModsWithCategory(class FName Category);
	float GetArmorAugmentation(class AActor* SourceActor, class UAttribDamageType* DamageType, class UObject* UserParams);
	class UAttribInstance* GetAttribInstance(class UAttributeDef* Attrib);
	float GetAttribValue(class UAttributeDef* Attrib);
	float GetExploitDamage(class AActor* SourceActor, class UAttribDamageType* DamageType, class UObject* UserParams);
	class UAttribInstance* GetOrCreateAttribInstance(class UAttributeDef* Attrib);
	void InitializeAttributes(bool bGrantDefaultAttribs);
	void InitializeTieredAttributes(bool bGrantDefaultAttribs, const TArray<struct FEnumHandle>& TierEnums);
	void InitializeTieredAttributesWithOverrides(bool bGrantDefaultAttribs, const TArray<struct FDefaultAttribute>& AttribOverrides, const TArray<struct FEnumHandle>& TierEnums);
	void K2_OnGetElapsedPlayTime(float* PlayTime);

	TArray<class UAttribMod*> GetActiveModsWithCategories(const TArray<class FName>& Categories, bool bExcludeExpiringMods) const;
	class UAttribMod* GetActiveModWithCategory(class FName Category, class AActor* SourceActor, bool bExcludeExpiringMods) const;
	class UAttributeDef* GetArmorAttrib() const;
	float GetDefaultAttribValue(class UAttributeDef* Attrib) const;
	class UAttributeDef* GetHealthAttrib() const;
	class UAttributeDef* GetShieldAttrib() const;
	bool HasActiveModWithCategory(class FName Category, bool bExcludeExpiringMods) const;
	bool HasArmorAttrib() const;
	bool HasAttribHandler() const;
	bool HasHealthAttrib() const;
	bool HasInitializedAttributes() const;
	bool HasShieldAttrib() const;
	bool IsDamageReceivedBound() const;
	bool IsHealthAttrib(class UAttributeDef* Attrib) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttribManagerComponent">();
	}
	static class UAttribManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttribManagerComponent>();
	}
};
static_assert(alignof(UAttribManagerComponent) == 0x000008, "Wrong alignment on UAttribManagerComponent");
static_assert(sizeof(UAttribManagerComponent) == 0x0001A0, "Wrong size on UAttribManagerComponent");
static_assert(offsetof(UAttribManagerComponent, OnDamageReceived) == 0x0000C0, "Member 'UAttribManagerComponent::OnDamageReceived' has a wrong offset!");
static_assert(offsetof(UAttribManagerComponent, OnDamageDealt) == 0x0000D0, "Member 'UAttribManagerComponent::OnDamageDealt' has a wrong offset!");
static_assert(offsetof(UAttribManagerComponent, HealthAttrib) == 0x0000E0, "Member 'UAttribManagerComponent::HealthAttrib' has a wrong offset!");
static_assert(offsetof(UAttribManagerComponent, ArmorAttrib) == 0x000108, "Member 'UAttribManagerComponent::ArmorAttrib' has a wrong offset!");
static_assert(offsetof(UAttribManagerComponent, ShieldAttrib) == 0x000130, "Member 'UAttribManagerComponent::ShieldAttrib' has a wrong offset!");
static_assert(offsetof(UAttribManagerComponent, DefaultAttribs) == 0x000158, "Member 'UAttribManagerComponent::DefaultAttribs' has a wrong offset!");
static_assert(offsetof(UAttribManagerComponent, DefaultMods) == 0x000168, "Member 'UAttribManagerComponent::DefaultMods' has a wrong offset!");
static_assert(offsetof(UAttribManagerComponent, bLogDamageDealt) == 0x000178, "Member 'UAttribManagerComponent::bLogDamageDealt' has a wrong offset!");
static_assert(offsetof(UAttribManagerComponent, AttribHandler) == 0x000180, "Member 'UAttribManagerComponent::AttribHandler' has a wrong offset!");

// Class AttributeSystem.AttribMod
// 0x0100 (0x0128 - 0x0028)
class UAttribMod final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnAttribModTick;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAttribValueChanged;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	EModApplyType                                 ApplyType;                                         // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EModStackType                                 StackType;                                         // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EModExpireFlags                               ExpireFlags;                                       // 0x004A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttribModFlags                               ModFlags;                                          // 0x004B(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAttribDamageType*                      DamageType;                                        // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EModOpType                                    BonusType;                                         // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EModNormalizedFuncType                        FunctionType;                                      // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Category;                                          // 0x005C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TickCount;                                         // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentTickCount;                                  // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RampUpTime;                                        // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RampDownTime;                                      // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmorPenetration;                                  // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PierceResistance;                                  // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CriticalChance;                                    // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CriticalDamage;                                    // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ExpireModCategoriesOnApply;                        // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAttribModApplyDataBase>        ApplyOnExpireMods;                                 // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	class UAttribInstance*                        DependsOnAttribInstance;                           // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAttribInstance*                        ScaleAttribInstance;                               // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            TickRateCurve;                                     // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 SourceActor;                                       // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                UserParams;                                        // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoftMinValue;                                      // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoftMaxValue;                                      // 0x00D4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x50];                                      // 0x00D8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTickCount(int32 CountToAdd);
	void SetTickRate(float Rate);
	void SetValue(float NewValue);

	float GetProgress() const;
	class AActor* GetTargetActor() const;
	class UAttribInstance* GetTargetAttribInstance() const;
	float GetTickRate() const;
	float GetTimeSinceCreation() const;
	float GetValue() const;
	bool HasExpired() const;
	bool IsActive() const;
	bool IsExpiring() const;
	bool ShouldExpireBy(EModExpireFlags Flags_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttribMod">();
	}
	static class UAttribMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttribMod>();
	}
};
static_assert(alignof(UAttribMod) == 0x000008, "Wrong alignment on UAttribMod");
static_assert(sizeof(UAttribMod) == 0x000128, "Wrong size on UAttribMod");
static_assert(offsetof(UAttribMod, OnAttribModTick) == 0x000028, "Member 'UAttribMod::OnAttribModTick' has a wrong offset!");
static_assert(offsetof(UAttribMod, OnAttribValueChanged) == 0x000038, "Member 'UAttribMod::OnAttribValueChanged' has a wrong offset!");
static_assert(offsetof(UAttribMod, ApplyType) == 0x000048, "Member 'UAttribMod::ApplyType' has a wrong offset!");
static_assert(offsetof(UAttribMod, StackType) == 0x000049, "Member 'UAttribMod::StackType' has a wrong offset!");
static_assert(offsetof(UAttribMod, ExpireFlags) == 0x00004A, "Member 'UAttribMod::ExpireFlags' has a wrong offset!");
static_assert(offsetof(UAttribMod, ModFlags) == 0x00004B, "Member 'UAttribMod::ModFlags' has a wrong offset!");
static_assert(offsetof(UAttribMod, DamageType) == 0x000050, "Member 'UAttribMod::DamageType' has a wrong offset!");
static_assert(offsetof(UAttribMod, BonusType) == 0x000058, "Member 'UAttribMod::BonusType' has a wrong offset!");
static_assert(offsetof(UAttribMod, FunctionType) == 0x000059, "Member 'UAttribMod::FunctionType' has a wrong offset!");
static_assert(offsetof(UAttribMod, Category) == 0x00005C, "Member 'UAttribMod::Category' has a wrong offset!");
static_assert(offsetof(UAttribMod, TickCount) == 0x000064, "Member 'UAttribMod::TickCount' has a wrong offset!");
static_assert(offsetof(UAttribMod, CurrentTickCount) == 0x000068, "Member 'UAttribMod::CurrentTickCount' has a wrong offset!");
static_assert(offsetof(UAttribMod, RampUpTime) == 0x00006C, "Member 'UAttribMod::RampUpTime' has a wrong offset!");
static_assert(offsetof(UAttribMod, RampDownTime) == 0x000070, "Member 'UAttribMod::RampDownTime' has a wrong offset!");
static_assert(offsetof(UAttribMod, ArmorPenetration) == 0x000074, "Member 'UAttribMod::ArmorPenetration' has a wrong offset!");
static_assert(offsetof(UAttribMod, PierceResistance) == 0x000078, "Member 'UAttribMod::PierceResistance' has a wrong offset!");
static_assert(offsetof(UAttribMod, CriticalChance) == 0x00007C, "Member 'UAttribMod::CriticalChance' has a wrong offset!");
static_assert(offsetof(UAttribMod, CriticalDamage) == 0x000080, "Member 'UAttribMod::CriticalDamage' has a wrong offset!");
static_assert(offsetof(UAttribMod, ExpireModCategoriesOnApply) == 0x000088, "Member 'UAttribMod::ExpireModCategoriesOnApply' has a wrong offset!");
static_assert(offsetof(UAttribMod, ApplyOnExpireMods) == 0x000098, "Member 'UAttribMod::ApplyOnExpireMods' has a wrong offset!");
static_assert(offsetof(UAttribMod, DependsOnAttribInstance) == 0x0000A8, "Member 'UAttribMod::DependsOnAttribInstance' has a wrong offset!");
static_assert(offsetof(UAttribMod, ScaleAttribInstance) == 0x0000B0, "Member 'UAttribMod::ScaleAttribInstance' has a wrong offset!");
static_assert(offsetof(UAttribMod, TickRateCurve) == 0x0000B8, "Member 'UAttribMod::TickRateCurve' has a wrong offset!");
static_assert(offsetof(UAttribMod, SourceActor) == 0x0000C0, "Member 'UAttribMod::SourceActor' has a wrong offset!");
static_assert(offsetof(UAttribMod, UserParams) == 0x0000C8, "Member 'UAttribMod::UserParams' has a wrong offset!");
static_assert(offsetof(UAttribMod, SoftMinValue) == 0x0000D0, "Member 'UAttribMod::SoftMinValue' has a wrong offset!");
static_assert(offsetof(UAttribMod, SoftMaxValue) == 0x0000D4, "Member 'UAttribMod::SoftMaxValue' has a wrong offset!");

// Class AttributeSystem.AttributeDef
// 0x0090 (0x00C0 - 0x0030)
class UAttributeDef final : public UDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAttributeDef>           MinValueAttrib;                                    // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAttributeDef>           MaxValueAttrib;                                    // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultValue;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DecimalPlaces;                                     // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeDef">();
	}
	static class UAttributeDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeDef>();
	}
};
static_assert(alignof(UAttributeDef) == 0x000008, "Wrong alignment on UAttributeDef");
static_assert(sizeof(UAttributeDef) == 0x0000C0, "Wrong size on UAttributeDef");
static_assert(offsetof(UAttributeDef, DisplayName) == 0x000030, "Member 'UAttributeDef::DisplayName' has a wrong offset!");
static_assert(offsetof(UAttributeDef, Description) == 0x000048, "Member 'UAttributeDef::Description' has a wrong offset!");
static_assert(offsetof(UAttributeDef, MinValueAttrib) == 0x000060, "Member 'UAttributeDef::MinValueAttrib' has a wrong offset!");
static_assert(offsetof(UAttributeDef, MaxValueAttrib) == 0x000088, "Member 'UAttributeDef::MaxValueAttrib' has a wrong offset!");
static_assert(offsetof(UAttributeDef, MinValue) == 0x0000B0, "Member 'UAttributeDef::MinValue' has a wrong offset!");
static_assert(offsetof(UAttributeDef, MaxValue) == 0x0000B4, "Member 'UAttributeDef::MaxValue' has a wrong offset!");
static_assert(offsetof(UAttributeDef, DefaultValue) == 0x0000B8, "Member 'UAttributeDef::DefaultValue' has a wrong offset!");
static_assert(offsetof(UAttributeDef, DecimalPlaces) == 0x0000BC, "Member 'UAttributeDef::DecimalPlaces' has a wrong offset!");

}

